ca65 V2.17 - Git 2b0172e4
Main file   : 6502_functional_test.a65
Current file: 6502_functional_test.a65

000000r 1               ;
000000r 1               ; 6 5 0 2   F U N C T I O N A L   T E S T
000000r 1               ;
000000r 1               ; Copyright (C) 2012-2015  Klaus Dormann
000000r 1               ;
000000r 1               ; This program is free software: you can redistribute it and/or modify
000000r 1               ; it under the terms of the GNU General Public License as published by
000000r 1               ; the Free Software Foundation, either version 3 of the License, or
000000r 1               ; (at your option) any later version.
000000r 1               ;
000000r 1               ; This program is distributed in the hope that it will be useful,
000000r 1               ; but WITHOUT ANY WARRANTY; without even the implied warranty of
000000r 1               ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
000000r 1               ; GNU General Public License for more details.
000000r 1               ;
000000r 1               ; You should have received a copy of the GNU General Public License
000000r 1               ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
000000r 1               
000000r 1               
000000r 1               ; This program is designed to test all opcodes of a 6502 emulator using all
000000r 1               ; addressing modes with focus on propper setting of the processor status
000000r 1               ; register bits.
000000r 1               ;
000000r 1               ; version 04-dec-2017
000000r 1               ; contact info at http://2m5.de or email K@2m5.de
000000r 1               ;
000000r 1               ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
000000r 1               ; command line switches: -l -m -s2 -w -h0
000000r 1               ;                         |  |  |   |  no page headers in listing
000000r 1               ;                         |  |  |   wide listing (133 char/col)
000000r 1               ;                         |  |  write intel hex file instead of binary
000000r 1               ;                         |  expand macros in listing
000000r 1               ;                         generate pass2 listing
000000r 1               ;
000000r 1               ; No IO - should be run from a monitor with access to registers.
000000r 1               ; To run load intel hex image with a load command, than alter PC to 400 hex
000000r 1               ; (code_segment) and enter a go command.
000000r 1               ; Loop on program counter determines error or successful completion of test.
000000r 1               ; Check listing for relevant traps (jump/branch *).
000000r 1               ; Please note that in early tests some instructions will have to be used before
000000r 1               ; they are actually tested!
000000r 1               ;
000000r 1               ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
000000r 1               ; Tests documented behavior of the original NMOS 6502 only! No unofficial
000000r 1               ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
000000r 1               ; not be tested. Decimal ops will only be tested with valid BCD operands and
000000r 1               ; N V Z flags will be ignored.
000000r 1               ;
000000r 1               ; Debugging hints:
000000r 1               ;     Most of the code is written s:=entially. if you hit a trap, check the
000000r 1               ;   immediately preceeding code for the instruction to be tested. Results are
000000r 1               ;   tested first, flags are checked second by pushing them onto the stack and
000000r 1               ;   pulling them to the accumulator after the result was checked. The "real"
000000r 1               ;   flags are no longer valid for the tested instruction at this time!
000000r 1               ;     If the tested instruction was indexed, the relevant index (X or Y) must
000000r 1               ;   also be checked. Opposed to the flags, X and Y registers are still valid.
000000r 1               ;
000000r 1               ; versions:
000000r 1               ;   28-jul-2012  1st version distributed for testing
000000r 1               ;   29-jul-2012  fixed references to location 0, now #0
000000r 1               ;                added license - GPLv3
000000r 1               ;   30-jul-2012  added configuration options
000000r 1               ;   01-aug-2012  added trap macro to allow user to change error handling
000000r 1               ;   01-dec-2012  fixed trap in branch field must be a branch
000000r 1               ;   02-mar-2013  fixed PLA flags not tested
000000r 1               ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
000000r 1               ;                added test s:=ence check to detect if tests jump their fence
000000r 1               ;   23-jul-2013  added RAM integrity check option
000000r 1               ;   16-aug-2013  added error report to standard output option
000000r 1               ;   13-dec-2014  added binary/decimal opcode table switch test
000000r 1               ;   14-dec-2014  improved relative address test
000000r 1               ;   23-aug-2015  added option to disable self modifying tests
000000r 1               ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
000000r 1               ;                added small branch offset pretest
000000r 1               ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
000000r 1               ;   04-dec-2017  fixed BRK only tested with interrupts enabled
000000r 1               ;                added option to skip the remainder of a failing test
000000r 1               ;                in report.i65
000000r 1               
000000r 1               
000000r 1               ; C O N F I G U R A T I O N
000000r 1               
000000r 1               ;ROM_vectors writable (0=no, 1=yes)
000000r 1               ;if ROM vectors can not be used interrupts will not be trapped
000000r 1               ;as a conseqence BRK can not be tested but will be emulated to test RTI
000000r 1               ROM_vectors		:=	1
000000r 1               
000000r 1               ;load_data_direct (0=move from code segment, 1=load directly)
000000r 1               ;loading directly is preferred but may not be supported by your platform
000000r 1               ;0 produces only consecutive object code, 1 is not suitable for a binary image
000000r 1               load_data_direct		:=	1
000000r 1               
000000r 1               ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
000000r 1               ;change) 2 r:=ires extra code and is not recommended. SEI & CLI can only be
000000r 1               ;tested if you allow changing the interrupt status (I_flag = 3)
000000r 1               I_flag		:=	3
000000r 1               
000000r 1               ;configure memory - try to stay away from memory used by the system
000000r 1               ;zero_page memory start address, $50 (80) consecutive Bytes r:=ired
000000r 1               ;                                add 2 if I_flag = 2
000000r 1               zero_page		:=	$a
000000r 1               
000000r 1               ;data_segment memory start address, $6A (106) consecutive Bytes r:=ired
000000r 1               data_segment		:=	$200
000000r 1               .if ((data_segment & $ff) <> 0)
000000r 1                       ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
000000r 1               .endif
000000r 1               
000000r 1               ;code_segment memory start address, 13kB of consecutive space r:=ired
000000r 1               ;                                   add 2.5 kB if I_flag = 2
000000r 1               code_segment		:=	$400
000000r 1               
000000r 1               ;self modifying code may be disabled to allow running in ROM
000000r 1               ;0=part of the code is self modifying and must reside in RAM
000000r 1               ;1=tests disabled: branch range
000000r 1               disable_selfmod		:=	0
000000r 1               
000000r 1               ;report errors through I/O channel (0=use standard self trap loops, 1=include
000000r 1               ;report.i65 as I/O channel, add 3.5 kB)
000000r 1               report		:=	1
000000r 1               rep_int     :=  0
000000r 1               
000000r 1               ;RAM integrity test option. Checks for undesired RAM writes.
000000r 1               ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
000000r 1               ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
000000r 1               ram_top		:=	-1
000000r 1               
000000r 1               ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
000000r 1               ;2=disable including decimal flag in processor status
000000r 1               disable_decimal		:=	0
000000r 1               
000000r 1               ;;        noopt       ;do not take shortcuts
000000r 1               
000000r 1               ;macros for error & success traps to allow user modification
000000r 1               ;example:
000000r 1               ;trap    macro
000000r 1               ;        jsr my_error_handler
000000r 1               ;        endm
000000r 1               ;trap_eq macro
000000r 1               ;        bne skip
000000r 1               ;        trap           ;failed :=al (zero)
000000r 1               ;skip
000000r 1               ;        endm
000000r 1               ;
000000r 1               ; my_error_handler should pop the calling address from the stack and report it.
000000r 1               ; putting larger portions of code (more than 3 bytes) inside the trap macro
000000r 1               ; may lead to branch range problems for some tests.
000000r 1               .if report = 0
000000r 1               .macro	trap
000000r 1                       jmp *           ;failed anyway
000000r 1               .endmacro
000000r 1               .macro	trap_eq
000000r 1                       beq *           ;failed :=al (zero)
000000r 1               .endmacro
000000r 1               .macro	trap_ne
000000r 1                       bne *           ;failed not :=al (non zero)
000000r 1               .endmacro
000000r 1               .macro	trap_cs
000000r 1                       bcs *           ;failed carry set
000000r 1               .endmacro
000000r 1               .macro	trap_cc
000000r 1                       bcc *           ;failed carry clear
000000r 1               .endmacro
000000r 1               .macro	trap_mi
000000r 1                       bmi *           ;failed minus (bit 7 set)
000000r 1               .endmacro
000000r 1               .macro	trap_pl
000000r 1                       bpl *           ;failed plus (bit 7 clear)
000000r 1               .endmacro
000000r 1               .macro	trap_vs
000000r 1                       bvs *           ;failed overflow set
000000r 1               .endmacro
000000r 1               .macro	trap_vc
000000r 1                       bvc *           ;failed overflow clear
000000r 1               .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1               .macro	success
000000r 1                       jmp *           ;test passed, no errors
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if report = 1
000000r 1               .macro	trap
000000r 1                       .local skip
000000r 1                       jsr report_error
000000r 1               .endmacro
000000r 1               .macro	trap_eq
000000r 1                       .local skip
000000r 1                       bne skip
000000r 1                       trap           ;failed :=al (zero)
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_ne
000000r 1                       .local skip
000000r 1                       beq skip
000000r 1                       trap            ;failed not :=al (non zero)
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_cs
000000r 1                       .local skip
000000r 1                       bcc skip
000000r 1                       trap            ;failed carry set
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_cc
000000r 1                       .local skip
000000r 1                       bcs skip
000000r 1                       trap            ;failed carry clear
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_mi
000000r 1                       .local skip
000000r 1                       bpl skip
000000r 1                       trap            ;failed minus (bit 7 set)
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_pl
000000r 1                       .local skip
000000r 1                       bmi skip
000000r 1                       trap            ;failed plus (bit 7 clear)
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_vs
000000r 1                       .local skip
000000r 1                       bvc skip
000000r 1                       trap            ;failed overflow set
000000r 1               skip:
000000r 1               .endmacro
000000r 1               .macro	trap_vc
000000r 1                       .local skip
000000r 1                       bvs skip
000000r 1                       trap            ;failed overflow clear
000000r 1               skip:
000000r 1               .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1               .macro	success
000000r 1                       jsr report_success
000000r 1               .endmacro
000000r 1               .endif
000000r 1               
000000r 1               
000000r 1               carry   := %00000001   ;flag bits in status
000000r 1               zero    := %00000010
000000r 1               intdis  := %00000100
000000r 1               decmode := %00001000
000000r 1               break   := %00010000
000000r 1               reserv  := %00100000
000000r 1               overfl  := %01000000
000000r 1               minus   := %10000000
000000r 1               
000000r 1               fc      := carry
000000r 1               fz      := zero
000000r 1               fzc     := carry+zero
000000r 1               fv      := overfl
000000r 1               fvz     := overfl+zero
000000r 1               fn      := minus
000000r 1               fnc     := minus+carry
000000r 1               fnz     := minus+zero
000000r 1               fnzc    := minus+zero+carry
000000r 1               fnv     := minus+overfl
000000r 1               
000000r 1               fao     := break+reserv    ;bits always on after PHP, BRK
000000r 1               fai     := fao+intdis      ;+ forced interrupt disable
000000r 1               faod    := fao+decmode     ;+ ignore decimal
000000r 1               faid    := fai+decmode     ;+ ignore decimal
000000r 1               m8      := $ff             ;8 bit mask
000000r 1               m8i     := $ff&~intdis     ;8 bit mask - interrupt disable
000000r 1               
000000r 1               ;macros to allow masking of status bits.
000000r 1               ;masking test of decimal bit
000000r 1               ;masking of interrupt enable/disable on load and compare
000000r 1               ;masking of always on bits after PHP or BRK (unused & break) on compare
000000r 1               .if disable_decimal < 2
000000r 1               .if I_flag = 0
000000r 1               .macro	load_flag f
000000r 1                           lda #f & m8i         ;force enable interrupts (mask I)
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           cmp #(f | fao) & m8i   ;I_flag is always enabled + always on bits
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           eor #( f & m8i | fao)   ;mask I, invert expected flags + always on bits
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if I_flag = 1
000000r 1               .macro	load_flag f
000000r 1                           lda #f | intdis      ;force disable interrupts
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           cmp #(f | fai) & m8    ;I_flag is always disabled + always on bits
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           eor #(f | fai)       ;invert expected flags + always on bits + I
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if I_flag = 2
000000r 1               .macro	load_flag f
000000r 1                           lda #f
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1               .endmacro
000000r 1               .macro	cmp_flag d
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           cmp #(f | fao) & m8i   ;expected flags + always on bits, mask I
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           eor #(f & m8i | fao)   ;mask I, invert expected flags + always on bits
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if I_flag = 3
000000r 1               .macro	load_flag f
000000r 1                           lda #f             ;allow test to change I-flag (no mask)
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           cmp #(f | fao) & m8    ;expected flags + always on bits
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           eor #f | fao         ;invert expected flags + always on bits
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .else
000000r 1               .if I_flag = 0
000000r 1               .macro	load_flag f
000000r 1                           lda #f & m8i         ;force enable interrupts (mask I)
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(f | faod) & m8i  ;I_flag is always enabled + always on bits
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(f & m8i | faod)  ;mask I, invert expected flags + always on bits
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if I_flag = 1
000000r 1               .macro	load_flag f
000000r 1                           lda #f | intdis      ;force disable interrupts
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(f | faid) & m8   ;I_flag is always disabled + always on bits
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(f | faid)      ;invert expected flags + always on bits + I
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if I_flag = 2
000000r 1               .macro	load_flag f
000000r 1                           lda #f
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(f | faod) & m8i  ;expected flags + always on bits, mask I
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(f & m8i | faod)  ;mask I, invert expected flags + always on bits
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .if I_flag = 3
000000r 1               .macro	load_flag f
000000r 1                           lda #f             ;allow test to change I-flag (no mask)
000000r 1               .endmacro
000000r 1               .macro	cmp_flag f
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(f | faod) & m8   ;expected flags + always on bits
000000r 1               .endmacro
000000r 1               .macro	eor_flag f
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor # f | faod        ;invert expected flags + always on bits
000000r 1               .endmacro
000000r 1               .endif
000000r 1               .endif
000000r 1               
000000r 1               ;macros to set (register|memory|zeropage) & status
000000r 1               .macro	set_stat f      ;setting flags in the processor status register
000000r 1                           load_flag f
000000r 1                           pha         ;use stack to load status
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_a  acc, fla     ;precharging accu & status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda #acc     ;precharge accu
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_x     acc, fla   ;precharging index & status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           ldx #acc    ;precharge index x
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_y acc, fla      ;precharging index & status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           ldy #acc     ;precharge index y
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_ax acc, fla       ;precharging indexed accu & immediate status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda acc,x    ;precharge accu
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_ay acc, fla      ;precharging indexed accu & immediate status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda acc,y    ;precharge accu
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_z acc, fla      ;precharging indexed zp & immediate status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda acc,x    ;load to zeropage
000000r 1                           sta zpt
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_zx acc, fla      ;precharging zp,x & immediate status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda acc,x    ;load to indexed zeropage
000000r 1                           sta zpt,x
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_abs acc, fla      ;precharging indexed memory & immediate status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda acc,x    ;load to memory
000000r 1                           sta abst
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	set_absx acc, fla      ;precharging abs,x & immediate status
000000r 1                           load_flag fla
000000r 1                           pha         ;use stack to load status
000000r 1                           lda acc,x    ;load to indexed memory
000000r 1                           sta abst,x
000000r 1                           plp
000000r 1               .endmacro
000000r 1               
000000r 1               ;macros to test (register|memory|zeropage) & status & (mask)
000000r 1               .macro	tst_stat acc      ;testing flags in the processor status register
000000r 1                           php         ;save status
000000r 1                           pla         ;use stack to retrieve status
000000r 1                           pha
000000r 1                           cmp_flag acc
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_a acc, fla      ;testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp #acc     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag fla
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_x acc,fla      ;testing result in x index & flags
000000r 1                           php         ;save flags
000000r 1                           cpx #acc     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag fla
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_y  acc,fla     ;testing result in y index & flags
000000r 1                           php         ;save flags
000000r 1                           cpy #acc     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag fla
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_ax acc1, acc2, fla      ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp acc1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag fla
000000r 1                           cmp acc2,x    ;test flags
000000r 1                           trap_ne     ;
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_ay acc1, acc2, fla      ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp acc1,y    ;test result
000000r 1                           trap_ne     ;
000000r 1                           pla         ;load status
000000r 1                           eor_flag fla
000000r 1                           cmp acc2,y    ;test flags
000000r 1                           trap_ne
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_z acc1,acc2,fla      ;indexed testing result in zp & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt
000000r 1                           cmp acc1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag fla
000000r 1                           cmp acc2,x    ;test flags
000000r 1                           trap_ne
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_zx acc1,acc2,fla      ;testing result in zp,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt,x
000000r 1                           cmp acc1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag fla
000000r 1                           cmp acc2,x    ;test flags
000000r 1                           trap_ne
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_abs acc1,acc2,fla      ;indexed testing result in memory & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst
000000r 1                           cmp acc1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag fla
000000r 1                           cmp acc2,x    ;test flags
000000r 1                           trap_ne
000000r 1               .endmacro
000000r 1               
000000r 1               .macro	tst_absx acc1,acc2,fla      ;testing result in abs,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst,x
000000r 1                           cmp acc1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag fla
000000r 1                           cmp acc2,x    ;test flags
000000r 1                           trap_ne
000000r 1               .endmacro
000000r 1               
000000r 1               ; RAM integrity test
000000r 1               ;   verifies that none of the previous tests has altered RAM outside of the
000000r 1               ;   designated write areas.
000000r 1               ;   uses zpt word as indirect pointer, zpt+2 word as checksum
000000r 1               .if ram_top > -1
000000r 1               .macro	check_ram
000000r 1                           cld
000000r 1                           lda #0
000000r 1                           sta zpt         ;set low byte of indirect pointer
000000r 1                           sta zpt+3       ;checksum high byte
000000r 1               .if disable_selfmod = 0
000000r 1                           sta range_adr   ;reset self modifying code
000000r 1               .endif
000000r 1                           clc
000000r 1                           ldx #zp_bss-zero_page ;zeropage - write test area
000000r 1               ccs3:      adc zero_page,x
000000r 1                           bcc ccs2
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs2:      inx
000000r 1                           bne ccs3
000000r 1                           ldx #>(abs1)   ;set high byte of indirect pointer
000000r 1                           stx zpt+1
000000r 1                           ldy #<(abs1)   ;data after write & execute test area
000000r 1               ccs5:      adc (zpt),y
000000r 1                           bcc ccs4
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs4:      iny
000000r 1                           bne ccs5
000000r 1                           inx             ;advance RAM high address
000000r 1                           stx zpt+1
000000r 1                           cpx #ram_top
000000r 1                           bne ccs5
000000r 1                           sta zpt+2       ;checksum low is
000000r 1                           cmp ram_chksm   ;checksum low expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           lda zpt+3       ;checksum high is
000000r 1                           cmp ram_chksm+1 ;checksum high expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1               .endmacro
000000r 1               .else
000000r 1               .macro	check_ram
000000r 1                           ;RAM check disabled - RAM size not set
000000r 1               .endmacro
000000r 1               .endif
000000r 1               
000000r 1               .macro	next_test           ;make sure, tests don't jump the fence
000000r 1                           lda test_case   ;previous test
000000r 1                           cmp #test_num
000000r 1                           trap_ne         ;test is out of sequence
000000r 1               test_num		.set	test_num + 1
000000r 1                           lda #test_num   ;*** next tests' number
000000r 1                           sta test_case
000000r 1                           ;check_ram       ;uncomment to find altered RAM after each test
000000r 1               .endmacro
000000r 1               ;;??;;.if load_data_direct = 1
000000r 1               ;;??;;        data
000000r 1               ;;??;;.else
000000r 1               ;;??;;        bss                 ;uninitialized segment, copy of data at end of code!
000000r 1               ;;??;;.endif
000000r 1                       .zeropage
000000r 1               ;break test interrupt save
000000r 1  xx           irq_a:   .res  1               ;a register
000001r 1  xx           irq_x:   .res  1               ;x register
000002r 1               .if I_flag = 2
000002r 1               ;masking for I bit in status
000002r 1               flag_I_on:   .res  1           ;or mask to load flags
000002r 1               flag_I_off:  .res  1           ;and mask to load flags
000002r 1               .endif
000002r 1               zpt:                         ;5 bytes store/modify test area
000002r 1               ;add/subtract operand generation and result/flag prediction
000002r 1  xx           adfc:    .res  1               ;carry flag before op
000003r 1  xx           ad1:     .res  1               ;operand 1 - accumulator
000004r 1  xx           ad2:     .res  1               ;operand 2 - memory / immediate
000005r 1  xx           adrl:    .res  1               ;expected result bits 0-7
000006r 1  xx           adrh:    .res  1               ;expected result bit 8 (carry)
000007r 1  xx           adrf:    .res  1               ;expected flags NV0000ZC (only binary mode)
000008r 1  xx           sb2:     .res  1               ;operand 2 complemented for subtract
000009r 1               zp_bss:
000009r 1  C3 82 41 00  zp1:     .byte  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00000Dr 1  7F           zp7f:    .byte  $7f             ;test pattern for compare
00000Er 1               ;logical zeropage operands
00000Er 1  00 1F 71 80  zpOR:    .byte  0,$1f,$71,$80   ;test pattern for OR
000012r 1  0F FF 7F 80  zpAN:    .byte  $0f,$ff,$7f,$80 ;test pattern for AND
000016r 1  FF 0F 8F 8F  zpEO:    .byte  $ff,$0f,$8f,$8f ;test pattern for EOR
00001Ar 1               ;indirect addressing pointers
00001Ar 1  17 02        ind1:    .word  abs1            ;indirect pointer to pattern in absolute memory
00001Cr 1  18 02                .word  abs1+1
00001Er 1  19 02                .word  abs1+2
000020r 1  1A 02                .word  abs1+3
000022r 1  1B 02                .word  abs7f
000024r 1  1F 01        inw1:    .word  abs1-$f8        ;indirect pointer for wrap-test pattern
000026r 1  03 02        indt:    .word  abst            ;indirect pointer to store area in absolute memory
000028r 1  04 02                .word  abst+1
00002Ar 1  05 02                .word  abst+2
00002Cr 1  06 02                .word  abst+3
00002Er 1  0B 01        inwt:    .word  abst-$f8        ;indirect pointer for wrap-test store
000030r 1  4E 02        indAN:   .word  absAN           ;indirect pointer to AND pattern in absolute memory
000032r 1  4F 02                .word  absAN+1
000034r 1  50 02                .word  absAN+2
000036r 1  51 02                .word  absAN+3
000038r 1  52 02        indEO:   .word  absEO           ;indirect pointer to EOR pattern in absolute memory
00003Ar 1  53 02                .word  absEO+1
00003Cr 1  54 02                .word  absEO+2
00003Er 1  55 02                .word  absEO+3
000040r 1  4A 02        indOR:   .word  absOR           ;indirect pointer to OR pattern in absolute memory
000042r 1  4B 02                .word  absOR+1
000044r 1  4C 02                .word  absOR+2
000046r 1  4D 02                .word  absOR+3
000048r 1               ;add/subtract indirect pointers
000048r 1  03 02        adi2:    .word  ada2            ;indirect pointer to operand 2 in absolute memory
00004Ar 1  04 02        sbi2:    .word  sba2            ;indirect pointer to complemented operand 2 (SBC)
00004Cr 1  04 01        adiy2:   .word  ada2-$ff        ;with offset for indirect indexed
00004Er 1  05 01        sbiy2:   .word  sba2-$ff
000050r 1               zp_bss_end:
000050r 1               
000050r 1                       .data
000000r 1                       .org data_segment
000200  1  xx           test_case:   .res  1           ;current test number
000201  1  xx xx        ram_chksm:   .res  2           ;checksum for RAM integrity test
000203  1               ;add/subtract operand copy - abs tests write area
000203  1               abst:                        ;5 bytes store/modify test area
000203  1  xx           ada2:    .res  1               ;operand 2
000204  1  xx           sba2:    .res  1               ;operand 2 complemented for subtract
000205  1  xx xx xx             .res  3               ;fill remaining bytes
000208  1               data_bss:
000208  1               .if load_data_direct = 1
000208  1  29 00        ex_andi: and #0              ;execute immediate opcodes
00020A  1  60                   rts
00020B  1  49 00        ex_eori: eor #0              ;execute immediate opcodes
00020D  1  60                   rts
00020E  1  09 00        ex_orai: ora #0              ;execute immediate opcodes
000210  1  60                   rts
000211  1  69 00        ex_adci: adc #0              ;execute immediate opcodes
000213  1  60                   rts
000214  1  E9 00        ex_sbci: sbc #0              ;execute immediate opcodes
000216  1  60                   rts
000217  1               .else
000217  1               ex_andi: .res  3
000217  1               ex_eori: .res  3
000217  1               ex_orai: .res  3
000217  1               ex_adci: .res  3
000217  1               ex_sbci: .res  3
000217  1               .endif
000217  1  C3 82 41 00  abs1:    .byte  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00021B  1  7F           abs7f:   .byte  $7f             ;test pattern for compare
00021C  1               ;loads
00021C  1  80 80 00 02  fLDx:    .byte  fn,fn,0,fz      ;expected flags for load
000220  1               ;shifts
000220  1               rASL:                        ;expected result ASL & ROL -carry
000220  1  86 04 82 00  rROL:    .byte  $86,$04,$82,0   ; "
000224  1  87 05 83 01  rROLc:   .byte  $87,$05,$83,1   ;expected result ROL +carry
000228  1               rLSR:                        ;expected result LSR & ROR -carry
000228  1  61 41 20 00  rROR:    .byte  $61,$41,$20,0   ; "
00022C  1  E1 C1 A0 80  rRORc:   .byte  $e1,$c1,$a0,$80 ;expected result ROR +carry
000230  1               fASL:                        ;expected flags for shifts
000230  1  81 01 80 02  fROL:    .byte  fnc,fc,fn,fz    ;no carry in
000234  1  81 01 80 00  fROLc:   .byte  fnc,fc,fn,0     ;carry in
000238  1               fLSR:
000238  1  01 00 01 02  fROR:    .byte  fc,0,fc,fz      ;no carry in
00023C  1  81 80 81 80  fRORc:   .byte  fnc,fn,fnc,fn   ;carry in
000240  1               ;increments (decrements)
000240  1  7F 80 FF 00  rINC:    .byte  $7f,$80,$ff,0,1 ;expected result for INC/DEC
000244  1  01           
000245  1  00 80 80 02  fINC:    .byte  0,fn,fn,fz,0    ;expected flags for INC/DEC
000249  1  00           
00024A  1               ;logical memory operand
00024A  1  00 1F 71 80  absOR:   .byte  0,$1f,$71,$80   ;test pattern for OR
00024E  1  0F FF 7F 80  absAN:   .byte  $0f,$ff,$7f,$80 ;test pattern for AND
000252  1  FF 0F 8F 8F  absEO:   .byte  $ff,$0f,$8f,$8f ;test pattern for EOR
000256  1               ;logical accu operand
000256  1  00 F1 1F 00  absORa:  .byte  0,$f1,$1f,0     ;test pattern for OR
00025A  1  F0 FF FF FF  absANa:  .byte  $f0,$ff,$ff,$ff ;test pattern for AND
00025E  1  FF F0 F0 0F  absEOa:  .byte  $ff,$f0,$f0,$0f ;test pattern for EOR
000262  1               ;logical results
000262  1  00 FF 7F 80  absrlo:  .byte  0,$ff,$7f,$80
000266  1  02 80 00 80  absflo:  .byte  fz,fn,0,fn
00026A  1               data_bss_end:
00026A  1               
00026A  1               
00026A  1                       .code
00026A  1                       .org code_segment
000400  1  D8           start:   cld
000401  1  A2 FF                ldx #$ff
000403  1  9A                   txs
000404  1  A9 00                lda #0          ;*** test 0 = initialize
000406  1  8D 00 02             sta test_case
000409  1               test_num		.set	0
000409  1               
000409  1               ;stop interrupts before initializing BSS
000409  1               .if I_flag = 1
000409  1                       sei
000409  1               .endif
000409  1               
000409  1               ;initialize I/O for report channel
000409  1               .if report = 1
000409  1  20 49 44             jsr report_init
00040C  1               .endif
00040C  1               
00040C  1               ;pretest small branch offset
00040C  1  A2 05                ldx #5
00040E  1  4C 36 04             jmp psb_test
000411  1               psb_bwok:
000411  1  A0 05                ldy #5
000413  1  D0 08                bne psb_forw
000415  1  20 58 44             trap        ;branch should be taken
000418  1  88                   dey         ;forward landing zone
000419  1  88                   dey
00041A  1  88                   dey
00041B  1  88                   dey
00041C  1  88                   dey
00041D  1               psb_forw:
00041D  1  88                   dey
00041E  1  88                   dey
00041F  1  88                   dey
000420  1  88                   dey
000421  1  88                   dey
000422  1  F0 17                beq psb_fwok
000424  1  20 58 44             trap        ;forward offset
000427  1               
000427  1  CA                   dex         ;backward landing zone
000428  1  CA                   dex
000429  1  CA                   dex
00042A  1  CA                   dex
00042B  1  CA                   dex
00042C  1               psb_back:
00042C  1  CA                   dex
00042D  1  CA                   dex
00042E  1  CA                   dex
00042F  1  CA                   dex
000430  1  CA                   dex
000431  1  F0 DE                beq psb_bwok
000433  1  20 58 44             trap        ;backward offset
000436  1               psb_test:
000436  1  D0 F4                bne psb_back
000438  1  20 58 44             trap        ;branch should be taken
00043B  1               psb_fwok:
00043B  1               
00043B  1               ;initialize BSS segment
00043B  1               .if load_data_direct <> 1
00043B  1                       ldx #zp_end-zp_init-1
00043B  1               ld_zp:   lda zp_init,x
00043B  1                       sta zp_bss,x
00043B  1                       dex
00043B  1                       bpl ld_zp
00043B  1                       ldx #data_end-data_init-1
00043B  1               ld_data: lda data_init,x
00043B  1                       sta data_bss,x
00043B  1                       dex
00043B  1                       bpl ld_data
00043B  1               .if ROM_vectors = 1
00043B  1                       ldx #5
00043B  1               ld_vect: lda vec_init,x
00043B  1                       sta vec_bss,x
00043B  1                       dex
00043B  1                       bpl ld_vect
00043B  1               .endif
00043B  1               .endif
00043B  1               
00043B  1               ;retain status of interrupt flag
00043B  1               .if I_flag = 2
00043B  1                       php
00043B  1                       pla
00043B  1                       and #4          ;isolate flag
00043B  1                       sta flag_I_on   ;or mask
00043B  1                       eor #<(~4)     ;reverse
00043B  1                       sta flag_I_off  ;and mask
00043B  1               .endif
00043B  1               
00043B  1               ;generate checksum for RAM integrity test
00043B  1               .if ram_top > -1
00043B  1                       lda #0
00043B  1                       sta zpt         ;set low byte of indirect pointer
00043B  1                       sta ram_chksm+1 ;checksum high byte
00043B  1               .if disable_selfmod = 0
00043B  1                       sta range_adr   ;reset self modifying code
00043B  1               .endif
00043B  1                       clc
00043B  1                       ldx #zp_bss-zero_page ;zeropage - write test area
00043B  1               gcs3:    adc zero_page,x
00043B  1                       bcc gcs2
00043B  1                       inc ram_chksm+1 ;carry to high byte
00043B  1                       clc
00043B  1               gcs2:    inx
00043B  1                       bne gcs3
00043B  1                       ldx #>(abs1)   ;set high byte of indirect pointer
00043B  1                       stx zpt+1
00043B  1                       ldy #<(abs1)   ;data after write & execute test area
00043B  1               gcs5:    adc (zpt),y
00043B  1                       bcc gcs4
00043B  1                       inc ram_chksm+1 ;carry to high byte
00043B  1                       clc
00043B  1               gcs4:    iny
00043B  1                       bne gcs5
00043B  1                       inx             ;advance RAM high address
00043B  1                       stx zpt+1
00043B  1                       cpx #ram_top
00043B  1                       bne gcs5
00043B  1                       sta ram_chksm   ;checksum complete
00043B  1               .endif
00043B  1  AD 00 02 C9          next_test
00043F  1  00 F0 03 20  
000443  1  58 44 A9 01  
00044A  1               .if disable_selfmod = 0
00044A  1               ;testing relative addressing with BEQ
00044A  1  A0 FE                ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
00044C  1               range_loop:
00044C  1  88                   dey             ;next relative address
00044D  1  98                   tya
00044E  1  AA                   tax             ;precharge count to end of loop
00044F  1  10 08                bpl range_fw    ;calculate relative address
000451  1  18                   clc             ;avoid branch self or to relative address of branch
000452  1  69 02                adc #2
000454  1  EA                   nop             ;offset landing zone - tolerate +/-5 offset to branch
000455  1  EA                   nop
000456  1  EA                   nop
000457  1  EA                   nop
000458  1  EA                   nop
000459  1               range_fw:
000459  1  EA                   nop
00045A  1  EA                   nop
00045B  1  EA                   nop
00045C  1  EA                   nop
00045D  1  EA                   nop
00045E  1  49 7F                eor #$7f        ;complement except sign
000460  1  8D EC 04             sta range_adr   ;load into test target
000463  1  A9 00                lda #0          ;should set zero flag in status register
000465  1  4C EB 04             jmp range_op
000468  1               
000468  1  CA                   dex             ; offset landing zone - backward branch too far
000469  1  CA                   dex
00046A  1  CA                   dex
00046B  1  CA                   dex
00046C  1  CA                   dex
00046D  1                       ;relative address target field with branch under test in the middle
00046D  1  CA                   dex             ;-128 - max backward
00046E  1  CA                   dex
00046F  1  CA                   dex
000470  1  CA                   dex
000471  1  CA                   dex
000472  1  CA                   dex
000473  1  CA                   dex
000474  1  CA                   dex
000475  1  CA                   dex             ;-120
000476  1  CA                   dex
000477  1  CA                   dex
000478  1  CA                   dex
000479  1  CA                   dex
00047A  1  CA                   dex
00047B  1  CA                   dex
00047C  1  CA                   dex
00047D  1  CA                   dex
00047E  1  CA                   dex
00047F  1  CA                   dex             ;-110
000480  1  CA                   dex
000481  1  CA                   dex
000482  1  CA                   dex
000483  1  CA                   dex
000484  1  CA                   dex
000485  1  CA                   dex
000486  1  CA                   dex
000487  1  CA                   dex
000488  1  CA                   dex
000489  1  CA                   dex             ;-100
00048A  1  CA                   dex
00048B  1  CA                   dex
00048C  1  CA                   dex
00048D  1  CA                   dex
00048E  1  CA                   dex
00048F  1  CA                   dex
000490  1  CA                   dex
000491  1  CA                   dex
000492  1  CA                   dex
000493  1  CA                   dex             ;-90
000494  1  CA                   dex
000495  1  CA                   dex
000496  1  CA                   dex
000497  1  CA                   dex
000498  1  CA                   dex
000499  1  CA                   dex
00049A  1  CA                   dex
00049B  1  CA                   dex
00049C  1  CA                   dex
00049D  1  CA                   dex             ;-80
00049E  1  CA                   dex
00049F  1  CA                   dex
0004A0  1  CA                   dex
0004A1  1  CA                   dex
0004A2  1  CA                   dex
0004A3  1  CA                   dex
0004A4  1  CA                   dex
0004A5  1  CA                   dex
0004A6  1  CA                   dex
0004A7  1  CA                   dex             ;-70
0004A8  1  CA                   dex
0004A9  1  CA                   dex
0004AA  1  CA                   dex
0004AB  1  CA                   dex
0004AC  1  CA                   dex
0004AD  1  CA                   dex
0004AE  1  CA                   dex
0004AF  1  CA                   dex
0004B0  1  CA                   dex
0004B1  1  CA                   dex             ;-60
0004B2  1  CA                   dex
0004B3  1  CA                   dex
0004B4  1  CA                   dex
0004B5  1  CA                   dex
0004B6  1  CA                   dex
0004B7  1  CA                   dex
0004B8  1  CA                   dex
0004B9  1  CA                   dex
0004BA  1  CA                   dex
0004BB  1  CA                   dex             ;-50
0004BC  1  CA                   dex
0004BD  1  CA                   dex
0004BE  1  CA                   dex
0004BF  1  CA                   dex
0004C0  1  CA                   dex
0004C1  1  CA                   dex
0004C2  1  CA                   dex
0004C3  1  CA                   dex
0004C4  1  CA                   dex
0004C5  1  CA                   dex             ;-40
0004C6  1  CA                   dex
0004C7  1  CA                   dex
0004C8  1  CA                   dex
0004C9  1  CA                   dex
0004CA  1  CA                   dex
0004CB  1  CA                   dex
0004CC  1  CA                   dex
0004CD  1  CA                   dex
0004CE  1  CA                   dex
0004CF  1  CA                   dex             ;-30
0004D0  1  CA                   dex
0004D1  1  CA                   dex
0004D2  1  CA                   dex
0004D3  1  CA                   dex
0004D4  1  CA                   dex
0004D5  1  CA                   dex
0004D6  1  CA                   dex
0004D7  1  CA                   dex
0004D8  1  CA                   dex
0004D9  1  CA                   dex             ;-20
0004DA  1  CA                   dex
0004DB  1  CA                   dex
0004DC  1  CA                   dex
0004DD  1  CA                   dex
0004DE  1  CA                   dex
0004DF  1  CA                   dex
0004E0  1  CA                   dex
0004E1  1  CA                   dex
0004E2  1  CA                   dex
0004E3  1  CA                   dex             ;-10
0004E4  1  CA                   dex
0004E5  1  CA                   dex
0004E6  1  CA                   dex
0004E7  1  CA                   dex
0004E8  1  CA                   dex
0004E9  1  CA                   dex
0004EA  1  CA                   dex             ;-3
0004EB  1               range_op:                ;test target with zero flag=0, z=1 if previous dex
0004EB  1               range_adr		:=	*+1       ;modifiable relative address
0004EB  1  F0 3E                beq *+64        ;+64 if called without modification
0004ED  1  CA                   dex             ;+0
0004EE  1  CA                   dex
0004EF  1  CA                   dex
0004F0  1  CA                   dex
0004F1  1  CA                   dex
0004F2  1  CA                   dex
0004F3  1  CA                   dex
0004F4  1  CA                   dex
0004F5  1  CA                   dex
0004F6  1  CA                   dex
0004F7  1  CA                   dex             ;+10
0004F8  1  CA                   dex
0004F9  1  CA                   dex
0004FA  1  CA                   dex
0004FB  1  CA                   dex
0004FC  1  CA                   dex
0004FD  1  CA                   dex
0004FE  1  CA                   dex
0004FF  1  CA                   dex
000500  1  CA                   dex
000501  1  CA                   dex             ;+20
000502  1  CA                   dex
000503  1  CA                   dex
000504  1  CA                   dex
000505  1  CA                   dex
000506  1  CA                   dex
000507  1  CA                   dex
000508  1  CA                   dex
000509  1  CA                   dex
00050A  1  CA                   dex
00050B  1  CA                   dex             ;+30
00050C  1  CA                   dex
00050D  1  CA                   dex
00050E  1  CA                   dex
00050F  1  CA                   dex
000510  1  CA                   dex
000511  1  CA                   dex
000512  1  CA                   dex
000513  1  CA                   dex
000514  1  CA                   dex
000515  1  CA                   dex             ;+40
000516  1  CA                   dex
000517  1  CA                   dex
000518  1  CA                   dex
000519  1  CA                   dex
00051A  1  CA                   dex
00051B  1  CA                   dex
00051C  1  CA                   dex
00051D  1  CA                   dex
00051E  1  CA                   dex
00051F  1  CA                   dex             ;+50
000520  1  CA                   dex
000521  1  CA                   dex
000522  1  CA                   dex
000523  1  CA                   dex
000524  1  CA                   dex
000525  1  CA                   dex
000526  1  CA                   dex
000527  1  CA                   dex
000528  1  CA                   dex
000529  1  CA                   dex             ;+60
00052A  1  CA                   dex
00052B  1  CA                   dex
00052C  1  CA                   dex
00052D  1  CA                   dex
00052E  1  CA                   dex
00052F  1  CA                   dex
000530  1  CA                   dex
000531  1  CA                   dex
000532  1  CA                   dex
000533  1  CA                   dex             ;+70
000534  1  CA                   dex
000535  1  CA                   dex
000536  1  CA                   dex
000537  1  CA                   dex
000538  1  CA                   dex
000539  1  CA                   dex
00053A  1  CA                   dex
00053B  1  CA                   dex
00053C  1  CA                   dex
00053D  1  CA                   dex             ;+80
00053E  1  CA                   dex
00053F  1  CA                   dex
000540  1  CA                   dex
000541  1  CA                   dex
000542  1  CA                   dex
000543  1  CA                   dex
000544  1  CA                   dex
000545  1  CA                   dex
000546  1  CA                   dex
000547  1  CA                   dex             ;+90
000548  1  CA                   dex
000549  1  CA                   dex
00054A  1  CA                   dex
00054B  1  CA                   dex
00054C  1  CA                   dex
00054D  1  CA                   dex
00054E  1  CA                   dex
00054F  1  CA                   dex
000550  1  CA                   dex
000551  1  CA                   dex             ;+100
000552  1  CA                   dex
000553  1  CA                   dex
000554  1  CA                   dex
000555  1  CA                   dex
000556  1  CA                   dex
000557  1  CA                   dex
000558  1  CA                   dex
000559  1  CA                   dex
00055A  1  CA                   dex
00055B  1  CA                   dex             ;+110
00055C  1  CA                   dex
00055D  1  CA                   dex
00055E  1  CA                   dex
00055F  1  CA                   dex
000560  1  CA                   dex
000561  1  CA                   dex
000562  1  CA                   dex
000563  1  CA                   dex
000564  1  CA                   dex
000565  1  CA                   dex             ;+120
000566  1  CA                   dex
000567  1  CA                   dex
000568  1  CA                   dex
000569  1  CA                   dex
00056A  1  CA                   dex
00056B  1  CA                   dex
00056C  1  EA                   nop             ;offset landing zone - forward branch too far
00056D  1  EA                   nop
00056E  1  EA                   nop
00056F  1  EA                   nop
000570  1  EA                   nop
000571  1  F0 08                beq range_ok    ;+127 - max forward
000573  1  20 58 44             trap            ; bad range
000576  1  EA                   nop             ;offset landing zone - tolerate +/-5 offset to branch
000577  1  EA                   nop
000578  1  EA                   nop
000579  1  EA                   nop
00057A  1  EA                   nop
00057B  1               range_ok:
00057B  1  EA                   nop
00057C  1  EA                   nop
00057D  1  EA                   nop
00057E  1  EA                   nop
00057F  1  EA                   nop
000580  1  C0 00                cpy #0
000582  1  F0 03                beq range_end
000584  1  4C 4C 04             jmp range_loop
000587  1               range_end:               ;range test successful
000587  1               .endif
000587  1  AD 00 02 C9          next_test
00058B  1  01 F0 03 20  
00058F  1  58 44 A9 02  
000596  1               
000596  1               ;partial test BNE & CMP, CPX, CPY immediate
000596  1  C0 01                cpy #1          ;testing BNE true
000598  1  D0 03                bne test_bne
00059A  1  20 58 44             trap
00059D  1               test_bne:
00059D  1  A9 00                lda #0
00059F  1  C9 00                cmp #0          ;test compare immediate
0005A1  1  F0 03 20 58          trap_ne
0005A5  1  44           
0005A6  1  B0 03 20 58          trap_cc
0005AA  1  44           
0005AB  1  10 03 20 58          trap_mi
0005AF  1  44           
0005B0  1  C9 01                cmp #1
0005B2  1  D0 03 20 58          trap_eq
0005B6  1  44           
0005B7  1  90 03 20 58          trap_cs
0005BB  1  44           
0005BC  1  30 03 20 58          trap_pl
0005C0  1  44           
0005C1  1  AA                   tax
0005C2  1  E0 00                cpx #0          ;test compare x immediate
0005C4  1  F0 03 20 58          trap_ne
0005C8  1  44           
0005C9  1  B0 03 20 58          trap_cc
0005CD  1  44           
0005CE  1  10 03 20 58          trap_mi
0005D2  1  44           
0005D3  1  E0 01                cpx #1
0005D5  1  D0 03 20 58          trap_eq
0005D9  1  44           
0005DA  1  90 03 20 58          trap_cs
0005DE  1  44           
0005DF  1  30 03 20 58          trap_pl
0005E3  1  44           
0005E4  1  A8                   tay
0005E5  1  C0 00                cpy #0          ;test compare y immediate
0005E7  1  F0 03 20 58          trap_ne
0005EB  1  44           
0005EC  1  B0 03 20 58          trap_cc
0005F0  1  44           
0005F1  1  10 03 20 58          trap_mi
0005F5  1  44           
0005F6  1  C0 01                cpy #1
0005F8  1  D0 03 20 58          trap_eq
0005FC  1  44           
0005FD  1  90 03 20 58          trap_cs
000601  1  44           
000602  1  30 03 20 58          trap_pl
000606  1  44           
000607  1  AD 00 02 C9          next_test
00060B  1  02 F0 03 20  
00060F  1  58 44 A9 03  
000616  1               ;testing stack operations PHA PHP PLA PLP
000616  1               
000616  1  A2 FF                ldx #$ff        ;initialize stack
000618  1  9A                   txs
000619  1  A9 55                lda #$55
00061B  1  48                   pha
00061C  1  A9 AA                lda #$aa
00061E  1  48                   pha
00061F  1  CD FE 01             cmp $1fe        ;on stack ?
000622  1  F0 03 20 58          trap_ne
000626  1  44           
000627  1  BA                   tsx
000628  1  8A                   txa             ;overwrite accu
000629  1  C9 FD                cmp #$fd        ;sp decremented?
00062B  1  F0 03 20 58          trap_ne
00062F  1  44           
000630  1  68                   pla
000631  1  C9 AA                cmp #$aa        ;successful retreived from stack?
000633  1  F0 03 20 58          trap_ne
000637  1  44           
000638  1  68                   pla
000639  1  C9 55                cmp #$55
00063B  1  F0 03 20 58          trap_ne
00063F  1  44           
000640  1  CD FF 01             cmp $1ff        ;remains on stack?
000643  1  F0 03 20 58          trap_ne
000647  1  44           
000648  1  BA                   tsx
000649  1  E0 FF                cpx #$ff        ;sp incremented?
00064B  1  F0 03 20 58          trap_ne
00064F  1  44           
000650  1  AD 00 02 C9          next_test
000654  1  03 F0 03 20  
000658  1  58 44 A9 04  
00065F  1               
00065F  1               ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
00065F  1  A9 FF 48 28          set_stat $ff    ;all on
000663  1  10 1A                bpl nbr1        ;branches should not be taken
000665  1  50 1B                bvc nbr2
000667  1  90 1C                bcc nbr3
000669  1  D0 1D                bne nbr4
00066B  1  30 03                bmi br1         ;branches should be taken
00066D  1  20 58 44             trap
000670  1  70 03        br1:     bvs br2
000672  1  20 58 44             trap
000675  1  B0 03        br2:     bcs br3
000677  1  20 58 44             trap
00067A  1  F0 0F        br3:     beq br4
00067C  1  20 58 44             trap
00067F  1               nbr1:
00067F  1  20 58 44             trap            ;previous bpl taken
000682  1               nbr2:
000682  1  20 58 44             trap            ;previous bvc taken
000685  1               nbr3:
000685  1  20 58 44             trap            ;previous bcc taken
000688  1               nbr4:
000688  1  20 58 44             trap            ;previous bne taken
00068B  1  08           br4:     php
00068C  1  BA                   tsx
00068D  1  E0 FE                cpx #$fe        ;sp after php?
00068F  1  F0 03 20 58          trap_ne
000693  1  44           
000694  1  68                   pla
000695  1  C9 FF                cmp_flag $ff    ;returned all flags on?
000697  1  F0 03 20 58          trap_ne
00069B  1  44           
00069C  1  BA                   tsx
00069D  1  E0 FF                cpx #$ff        ;sp after php?
00069F  1  F0 03 20 58          trap_ne
0006A3  1  44           
0006A4  1  A9 00 48 28          set_stat 0      ;all off
0006A8  1  30 1A                bmi nbr11       ;branches should not be taken
0006AA  1  70 1B                bvs nbr12
0006AC  1  B0 1C                bcs nbr13
0006AE  1  F0 1D                beq nbr14
0006B0  1  10 03                bpl br11        ;branches should be taken
0006B2  1  20 58 44             trap
0006B5  1  50 03        br11:    bvc br12
0006B7  1  20 58 44             trap
0006BA  1  90 03        br12:    bcc br13
0006BC  1  20 58 44             trap
0006BF  1  D0 0F        br13:    bne br14
0006C1  1  20 58 44             trap
0006C4  1               nbr11:
0006C4  1  20 58 44             trap            ;previous bmi taken
0006C7  1               nbr12:
0006C7  1  20 58 44             trap            ;previous bvs taken
0006CA  1               nbr13:
0006CA  1  20 58 44             trap            ;previous bcs taken
0006CD  1               nbr14:
0006CD  1  20 58 44             trap            ;previous beq taken
0006D0  1  08           br14:    php
0006D1  1  68                   pla
0006D2  1  C9 30                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0006D4  1  F0 03 20 58          trap_ne
0006D8  1  44           
0006D9  1                       ;crosscheck flags
0006D9  1  A9 02 48 28          set_stat zero
0006DD  1  D0 02                bne brzs1
0006DF  1  F0 03                beq brzs2
0006E1  1               brzs1:
0006E1  1  20 58 44             trap            ;branch zero/non zero
0006E4  1  B0 02        brzs2:   bcs brzs3
0006E6  1  90 03                bcc brzs4
0006E8  1               brzs3:
0006E8  1  20 58 44             trap            ;branch carry/no carry
0006EB  1  30 02        brzs4:   bmi brzs5
0006ED  1  10 03                bpl brzs6
0006EF  1               brzs5:
0006EF  1  20 58 44             trap            ;branch minus/plus
0006F2  1  70 02        brzs6:   bvs brzs7
0006F4  1  50 03                bvc brzs8
0006F6  1               brzs7:
0006F6  1  20 58 44             trap            ;branch overflow/no overflow
0006F9  1               brzs8:
0006F9  1  A9 01 48 28          set_stat carry
0006FD  1  F0 02                beq brcs1
0006FF  1  D0 03                bne brcs2
000701  1               brcs1:
000701  1  20 58 44             trap            ;branch zero/non zero
000704  1  90 02        brcs2:   bcc brcs3
000706  1  B0 03                bcs brcs4
000708  1               brcs3:
000708  1  20 58 44             trap            ;branch carry/no carry
00070B  1  30 02        brcs4:   bmi brcs5
00070D  1  10 03                bpl brcs6
00070F  1               brcs5:
00070F  1  20 58 44             trap            ;branch minus/plus
000712  1  70 02        brcs6:   bvs brcs7
000714  1  50 03                bvc brcs8
000716  1               brcs7:
000716  1  20 58 44             trap            ;branch overflow/no overflow
000719  1               
000719  1               brcs8:
000719  1  A9 80 48 28          set_stat minus
00071D  1  F0 02                beq brmi1
00071F  1  D0 03                bne brmi2
000721  1               brmi1:
000721  1  20 58 44             trap            ;branch zero/non zero
000724  1  B0 02        brmi2:   bcs brmi3
000726  1  90 03                bcc brmi4
000728  1               brmi3:
000728  1  20 58 44             trap            ;branch carry/no carry
00072B  1  10 02        brmi4:   bpl brmi5
00072D  1  30 03                bmi brmi6
00072F  1               brmi5:
00072F  1  20 58 44             trap            ;branch minus/plus
000732  1  70 02        brmi6:   bvs brmi7
000734  1  50 03                bvc brmi8
000736  1               brmi7:
000736  1  20 58 44             trap            ;branch overflow/no overflow
000739  1               brmi8:
000739  1  A9 40 48 28          set_stat overfl
00073D  1  F0 02                beq brvs1
00073F  1  D0 03                bne brvs2
000741  1               brvs1:
000741  1  20 58 44             trap            ;branch zero/non zero
000744  1  B0 02        brvs2:   bcs brvs3
000746  1  90 03                bcc brvs4
000748  1               brvs3:
000748  1  20 58 44             trap            ;branch carry/no carry
00074B  1  30 02        brvs4:   bmi brvs5
00074D  1  10 03                bpl brvs6
00074F  1               brvs5:
00074F  1  20 58 44             trap            ;branch minus/plus
000752  1  50 02        brvs6:   bvc brvs7
000754  1  70 03                bvs brvs8
000756  1               brvs7:
000756  1  20 58 44             trap            ;branch overflow/no overflow
000759  1               brvs8:
000759  1  A9 FD 48 28          set_stat $ff-zero
00075D  1  F0 02                beq brzc1
00075F  1  D0 03                bne brzc2
000761  1               brzc1:
000761  1  20 58 44             trap            ;branch zero/non zero
000764  1  90 02        brzc2:   bcc brzc3
000766  1  B0 03                bcs brzc4
000768  1               brzc3:
000768  1  20 58 44             trap            ;branch carry/no carry
00076B  1  10 02        brzc4:   bpl brzc5
00076D  1  30 03                bmi brzc6
00076F  1               brzc5:
00076F  1  20 58 44             trap            ;branch minus/plus
000772  1  50 02        brzc6:   bvc brzc7
000774  1  70 03                bvs brzc8
000776  1               brzc7:
000776  1  20 58 44             trap            ;branch overflow/no overflow
000779  1               brzc8:
000779  1  A9 FE 48 28          set_stat $ff-carry
00077D  1  D0 02                bne brcc1
00077F  1  F0 03                beq brcc2
000781  1               brcc1:
000781  1  20 58 44             trap            ;branch zero/non zero
000784  1  B0 02        brcc2:   bcs brcc3
000786  1  90 03                bcc brcc4
000788  1               brcc3:
000788  1  20 58 44             trap            ;branch carry/no carry
00078B  1  10 02        brcc4:   bpl brcc5
00078D  1  30 03                bmi brcc6
00078F  1               brcc5:
00078F  1  20 58 44             trap            ;branch minus/plus
000792  1  50 02        brcc6:   bvc brcc7
000794  1  70 03                bvs brcc8
000796  1               brcc7:
000796  1  20 58 44             trap            ;branch overflow/no overflow
000799  1               brcc8:
000799  1  A9 7F 48 28          set_stat $ff-minus
00079D  1  D0 02                bne brpl1
00079F  1  F0 03                beq brpl2
0007A1  1               brpl1:
0007A1  1  20 58 44             trap            ;branch zero/non zero
0007A4  1  90 02        brpl2:   bcc brpl3
0007A6  1  B0 03                bcs brpl4
0007A8  1               brpl3:
0007A8  1  20 58 44             trap            ;branch carry/no carry
0007AB  1  30 02        brpl4:   bmi brpl5
0007AD  1  10 03                bpl brpl6
0007AF  1               brpl5:
0007AF  1  20 58 44             trap            ;branch minus/plus
0007B2  1  50 02        brpl6:   bvc brpl7
0007B4  1  70 03                bvs brpl8
0007B6  1               brpl7:
0007B6  1  20 58 44             trap            ;branch overflow/no overflow
0007B9  1               brpl8:
0007B9  1  A9 BF 48 28          set_stat $ff-overfl
0007BD  1  D0 02                bne brvc1
0007BF  1  F0 03                beq brvc2
0007C1  1               brvc1:
0007C1  1  20 58 44             trap            ;branch zero/non zero
0007C4  1  90 02        brvc2:   bcc brvc3
0007C6  1  B0 03                bcs brvc4
0007C8  1               brvc3:
0007C8  1  20 58 44             trap            ;branch carry/no carry
0007CB  1  10 02        brvc4:   bpl brvc5
0007CD  1  30 03                bmi brvc6
0007CF  1               brvc5:
0007CF  1  20 58 44             trap            ;branch minus/plus
0007D2  1  70 02        brvc6:   bvs brvc7
0007D4  1  50 03                bvc brvc8
0007D6  1               brvc7:
0007D6  1  20 58 44             trap            ;branch overflow/no overflow
0007D9  1               brvc8:
0007D9  1  AD 00 02 C9          next_test
0007DD  1  04 F0 03 20  
0007E1  1  58 44 A9 05  
0007E8  1               
0007E8  1               ; test PHA does not alter flags or accumulator but PLA does
0007E8  1  A2 55                ldx #$55        ;x & y protected
0007EA  1  A0 AA                ldy #$aa
0007EC  1  A9 FF 48 A9          set_a 1,$ff     ;push
0007F0  1  01 28        
0007F2  1  48                   pha
0007F3  1  08 C9 01 F0          tst_a 1,$ff
0007F7  1  03 20 58 44  
0007FB  1  68 48 C9 FF  
000805  1  A9 00 48 A9          set_a 0,0
000809  1  00 28        
00080B  1  48                   pha
00080C  1  08 C9 00 F0          tst_a 0,0
000810  1  03 20 58 44  
000814  1  68 48 C9 30  
00081E  1  A9 FF 48 A9          set_a $ff,$ff
000822  1  FF 28        
000824  1  48                   pha
000825  1  08 C9 FF F0          tst_a $ff,$ff
000829  1  03 20 58 44  
00082D  1  68 48 C9 FF  
000837  1  A9 00 48 A9          set_a 1,0
00083B  1  01 28        
00083D  1  48                   pha
00083E  1  08 C9 01 F0          tst_a 1,0
000842  1  03 20 58 44  
000846  1  68 48 C9 30  
000850  1  A9 FF 48 A9          set_a 0,$ff
000854  1  00 28        
000856  1  48                   pha
000857  1  08 C9 00 F0          tst_a 0,$ff
00085B  1  03 20 58 44  
00085F  1  68 48 C9 FF  
000869  1  A9 00 48 A9          set_a $ff,0
00086D  1  FF 28        
00086F  1  48                   pha
000870  1  08 C9 FF F0          tst_a $ff,0
000874  1  03 20 58 44  
000878  1  68 48 C9 30  
000882  1  A9 FF 48 A9          set_a 0,$ff     ;pull
000886  1  00 28        
000888  1  68                   pla
000889  1  08 C9 FF F0          tst_a $ff,$ff-zero
00088D  1  03 20 58 44  
000891  1  68 48 C9 FD  
00089B  1  A9 00 48 A9          set_a $ff,0
00089F  1  FF 28        
0008A1  1  68                   pla
0008A2  1  08 C9 00 F0          tst_a 0,zero
0008A6  1  03 20 58 44  
0008AA  1  68 48 C9 32  
0008B4  1  A9 FF 48 A9          set_a $fe,$ff
0008B8  1  FE 28        
0008BA  1  68                   pla
0008BB  1  08 C9 01 F0          tst_a 1,$ff-zero-minus
0008BF  1  03 20 58 44  
0008C3  1  68 48 C9 7D  
0008CD  1  A9 00 48 A9          set_a 0,0
0008D1  1  00 28        
0008D3  1  68                   pla
0008D4  1  08 C9 FF F0          tst_a $ff,minus
0008D8  1  03 20 58 44  
0008DC  1  68 48 C9 B0  
0008E6  1  A9 FF 48 A9          set_a $ff,$ff
0008EA  1  FF 28        
0008EC  1  68                   pla
0008ED  1  08 C9 00 F0          tst_a 0,$ff-minus
0008F1  1  03 20 58 44  
0008F5  1  68 48 C9 7F  
0008FF  1  A9 00 48 A9          set_a $fe,0
000903  1  FE 28        
000905  1  68                   pla
000906  1  08 C9 01 F0          tst_a 1,0
00090A  1  03 20 58 44  
00090E  1  68 48 C9 30  
000918  1  E0 55                cpx #$55        ;x & y unchanged?
00091A  1  F0 03 20 58          trap_ne
00091E  1  44           
00091F  1  C0 AA                cpy #$aa
000921  1  F0 03 20 58          trap_ne
000925  1  44           
000926  1  AD 00 02 C9          next_test
00092A  1  05 F0 03 20  
00092E  1  58 44 A9 06  
000935  1               
000935  1               ; partial pretest EOR #
000935  1  A9 00 48 A9          set_a $3c,0
000939  1  3C 28        
00093B  1  49 C3                eor #$c3
00093D  1  08 C9 FF F0          tst_a $ff,fn
000941  1  03 20 58 44  
000945  1  68 48 C9 B0  
00094F  1  A9 00 48 A9          set_a $c3,0
000953  1  C3 28        
000955  1  49 C3                eor #$c3
000957  1  08 C9 00 F0          tst_a 0,fz
00095B  1  03 20 58 44  
00095F  1  68 48 C9 32  
000969  1  AD 00 02 C9          next_test
00096D  1  06 F0 03 20  
000971  1  58 44 A9 07  
000978  1               
000978  1               ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
000978  1               ; testing NOP
000978  1  A2 24                ldx #$24
00097A  1  A0 42                ldy #$42
00097C  1  A9 00 48 A9          set_a $18,0
000980  1  18 28        
000982  1  EA                   nop
000983  1  08 C9 18 F0          tst_a $18,0
000987  1  03 20 58 44  
00098B  1  68 48 C9 30  
000995  1  E0 24                cpx #$24
000997  1  F0 03 20 58          trap_ne
00099B  1  44           
00099C  1  C0 42                cpy #$42
00099E  1  F0 03 20 58          trap_ne
0009A2  1  44           
0009A3  1  A2 DB                ldx #$db
0009A5  1  A0 BD                ldy #$bd
0009A7  1  A9 FF 48 A9          set_a $e7,$ff
0009AB  1  E7 28        
0009AD  1  EA                   nop
0009AE  1  08 C9 E7 F0          tst_a $e7,$ff
0009B2  1  03 20 58 44  
0009B6  1  68 48 C9 FF  
0009C0  1  E0 DB                cpx #$db
0009C2  1  F0 03 20 58          trap_ne
0009C6  1  44           
0009C7  1  C0 BD                cpy #$bd
0009C9  1  F0 03 20 58          trap_ne
0009CD  1  44           
0009CE  1  AD 00 02 C9          next_test
0009D2  1  07 F0 03 20  
0009D6  1  58 44 A9 08  
0009DD  1               
0009DD  1               ; jump absolute
0009DD  1  A9 00 48 28          set_stat $0
0009E1  1  A9 46                lda #'F'
0009E3  1  A2 41                ldx #'A'
0009E5  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
0009E7  1  4C 8C 42             jmp test_far
0009EA  1  EA                   nop
0009EB  1  EA                   nop
0009EC  1  F0 03 20 58          trap_ne         ;runover protection
0009F0  1  44           
0009F1  1  E8                   inx
0009F2  1  E8                   inx
0009F3  1               far_ret:
0009F3  1  D0 03 20 58          trap_eq         ;returned flags OK?
0009F7  1  44           
0009F8  1  30 03 20 58          trap_pl
0009FC  1  44           
0009FD  1  B0 03 20 58          trap_cc
000A01  1  44           
000A02  1  70 03 20 58          trap_vc
000A06  1  44           
000A07  1  C9 EC                cmp #('F'^$aa)  ;returned registers OK?
000A09  1  F0 03 20 58          trap_ne
000A0D  1  44           
000A0E  1  E0 42                cpx #('A'+1)
000A10  1  F0 03 20 58          trap_ne
000A14  1  44           
000A15  1  C0 4F                cpy #('R'-3)
000A17  1  F0 03 20 58          trap_ne
000A1B  1  44           
000A1C  1  CA                   dex
000A1D  1  C8                   iny
000A1E  1  C8                   iny
000A1F  1  C8                   iny
000A20  1  49 AA                eor #$aa        ;N=0, V=1, Z=0, C=1
000A22  1  4C 2E 0A             jmp test_near
000A25  1  EA                   nop
000A26  1  EA                   nop
000A27  1  F0 03 20 58          trap_ne         ;runover protection
000A2B  1  44           
000A2C  1  E8                   inx
000A2D  1  E8                   inx
000A2E  1               test_near:
000A2E  1  D0 03 20 58          trap_eq         ;passed flags OK?
000A32  1  44           
000A33  1  10 03 20 58          trap_mi
000A37  1  44           
000A38  1  B0 03 20 58          trap_cc
000A3C  1  44           
000A3D  1  70 03 20 58          trap_vc
000A41  1  44           
000A42  1  C9 46                cmp #'F'        ;passed registers OK?
000A44  1  F0 03 20 58          trap_ne
000A48  1  44           
000A49  1  E0 41                cpx #'A'
000A4B  1  F0 03 20 58          trap_ne
000A4F  1  44           
000A50  1  C0 52                cpy #'R'
000A52  1  F0 03 20 58          trap_ne
000A56  1  44           
000A57  1  AD 00 02 C9          next_test
000A5B  1  08 F0 03 20  
000A5F  1  58 44 A9 09  
000A66  1               
000A66  1               ; jump indirect
000A66  1  A9 00 48 28          set_stat 0
000A6A  1  A9 49                lda #'I'
000A6C  1  A2 4E                ldx #'N'
000A6E  1  A0 44                ldy #'D'        ;N=0, V=0, Z=0, C=0
000A70  1  6C D2 42             jmp (ptr_tst_ind)
000A73  1  EA                   nop
000A74  1  F0 03 20 58          trap_ne         ;runover protection
000A78  1  44           
000A79  1  88                   dey
000A7A  1  88                   dey
000A7B  1               ind_ret:
000A7B  1  08                   php             ;either SP or Y count will fail, if we do not hit
000A7C  1  88                   dey
000A7D  1  88                   dey
000A7E  1  88                   dey
000A7F  1  28                   plp
000A80  1  D0 03 20 58          trap_eq         ;returned flags OK?
000A84  1  44           
000A85  1  30 03 20 58          trap_pl
000A89  1  44           
000A8A  1  B0 03 20 58          trap_cc
000A8E  1  44           
000A8F  1  70 03 20 58          trap_vc
000A93  1  44           
000A94  1  C9 E3                cmp #('I'^$aa)  ;returned registers OK?
000A96  1  F0 03 20 58          trap_ne
000A9A  1  44           
000A9B  1  E0 4F                cpx #('N'+1)
000A9D  1  F0 03 20 58          trap_ne
000AA1  1  44           
000AA2  1  C0 3E                cpy #('D'-6)
000AA4  1  F0 03 20 58          trap_ne
000AA8  1  44           
000AA9  1  BA                   tsx             ;SP check
000AAA  1  E0 FF                cpx #$ff
000AAC  1  F0 03 20 58          trap_ne
000AB0  1  44           
000AB1  1  AD 00 02 C9          next_test
000AB5  1  09 F0 03 20  
000AB9  1  58 44 A9 0A  
000AC0  1               
000AC0  1               ; jump subroutine & return from subroutine
000AC0  1  A9 00 48 28          set_stat 0
000AC4  1  A9 4A                lda #'J'
000AC6  1  A2 53                ldx #'S'
000AC8  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
000ACA  1  20 29 43             jsr test_jsr
000ACD  1               jsr_ret		:=	*-1           ;last address of jsr = return address
000ACD  1  08                   php             ;either SP or Y count will fail, if we do not hit
000ACE  1  88                   dey
000ACF  1  88                   dey
000AD0  1  88                   dey
000AD1  1  28                   plp
000AD2  1  D0 03 20 58          trap_eq         ;returned flags OK?
000AD6  1  44           
000AD7  1  30 03 20 58          trap_pl
000ADB  1  44           
000ADC  1  B0 03 20 58          trap_cc
000AE0  1  44           
000AE1  1  70 03 20 58          trap_vc
000AE5  1  44           
000AE6  1  C9 E0                cmp #('J'^$aa)  ;returned registers OK?
000AE8  1  F0 03 20 58          trap_ne
000AEC  1  44           
000AED  1  E0 54                cpx #('S'+1)
000AEF  1  F0 03 20 58          trap_ne
000AF3  1  44           
000AF4  1  C0 4C                cpy #('R'-6)
000AF6  1  F0 03 20 58          trap_ne
000AFA  1  44           
000AFB  1  BA                   tsx             ;sp?
000AFC  1  E0 FF                cpx #$ff
000AFE  1  F0 03 20 58          trap_ne
000B02  1  44           
000B03  1  AD 00 02 C9          next_test
000B07  1  0A F0 03 20  
000B0B  1  58 44 A9 0B  
000B12  1               
000B12  1               ; break & return from interrupt
000B12  1               .if ROM_vectors = 1
000B12  1  A9 00                load_flag 0     ;with interrupts enabled if allowed!
000B14  1  48                   pha
000B15  1  A9 42                lda #'B'
000B17  1  A2 52                ldx #'R'
000B19  1  A0 4B                ldy #'K'
000B1B  1  28                   plp             ;N=0, V=0, Z=0, C=0
000B1C  1  00                   brk
000B1D  1               .else
000B1D  1                       lda #> brk_ret0 ;emulated break
000B1D  1                       pha
000B1D  1                       lda #< brk_ret0
000B1D  1                       pha
000B1D  1                       load_flag fao    ;set break & unused on stack
000B1D  1                       pha
000B1D  1                       load_flag intdis ;during interrupt
000B1D  1                       pha
000B1D  1                       lda #'B'
000B1D  1                       ldx #'R'
000B1D  1                       ldy #'K'
000B1D  1                       plp             ;N=0, V=0, Z=0, C=0
000B1D  1                       jmp irq_trap
000B1D  1               .endif
000B1D  1  88                   dey             ;should not be executed
000B1E  1               brk_ret0:                ;address of break return
000B1E  1  08                   php             ;either SP or Y count will fail, if we do not hit
000B1F  1  88                   dey
000B20  1  88                   dey
000B21  1  88                   dey
000B22  1  C9 E8                cmp #'B'^$aa    ;returned registers OK?
000B24  1                       ;the IRQ vector was never executed if A & X stay unmodified
000B24  1  F0 03 20 58          trap_ne
000B28  1  44           
000B29  1  E0 53                cpx #'R'+1
000B2B  1  F0 03 20 58          trap_ne
000B2F  1  44           
000B30  1  C0 45                cpy #'K'-6
000B32  1  F0 03 20 58          trap_ne
000B36  1  44           
000B37  1  68                   pla             ;returned flags OK (unchanged)?
000B38  1  C9 30                cmp_flag 0
000B3A  1  F0 03 20 58          trap_ne
000B3E  1  44           
000B3F  1  BA                   tsx             ;sp?
000B40  1  E0 FF                cpx #$ff
000B42  1  F0 03 20 58          trap_ne
000B46  1  44           
000B47  1               .if ROM_vectors = 1
000B47  1  A9 FF                load_flag $ff   ;with interrupts disabled if allowed!
000B49  1  48                   pha
000B4A  1  A9 BD                lda #$ff-'B'
000B4C  1  A2 AD                ldx #$ff-'R'
000B4E  1  A0 B4                ldy #$ff-'K'
000B50  1  28                   plp             ;N=1, V=1, Z=1, C=1
000B51  1  00                   brk
000B52  1               .else
000B52  1                       lda #> brk_ret1 ;emulated break
000B52  1                       pha
000B52  1                       lda #< brk_ret1
000B52  1                       pha
000B52  1                       load_flag $ff
000B52  1                       pha             ;set break & unused on stack
000B52  1                       pha             ;actual flags
000B52  1                       lda #$ff-'B'
000B52  1                       ldx #$ff-'R'
000B52  1                       ldy #$ff-'K'
000B52  1                       plp             ;N=1, V=1, Z=1, C=1
000B52  1                       jmp irq_trap
000B52  1               .endif
000B52  1  88                   dey             ;should not be executed
000B53  1               brk_ret1:                ;address of break return
000B53  1  08                   php             ;either SP or Y count will fail, if we do not hit
000B54  1  88                   dey
000B55  1  88                   dey
000B56  1  88                   dey
000B57  1  C9 17                cmp #($ff-'B')^$aa  ;returned registers OK?
000B59  1                       ;the IRQ vector was never executed if A & X stay unmodified
000B59  1  F0 03 20 58          trap_ne
000B5D  1  44           
000B5E  1  E0 AE                cpx #$ff-'R'+1
000B60  1  F0 03 20 58          trap_ne
000B64  1  44           
000B65  1  C0 AE                cpy #$ff-'K'-6
000B67  1  F0 03 20 58          trap_ne
000B6B  1  44           
000B6C  1  68                   pla             ;returned flags OK (unchanged)?
000B6D  1  C9 FF                cmp_flag $ff
000B6F  1  F0 03 20 58          trap_ne
000B73  1  44           
000B74  1  BA                   tsx             ;sp?
000B75  1  E0 FF                cpx #$ff
000B77  1  F0 03 20 58          trap_ne
000B7B  1  44           
000B7C  1  AD 00 02 C9          next_test
000B80  1  0B F0 03 20  
000B84  1  58 44 A9 0C  
000B8B  1               
000B8B  1               ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
000B8B  1  A9 FF 48 28          set_stat $ff
000B8F  1  18                   clc
000B90  1  08 68 48 C9          tst_stat $ff-carry
000B94  1  FE F0 03 20  
000B98  1  58 44 28     
000B9B  1  38                   sec
000B9C  1  08 68 48 C9          tst_stat $ff
000BA0  1  FF F0 03 20  
000BA4  1  58 44 28     
000BA7  1               .if I_flag = 3
000BA7  1  58                   cli
000BA8  1  08 68 48 C9          tst_stat $ff-intdis
000BAC  1  FB F0 03 20  
000BB0  1  58 44 28     
000BB3  1  78                   sei
000BB4  1  08 68 48 C9          tst_stat $ff
000BB8  1  FF F0 03 20  
000BBC  1  58 44 28     
000BBF  1               .endif
000BBF  1  D8                   cld
000BC0  1  08 68 48 C9          tst_stat $ff-decmode
000BC4  1  F7 F0 03 20  
000BC8  1  58 44 28     
000BCB  1  F8                   sed
000BCC  1  08 68 48 C9          tst_stat $ff
000BD0  1  FF F0 03 20  
000BD4  1  58 44 28     
000BD7  1  B8                   clv
000BD8  1  08 68 48 C9          tst_stat $ff-overfl
000BDC  1  BF F0 03 20  
000BE0  1  58 44 28     
000BE3  1  A9 00 48 28          set_stat 0
000BE7  1  08 68 48 C9          tst_stat 0
000BEB  1  30 F0 03 20  
000BEF  1  58 44 28     
000BF2  1  38                   sec
000BF3  1  08 68 48 C9          tst_stat carry
000BF7  1  31 F0 03 20  
000BFB  1  58 44 28     
000BFE  1  18                   clc
000BFF  1  08 68 48 C9          tst_stat 0
000C03  1  30 F0 03 20  
000C07  1  58 44 28     
000C0A  1               .if I_flag = 3
000C0A  1  78                   sei
000C0B  1  08 68 48 C9          tst_stat intdis
000C0F  1  34 F0 03 20  
000C13  1  58 44 28     
000C16  1  58                   cli
000C17  1  08 68 48 C9          tst_stat 0
000C1B  1  30 F0 03 20  
000C1F  1  58 44 28     
000C22  1               .endif
000C22  1  F8                   sed
000C23  1  08 68 48 C9          tst_stat decmode
000C27  1  38 F0 03 20  
000C2B  1  58 44 28     
000C2E  1  D8                   cld
000C2F  1  08 68 48 C9          tst_stat 0
000C33  1  30 F0 03 20  
000C37  1  58 44 28     
000C3A  1  A9 40 48 28          set_stat overfl
000C3E  1  08 68 48 C9          tst_stat overfl
000C42  1  70 F0 03 20  
000C46  1  58 44 28     
000C49  1  B8                   clv
000C4A  1  08 68 48 C9          tst_stat 0
000C4E  1  30 F0 03 20  
000C52  1  58 44 28     
000C55  1  AD 00 02 C9          next_test
000C59  1  0C F0 03 20  
000C5D  1  58 44 A9 0D  
000C64  1               ; testing index register increment/decrement and transfer
000C64  1               ; INX INY DEX DEY TAX TXA TAY TYA
000C64  1  A2 FE                ldx #$fe
000C66  1  A9 FF 48 28          set_stat $ff
000C6A  1  E8                   inx             ;ff
000C6B  1  08 E0 FF F0          tst_x $ff,$ff-zero
000C6F  1  03 20 58 44  
000C73  1  68 48 C9 FD  
000C7D  1  E8                   inx             ;00
000C7E  1  08 E0 00 F0          tst_x 0,$ff-minus
000C82  1  03 20 58 44  
000C86  1  68 48 C9 7F  
000C90  1  E8                   inx             ;01
000C91  1  08 E0 01 F0          tst_x 1,$ff-minus-zero
000C95  1  03 20 58 44  
000C99  1  68 48 C9 7D  
000CA3  1  CA                   dex             ;00
000CA4  1  08 E0 00 F0          tst_x 0,$ff-minus
000CA8  1  03 20 58 44  
000CAC  1  68 48 C9 7F  
000CB6  1  CA                   dex             ;ff
000CB7  1  08 E0 FF F0          tst_x $ff,$ff-zero
000CBB  1  03 20 58 44  
000CBF  1  68 48 C9 FD  
000CC9  1  CA                   dex             ;fe
000CCA  1  A9 00 48 28          set_stat 0
000CCE  1  E8                   inx             ;ff
000CCF  1  08 E0 FF F0          tst_x $ff,minus
000CD3  1  03 20 58 44  
000CD7  1  68 48 C9 B0  
000CE1  1  E8                   inx             ;00
000CE2  1  08 E0 00 F0          tst_x 0,zero
000CE6  1  03 20 58 44  
000CEA  1  68 48 C9 32  
000CF4  1  E8                   inx             ;01
000CF5  1  08 E0 01 F0          tst_x 1,0
000CF9  1  03 20 58 44  
000CFD  1  68 48 C9 30  
000D07  1  CA                   dex             ;00
000D08  1  08 E0 00 F0          tst_x 0,zero
000D0C  1  03 20 58 44  
000D10  1  68 48 C9 32  
000D1A  1  CA                   dex             ;ff
000D1B  1  08 E0 FF F0          tst_x $ff,minus
000D1F  1  03 20 58 44  
000D23  1  68 48 C9 B0  
000D2D  1               
000D2D  1  A0 FE                ldy #$fe
000D2F  1  A9 FF 48 28          set_stat $ff
000D33  1  C8                   iny             ;ff
000D34  1  08 C0 FF F0          tst_y $ff,$ff-zero
000D38  1  03 20 58 44  
000D3C  1  68 48 C9 FD  
000D46  1  C8                   iny             ;00
000D47  1  08 C0 00 F0          tst_y 0,$ff-minus
000D4B  1  03 20 58 44  
000D4F  1  68 48 C9 7F  
000D59  1  C8                   iny             ;01
000D5A  1  08 C0 01 F0          tst_y 1,$ff-minus-zero
000D5E  1  03 20 58 44  
000D62  1  68 48 C9 7D  
000D6C  1  88                   dey             ;00
000D6D  1  08 C0 00 F0          tst_y 0,$ff-minus
000D71  1  03 20 58 44  
000D75  1  68 48 C9 7F  
000D7F  1  88                   dey             ;ff
000D80  1  08 C0 FF F0          tst_y $ff,$ff-zero
000D84  1  03 20 58 44  
000D88  1  68 48 C9 FD  
000D92  1  88                   dey             ;fe
000D93  1  A9 00 48 28          set_stat 0
000D97  1  C8                   iny             ;ff
000D98  1  08 C0 FF F0          tst_y $ff,0+minus
000D9C  1  03 20 58 44  
000DA0  1  68 48 C9 B0  
000DAA  1  C8                   iny             ;00
000DAB  1  08 C0 00 F0          tst_y 0,zero
000DAF  1  03 20 58 44  
000DB3  1  68 48 C9 32  
000DBD  1  C8                   iny             ;01
000DBE  1  08 C0 01 F0          tst_y 1,0
000DC2  1  03 20 58 44  
000DC6  1  68 48 C9 30  
000DD0  1  88                   dey             ;00
000DD1  1  08 C0 00 F0          tst_y 0,zero
000DD5  1  03 20 58 44  
000DD9  1  68 48 C9 32  
000DE3  1  88                   dey             ;ff
000DE4  1  08 C0 FF F0          tst_y $ff,minus
000DE8  1  03 20 58 44  
000DEC  1  68 48 C9 B0  
000DF6  1               
000DF6  1  A2 FF                ldx #$ff
000DF8  1  A9 FF 48 28          set_stat $ff
000DFC  1  8A                   txa
000DFD  1  08 C9 FF F0          tst_a $ff,$ff-zero
000E01  1  03 20 58 44  
000E05  1  68 48 C9 FD  
000E0F  1  08                   php
000E10  1  E8                   inx             ;00
000E11  1  28                   plp
000E12  1  8A                   txa
000E13  1  08 C9 00 F0          tst_a 0,$ff-minus
000E17  1  03 20 58 44  
000E1B  1  68 48 C9 7F  
000E25  1  08                   php
000E26  1  E8                   inx             ;01
000E27  1  28                   plp
000E28  1  8A                   txa
000E29  1  08 C9 01 F0          tst_a 1,$ff-minus-zero
000E2D  1  03 20 58 44  
000E31  1  68 48 C9 7D  
000E3B  1  A9 00 48 28          set_stat 0
000E3F  1  8A                   txa
000E40  1  08 C9 01 F0          tst_a 1,0
000E44  1  03 20 58 44  
000E48  1  68 48 C9 30  
000E52  1  08                   php
000E53  1  CA                   dex             ;00
000E54  1  28                   plp
000E55  1  8A                   txa
000E56  1  08 C9 00 F0          tst_a 0,zero
000E5A  1  03 20 58 44  
000E5E  1  68 48 C9 32  
000E68  1  08                   php
000E69  1  CA                   dex             ;ff
000E6A  1  28                   plp
000E6B  1  8A                   txa
000E6C  1  08 C9 FF F0          tst_a $ff,minus
000E70  1  03 20 58 44  
000E74  1  68 48 C9 B0  
000E7E  1               
000E7E  1  A0 FF                ldy #$ff
000E80  1  A9 FF 48 28          set_stat $ff
000E84  1  98                   tya
000E85  1  08 C9 FF F0          tst_a $ff,$ff-zero
000E89  1  03 20 58 44  
000E8D  1  68 48 C9 FD  
000E97  1  08                   php
000E98  1  C8                   iny             ;00
000E99  1  28                   plp
000E9A  1  98                   tya
000E9B  1  08 C9 00 F0          tst_a 0,$ff-minus
000E9F  1  03 20 58 44  
000EA3  1  68 48 C9 7F  
000EAD  1  08                   php
000EAE  1  C8                   iny             ;01
000EAF  1  28                   plp
000EB0  1  98                   tya
000EB1  1  08 C9 01 F0          tst_a 1,$ff-minus-zero
000EB5  1  03 20 58 44  
000EB9  1  68 48 C9 7D  
000EC3  1  A9 00 48 28          set_stat 0
000EC7  1  98                   tya
000EC8  1  08 C9 01 F0          tst_a 1,0
000ECC  1  03 20 58 44  
000ED0  1  68 48 C9 30  
000EDA  1  08                   php
000EDB  1  88                   dey             ;00
000EDC  1  28                   plp
000EDD  1  98                   tya
000EDE  1  08 C9 00 F0          tst_a 0,zero
000EE2  1  03 20 58 44  
000EE6  1  68 48 C9 32  
000EF0  1  08                   php
000EF1  1  88                   dey             ;ff
000EF2  1  28                   plp
000EF3  1  98                   tya
000EF4  1  08 C9 FF F0          tst_a $ff,minus
000EF8  1  03 20 58 44  
000EFC  1  68 48 C9 B0  
000F06  1               
000F06  1  A9 FF                load_flag $ff
000F08  1  48                   pha
000F09  1  A2 FF                ldx #$ff        ;ff
000F0B  1  8A                   txa
000F0C  1  28                   plp
000F0D  1  A8                   tay
000F0E  1  08 C0 FF F0          tst_y $ff,$ff-zero
000F12  1  03 20 58 44  
000F16  1  68 48 C9 FD  
000F20  1  08                   php
000F21  1  E8                   inx             ;00
000F22  1  8A                   txa
000F23  1  28                   plp
000F24  1  A8                   tay
000F25  1  08 C0 00 F0          tst_y 0,$ff-minus
000F29  1  03 20 58 44  
000F2D  1  68 48 C9 7F  
000F37  1  08                   php
000F38  1  E8                   inx             ;01
000F39  1  8A                   txa
000F3A  1  28                   plp
000F3B  1  A8                   tay
000F3C  1  08 C0 01 F0          tst_y 1,$ff-minus-zero
000F40  1  03 20 58 44  
000F44  1  68 48 C9 7D  
000F4E  1  A9 00                load_flag 0
000F50  1  48                   pha
000F51  1  A9 00                lda #0
000F53  1  8A                   txa
000F54  1  28                   plp
000F55  1  A8                   tay
000F56  1  08 C0 01 F0          tst_y 1,0
000F5A  1  03 20 58 44  
000F5E  1  68 48 C9 30  
000F68  1  08                   php
000F69  1  CA                   dex             ;00
000F6A  1  8A                   txa
000F6B  1  28                   plp
000F6C  1  A8                   tay
000F6D  1  08 C0 00 F0          tst_y 0,zero
000F71  1  03 20 58 44  
000F75  1  68 48 C9 32  
000F7F  1  08                   php
000F80  1  CA                   dex             ;ff
000F81  1  8A                   txa
000F82  1  28                   plp
000F83  1  A8                   tay
000F84  1  08 C0 FF F0          tst_y $ff,minus
000F88  1  03 20 58 44  
000F8C  1  68 48 C9 B0  
000F96  1               
000F96  1               
000F96  1  A9 FF                load_flag $ff
000F98  1  48                   pha
000F99  1  A0 FF                ldy #$ff        ;ff
000F9B  1  98                   tya
000F9C  1  28                   plp
000F9D  1  AA                   tax
000F9E  1  08 E0 FF F0          tst_x $ff,$ff-zero
000FA2  1  03 20 58 44  
000FA6  1  68 48 C9 FD  
000FB0  1  08                   php
000FB1  1  C8                   iny             ;00
000FB2  1  98                   tya
000FB3  1  28                   plp
000FB4  1  AA                   tax
000FB5  1  08 E0 00 F0          tst_x 0,$ff-minus
000FB9  1  03 20 58 44  
000FBD  1  68 48 C9 7F  
000FC7  1  08                   php
000FC8  1  C8                   iny             ;01
000FC9  1  98                   tya
000FCA  1  28                   plp
000FCB  1  AA                   tax
000FCC  1  08 E0 01 F0          tst_x 1,$ff-minus-zero
000FD0  1  03 20 58 44  
000FD4  1  68 48 C9 7D  
000FDE  1  A9 00                load_flag 0
000FE0  1  48                   pha
000FE1  1  A9 00                lda #0          ;preset status
000FE3  1  98                   tya
000FE4  1  28                   plp
000FE5  1  AA                   tax
000FE6  1  08 E0 01 F0          tst_x 1,0
000FEA  1  03 20 58 44  
000FEE  1  68 48 C9 30  
000FF8  1  08                   php
000FF9  1  88                   dey             ;00
000FFA  1  98                   tya
000FFB  1  28                   plp
000FFC  1  AA                   tax
000FFD  1  08 E0 00 F0          tst_x 0,zero
001001  1  03 20 58 44  
001005  1  68 48 C9 32  
00100F  1  08                   php
001010  1  88                   dey             ;ff
001011  1  98                   tya
001012  1  28                   plp
001013  1  AA                   tax
001014  1  08 E0 FF F0          tst_x $ff,minus
001018  1  03 20 58 44  
00101C  1  68 48 C9 B0  
001026  1  AD 00 02 C9          next_test
00102A  1  0D F0 03 20  
00102E  1  58 44 A9 0E  
001035  1               
001035  1               ;TSX sets NZ - TXS does not
001035  1               ;  This section also tests for proper stack wrap around.
001035  1  A2 01                ldx #1          ;01
001037  1  A9 FF 48 28          set_stat $ff
00103B  1  9A                   txs
00103C  1  08                   php
00103D  1  AD 01 01             lda $101
001040  1  C9 FF                cmp_flag $ff
001042  1  F0 03 20 58          trap_ne
001046  1  44           
001047  1  A9 00 48 28          set_stat 0
00104B  1  9A                   txs
00104C  1  08                   php
00104D  1  AD 01 01             lda $101
001050  1  C9 30                cmp_flag 0
001052  1  F0 03 20 58          trap_ne
001056  1  44           
001057  1  CA                   dex             ;00
001058  1  A9 FF 48 28          set_stat $ff
00105C  1  9A                   txs
00105D  1  08                   php
00105E  1  AD 00 01             lda $100
001061  1  C9 FF                cmp_flag $ff
001063  1  F0 03 20 58          trap_ne
001067  1  44           
001068  1  A9 00 48 28          set_stat 0
00106C  1  9A                   txs
00106D  1  08                   php
00106E  1  AD 00 01             lda $100
001071  1  C9 30                cmp_flag 0
001073  1  F0 03 20 58          trap_ne
001077  1  44           
001078  1  CA                   dex             ;ff
001079  1  A9 FF 48 28          set_stat $ff
00107D  1  9A                   txs
00107E  1  08                   php
00107F  1  AD FF 01             lda $1ff
001082  1  C9 FF                cmp_flag $ff
001084  1  F0 03 20 58          trap_ne
001088  1  44           
001089  1  A9 00 48 28          set_stat 0
00108D  1  9A                   txs
00108E  1  08                   php
00108F  1  AD FF 01             lda $1ff
001092  1  C9 30                cmp_flag 0
001094  1               
001094  1  A2 01                ldx #1
001096  1  9A                   txs             ;sp=01
001097  1  A9 FF 48 28          set_stat $ff
00109B  1  BA                   tsx             ;clears Z, N
00109C  1  08                   php             ;sp=00
00109D  1  E0 01                cpx #1
00109F  1  F0 03 20 58          trap_ne
0010A3  1  44           
0010A4  1  AD 01 01             lda $101
0010A7  1  C9 7D                cmp_flag $ff-minus-zero
0010A9  1  F0 03 20 58          trap_ne
0010AD  1  44           
0010AE  1  A9 FF 48 28          set_stat $ff
0010B2  1  BA                   tsx             ;clears N, sets Z
0010B3  1  08                   php             ;sp=ff
0010B4  1  E0 00                cpx #0
0010B6  1  F0 03 20 58          trap_ne
0010BA  1  44           
0010BB  1  AD 00 01             lda $100
0010BE  1  C9 7F                cmp_flag $ff-minus
0010C0  1  F0 03 20 58          trap_ne
0010C4  1  44           
0010C5  1  A9 FF 48 28          set_stat $ff
0010C9  1  BA                   tsx             ;clears N, sets Z
0010CA  1  08                   php             ;sp=fe
0010CB  1  E0 FF                cpx #$ff
0010CD  1  F0 03 20 58          trap_ne
0010D1  1  44           
0010D2  1  AD FF 01             lda $1ff
0010D5  1  C9 FD                cmp_flag $ff-zero
0010D7  1  F0 03 20 58          trap_ne
0010DB  1  44           
0010DC  1               
0010DC  1  A2 01                ldx #1
0010DE  1  9A                   txs             ;sp=01
0010DF  1  A9 00 48 28          set_stat 0
0010E3  1  BA                   tsx             ;clears Z, N
0010E4  1  08                   php             ;sp=00
0010E5  1  E0 01                cpx #1
0010E7  1  F0 03 20 58          trap_ne
0010EB  1  44           
0010EC  1  AD 01 01             lda $101
0010EF  1  C9 30                cmp_flag 0
0010F1  1  F0 03 20 58          trap_ne
0010F5  1  44           
0010F6  1  A9 00 48 28          set_stat 0
0010FA  1  BA                   tsx             ;clears N, sets Z
0010FB  1  08                   php             ;sp=ff
0010FC  1  E0 00                cpx #0
0010FE  1  F0 03 20 58          trap_ne
001102  1  44           
001103  1  AD 00 01             lda $100
001106  1  C9 32                cmp_flag zero
001108  1  F0 03 20 58          trap_ne
00110C  1  44           
00110D  1  A9 00 48 28          set_stat 0
001111  1  BA                   tsx             ;clears N, sets Z
001112  1  08                   php             ;sp=fe
001113  1  E0 FF                cpx #$ff
001115  1  F0 03 20 58          trap_ne
001119  1  44           
00111A  1  AD FF 01             lda $1ff
00111D  1  C9 B0                cmp_flag minus
00111F  1  F0 03 20 58          trap_ne
001123  1  44           
001124  1  68                   pla             ;sp=ff
001125  1  AD 00 02 C9          next_test
001129  1  0E F0 03 20  
00112D  1  58 44 A9 0F  
001134  1               
001134  1               ; testing index register load & store LDY LDX STY STX all addressing modes
001134  1               ; LDX / STX - zp,y / abs,y
001134  1  A0 03                ldy #3
001136  1               tldx:
001136  1  A9 00 48 28          set_stat 0
00113A  1  B6 rr                ldx zp1,y
00113C  1  08                   php         ;test stores do not alter flags
00113D  1  8A                   txa
00113E  1  49 C3                eor #$c3
001140  1  28                   plp
001141  1  99 03 02             sta abst,y
001144  1  08                   php         ;flags after load/store s:=ence
001145  1  49 C3                eor #$c3
001147  1  D9 17 02             cmp abs1,y  ;test result
00114A  1  F0 03 20 58          trap_ne
00114E  1  44           
00114F  1  68                   pla         ;load status
001150  1  49 30                eor_flag 0
001152  1  D9 1C 02             cmp fLDx,y  ;test flags
001155  1  F0 03 20 58          trap_ne
001159  1  44           
00115A  1  88                   dey
00115B  1  10 D9                bpl tldx
00115D  1               
00115D  1  A0 03                ldy #3
00115F  1               tldx1:
00115F  1  A9 FF 48 28          set_stat $ff
001163  1  B6 rr                ldx zp1,y
001165  1  08                   php         ;test stores do not alter flags
001166  1  8A                   txa
001167  1  49 C3                eor #$c3
001169  1  28                   plp
00116A  1  99 03 02             sta abst,y
00116D  1  08                   php         ;flags after load/store s:=ence
00116E  1  49 C3                eor #$c3
001170  1  D9 17 02             cmp abs1,y  ;test result
001173  1  F0 03 20 58          trap_ne
001177  1  44           
001178  1  68                   pla         ;load status
001179  1  49 7D                eor_flag < ~ fnz ;mask bits not altered
00117B  1  D9 1C 02             cmp fLDx,y  ;test flags
00117E  1  F0 03 20 58          trap_ne
001182  1  44           
001183  1  88                   dey
001184  1  10 D9                bpl tldx1
001186  1               
001186  1  A0 03                ldy #3
001188  1               tldx2:
001188  1  A9 00 48 28          set_stat 0
00118C  1  BE 17 02             ldx abs1,y
00118F  1  08                   php         ;test stores do not alter flags
001190  1  8A                   txa
001191  1  49 C3                eor #$c3
001193  1  AA                   tax
001194  1  28                   plp
001195  1  96 rr                stx zpt,y
001197  1  08                   php         ;flags after load/store s:=ence
001198  1  49 C3                eor #$c3
00119A  1  D9 rr rr             cmp zp1,y   ;test result
00119D  1  F0 03 20 58          trap_ne
0011A1  1  44           
0011A2  1  68                   pla         ;load status
0011A3  1  49 30                eor_flag 0
0011A5  1  D9 1C 02             cmp fLDx,y  ;test flags
0011A8  1  F0 03 20 58          trap_ne
0011AC  1  44           
0011AD  1  88                   dey
0011AE  1  10 D8                bpl tldx2
0011B0  1               
0011B0  1  A0 03                ldy #3
0011B2  1               tldx3:
0011B2  1  A9 FF 48 28          set_stat $ff
0011B6  1  BE 17 02             ldx abs1,y
0011B9  1  08                   php         ;test stores do not alter flags
0011BA  1  8A                   txa
0011BB  1  49 C3                eor #$c3
0011BD  1  AA                   tax
0011BE  1  28                   plp
0011BF  1  96 rr                stx zpt,y
0011C1  1  08                   php         ;flags after load/store s:=ence
0011C2  1  49 C3                eor #$c3
0011C4  1  D9 rr rr             cmp zp1,y   ;test result
0011C7  1  F0 03 20 58          trap_ne
0011CB  1  44           
0011CC  1  68                   pla         ;load status
0011CD  1  49 7D                eor_flag <~fnz ;mask bits not altered
0011CF  1  D9 1C 02             cmp fLDx,y  ;test flags
0011D2  1  F0 03 20 58          trap_ne
0011D6  1  44           
0011D7  1  88                   dey
0011D8  1  10 D8                bpl tldx3
0011DA  1               
0011DA  1  A0 03                ldy #3      ;testing store result
0011DC  1  A2 00                ldx #0
0011DE  1  B9 rr rr     tstx:    lda zpt,y
0011E1  1  49 C3                eor #$c3
0011E3  1  D9 rr rr             cmp zp1,y
0011E6  1  F0 03 20 58          trap_ne     ;store to zp data
0011EA  1  44           
0011EB  1  96 rr                stx zpt,y   ;clear
0011ED  1  B9 03 02             lda abst,y
0011F0  1  49 C3                eor #$c3
0011F2  1  D9 17 02             cmp abs1,y
0011F5  1  F0 03 20 58          trap_ne     ;store to abs data
0011F9  1  44           
0011FA  1  8A                   txa
0011FB  1  99 03 02             sta abst,y  ;clear
0011FE  1  88                   dey
0011FF  1  10 DD                bpl tstx
001201  1  AD 00 02 C9          next_test
001205  1  0F F0 03 20  
001209  1  58 44 A9 10  
001210  1               
001210  1               ; indexed wraparound test (only zp should wrap)
001210  1  A0 FD                ldy #3+$fa
001212  1  B6 rr        tldx4:   ldx <(zp1-$fa),y   ;wrap on indexed zp
001214  1  8A                   txa
001215  1  99 09 01             sta abst-$fa,y      ;no STX abs,y!
001218  1  88                   dey
001219  1  C0 FA                cpy #$fa
00121B  1  B0 F5                bcs tldx4
00121D  1  A0 FD                ldy #3+$fa
00121F  1  BE 1D 01     tldx5:   ldx abs1-$fa,y      ;no wrap on indexed abs
001222  1  96 rr                stx <(zpt-$fa),y
001224  1  88                   dey
001225  1  C0 FA                cpy #$fa
001227  1  B0 F6                bcs tldx5
001229  1  A0 03                ldy #3      ;testing wraparound result
00122B  1  A2 00                ldx #0
00122D  1  B9 rr rr     tstx1:   lda zpt,y
001230  1  D9 rr rr             cmp zp1,y
001233  1  F0 03 20 58          trap_ne     ;store to zp data
001237  1  44           
001238  1  96 rr                stx zpt,y   ;clear
00123A  1  B9 03 02             lda abst,y
00123D  1  D9 17 02             cmp abs1,y
001240  1  F0 03 20 58          trap_ne     ;store to abs data
001244  1  44           
001245  1  8A                   txa
001246  1  99 03 02             sta abst,y  ;clear
001249  1  88                   dey
00124A  1  10 E1                bpl tstx1
00124C  1  AD 00 02 C9          next_test
001250  1  10 F0 03 20  
001254  1  58 44 A9 11  
00125B  1               
00125B  1               ; LDY / STY - zp,x / abs,x
00125B  1  A2 03                ldx #3
00125D  1               tldy:
00125D  1  A9 00 48 28          set_stat 0
001261  1  B4 rr                ldy zp1,x
001263  1  08                   php         ;test stores do not alter flags
001264  1  98                   tya
001265  1  49 C3                eor #$c3
001267  1  28                   plp
001268  1  9D 03 02             sta abst,x
00126B  1  08                   php         ;flags after load/store s:=ence
00126C  1  49 C3                eor #$c3
00126E  1  DD 17 02             cmp abs1,x  ;test result
001271  1  F0 03 20 58          trap_ne
001275  1  44           
001276  1  68                   pla         ;load status
001277  1  49 30                eor_flag 0
001279  1  DD 1C 02             cmp fLDx,x  ;test flags
00127C  1  F0 03 20 58          trap_ne
001280  1  44           
001281  1  CA                   dex
001282  1  10 D9                bpl tldy
001284  1               
001284  1  A2 03                ldx #3
001286  1               tldy1:
001286  1  A9 FF 48 28          set_stat $ff
00128A  1  B4 rr                ldy zp1,x
00128C  1  08                   php         ;test stores do not alter flags
00128D  1  98                   tya
00128E  1  49 C3                eor #$c3
001290  1  28                   plp
001291  1  9D 03 02             sta abst,x
001294  1  08                   php         ;flags after load/store s:=ence
001295  1  49 C3                eor #$c3
001297  1  DD 17 02             cmp abs1,x  ;test result
00129A  1  F0 03 20 58          trap_ne
00129E  1  44           
00129F  1  68                   pla         ;load status
0012A0  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012A2  1  DD 1C 02             cmp fLDx,x  ;test flags
0012A5  1  F0 03 20 58          trap_ne
0012A9  1  44           
0012AA  1  CA                   dex
0012AB  1  10 D9                bpl tldy1
0012AD  1               
0012AD  1  A2 03                ldx #3
0012AF  1               tldy2:
0012AF  1  A9 00 48 28          set_stat 0
0012B3  1  BC 17 02             ldy abs1,x
0012B6  1  08                   php         ;test stores do not alter flags
0012B7  1  98                   tya
0012B8  1  49 C3                eor #$c3
0012BA  1  A8                   tay
0012BB  1  28                   plp
0012BC  1  94 rr                sty zpt,x
0012BE  1  08                   php         ;flags after load/store s:=ence
0012BF  1  49 C3                eor #$c3
0012C1  1  D5 rr                cmp zp1,x   ;test result
0012C3  1  F0 03 20 58          trap_ne
0012C7  1  44           
0012C8  1  68                   pla         ;load status
0012C9  1  49 30                eor_flag 0
0012CB  1  DD 1C 02             cmp fLDx,x  ;test flags
0012CE  1  F0 03 20 58          trap_ne
0012D2  1  44           
0012D3  1  CA                   dex
0012D4  1  10 D9                bpl tldy2
0012D6  1               
0012D6  1  A2 03                ldx #3
0012D8  1               tldy3:
0012D8  1  A9 FF 48 28          set_stat $ff
0012DC  1  BC 17 02             ldy abs1,x
0012DF  1  08                   php         ;test stores do not alter flags
0012E0  1  98                   tya
0012E1  1  49 C3                eor #$c3
0012E3  1  A8                   tay
0012E4  1  28                   plp
0012E5  1  94 rr                sty zpt,x
0012E7  1  08                   php         ;flags after load/store s:=ence
0012E8  1  49 C3                eor #$c3
0012EA  1  D5 rr                cmp zp1,x   ;test result
0012EC  1  F0 03 20 58          trap_ne
0012F0  1  44           
0012F1  1  68                   pla         ;load status
0012F2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012F4  1  DD 1C 02             cmp fLDx,x  ;test flags
0012F7  1  F0 03 20 58          trap_ne
0012FB  1  44           
0012FC  1  CA                   dex
0012FD  1  10 D9                bpl tldy3
0012FF  1               
0012FF  1  A2 03                ldx #3      ;testing store result
001301  1  A0 00                ldy #0
001303  1  B5 rr        tsty:    lda zpt,x
001305  1  49 C3                eor #$c3
001307  1  D5 rr                cmp zp1,x
001309  1  F0 03 20 58          trap_ne     ;store to zp,x data
00130D  1  44           
00130E  1  94 rr                sty zpt,x   ;clear
001310  1  BD 03 02             lda abst,x
001313  1  49 C3                eor #$c3
001315  1  DD 17 02             cmp abs1,x
001318  1  F0 03 20 58          trap_ne     ;store to abs,x data
00131C  1  44           
00131D  1  8A                   txa
00131E  1  9D 03 02             sta abst,x  ;clear
001321  1  CA                   dex
001322  1  10 DF                bpl tsty
001324  1  AD 00 02 C9          next_test
001328  1  11 F0 03 20  
00132C  1  58 44 A9 12  
001333  1               
001333  1               ; indexed wraparound test (only zp should wrap)
001333  1  A2 FD                ldx #3+$fa
001335  1  B4 rr        tldy4:   ldy <(zp1-$fa),x   ;wrap on indexed zp
001337  1  98                   tya
001338  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
00133B  1  CA                   dex
00133C  1  E0 FA                cpx #$fa
00133E  1  B0 F5                bcs tldy4
001340  1  A2 FD                ldx #3+$fa
001342  1  BC 1D 01     tldy5:   ldy abs1-$fa,x      ;no wrap on indexed abs
001345  1  94 rr                sty <(zpt-$fa),x
001347  1  CA                   dex
001348  1  E0 FA                cpx #$fa
00134A  1  B0 F6                bcs tldy5
00134C  1  A2 03                ldx #3      ;testing wraparound result
00134E  1  A0 00                ldy #0
001350  1  B5 rr        tsty1:   lda zpt,x
001352  1  D5 rr                cmp zp1,x
001354  1  F0 03 20 58          trap_ne     ;store to zp,x data
001358  1  44           
001359  1  94 rr                sty zpt,x   ;clear
00135B  1  BD 03 02             lda abst,x
00135E  1  DD 17 02             cmp abs1,x
001361  1  F0 03 20 58          trap_ne     ;store to abs,x data
001365  1  44           
001366  1  8A                   txa
001367  1  9D 03 02             sta abst,x  ;clear
00136A  1  CA                   dex
00136B  1  10 E3                bpl tsty1
00136D  1  AD 00 02 C9          next_test
001371  1  12 F0 03 20  
001375  1  58 44 A9 13  
00137C  1               
00137C  1               ; LDX / STX - zp / abs / #
00137C  1  A9 00 48 28          set_stat 0
001380  1  A6 rr                ldx zp1
001382  1  08                   php         ;test stores do not alter flags
001383  1  8A                   txa
001384  1  49 C3                eor #$c3
001386  1  AA                   tax
001387  1  28                   plp
001388  1  8E 03 02             stx abst
00138B  1  08                   php         ;flags after load/store s:=ence
00138C  1  49 C3                eor #$c3
00138E  1  AA                   tax
00138F  1  E0 C3                cpx #$c3    ;test result
001391  1  F0 03 20 58          trap_ne
001395  1  44           
001396  1  68                   pla         ;load status
001397  1  49 30                eor_flag 0
001399  1  CD 1C 02             cmp fLDx    ;test flags
00139C  1  F0 03 20 58          trap_ne
0013A0  1  44           
0013A1  1  A9 00 48 28          set_stat 0
0013A5  1  A6 rr                ldx zp1+1
0013A7  1  08                   php         ;test stores do not alter flags
0013A8  1  8A                   txa
0013A9  1  49 C3                eor #$c3
0013AB  1  AA                   tax
0013AC  1  28                   plp
0013AD  1  8E 04 02             stx abst+1
0013B0  1  08                   php         ;flags after load/store s:=ence
0013B1  1  49 C3                eor #$c3
0013B3  1  AA                   tax
0013B4  1  E0 82                cpx #$82    ;test result
0013B6  1  F0 03 20 58          trap_ne
0013BA  1  44           
0013BB  1  68                   pla         ;load status
0013BC  1  49 30                eor_flag 0
0013BE  1  CD 1D 02             cmp fLDx+1  ;test flags
0013C1  1  F0 03 20 58          trap_ne
0013C5  1  44           
0013C6  1  A9 00 48 28          set_stat 0
0013CA  1  A6 rr                ldx zp1+2
0013CC  1  08                   php         ;test stores do not alter flags
0013CD  1  8A                   txa
0013CE  1  49 C3                eor #$c3
0013D0  1  AA                   tax
0013D1  1  28                   plp
0013D2  1  8E 05 02             stx abst+2
0013D5  1  08                   php         ;flags after load/store s:=ence
0013D6  1  49 C3                eor #$c3
0013D8  1  AA                   tax
0013D9  1  E0 41                cpx #$41    ;test result
0013DB  1  F0 03 20 58          trap_ne
0013DF  1  44           
0013E0  1  68                   pla         ;load status
0013E1  1  49 30                eor_flag 0
0013E3  1  CD 1E 02             cmp fLDx+2  ;test flags
0013E6  1  F0 03 20 58          trap_ne
0013EA  1  44           
0013EB  1  A9 00 48 28          set_stat 0
0013EF  1  A6 rr                ldx zp1+3
0013F1  1  08                   php         ;test stores do not alter flags
0013F2  1  8A                   txa
0013F3  1  49 C3                eor #$c3
0013F5  1  AA                   tax
0013F6  1  28                   plp
0013F7  1  8E 06 02             stx abst+3
0013FA  1  08                   php         ;flags after load/store s:=ence
0013FB  1  49 C3                eor #$c3
0013FD  1  AA                   tax
0013FE  1  E0 00                cpx #0      ;test result
001400  1  F0 03 20 58          trap_ne
001404  1  44           
001405  1  68                   pla         ;load status
001406  1  49 30                eor_flag 0
001408  1  CD 1F 02             cmp fLDx+3  ;test flags
00140B  1  F0 03 20 58          trap_ne
00140F  1  44           
001410  1               
001410  1  A9 FF 48 28          set_stat $ff
001414  1  A6 rr                ldx zp1
001416  1  08                   php         ;test stores do not alter flags
001417  1  8A                   txa
001418  1  49 C3                eor #$c3
00141A  1  AA                   tax
00141B  1  28                   plp
00141C  1  8E 03 02             stx abst
00141F  1  08                   php         ;flags after load/store s:=ence
001420  1  49 C3                eor #$c3
001422  1  AA                   tax
001423  1  E0 C3                cpx #$c3    ;test result
001425  1  F0 03 20 58          trap_ne     ;
001429  1  44           
00142A  1  68                   pla         ;load status
00142B  1  49 7D                eor_flag <~fnz ;mask bits not altered
00142D  1  CD 1C 02             cmp fLDx    ;test flags
001430  1  F0 03 20 58          trap_ne
001434  1  44           
001435  1  A9 FF 48 28          set_stat $ff
001439  1  A6 rr                ldx zp1+1
00143B  1  08                   php         ;test stores do not alter flags
00143C  1  8A                   txa
00143D  1  49 C3                eor #$c3
00143F  1  AA                   tax
001440  1  28                   plp
001441  1  8E 04 02             stx abst+1
001444  1  08                   php         ;flags after load/store s:=ence
001445  1  49 C3                eor #$c3
001447  1  AA                   tax
001448  1  E0 82                cpx #$82    ;test result
00144A  1  F0 03 20 58          trap_ne
00144E  1  44           
00144F  1  68                   pla         ;load status
001450  1  49 7D                eor_flag <~fnz ;mask bits not altered
001452  1  CD 1D 02             cmp fLDx+1  ;test flags
001455  1  F0 03 20 58          trap_ne
001459  1  44           
00145A  1  A9 FF 48 28          set_stat $ff
00145E  1  A6 rr                ldx zp1+2
001460  1  08                   php         ;test stores do not alter flags
001461  1  8A                   txa
001462  1  49 C3                eor #$c3
001464  1  AA                   tax
001465  1  28                   plp
001466  1  8E 05 02             stx abst+2
001469  1  08                   php         ;flags after load/store s:=ence
00146A  1  49 C3                eor #$c3
00146C  1  AA                   tax
00146D  1  E0 41                cpx #$41    ;test result
00146F  1  F0 03 20 58          trap_ne     ;
001473  1  44           
001474  1  68                   pla         ;load status
001475  1  49 7D                eor_flag <~fnz ;mask bits not altered
001477  1  CD 1E 02             cmp fLDx+2  ;test flags
00147A  1  F0 03 20 58          trap_ne
00147E  1  44           
00147F  1  A9 FF 48 28          set_stat $ff
001483  1  A6 rr                ldx zp1+3
001485  1  08                   php         ;test stores do not alter flags
001486  1  8A                   txa
001487  1  49 C3                eor #$c3
001489  1  AA                   tax
00148A  1  28                   plp
00148B  1  8E 06 02             stx abst+3
00148E  1  08                   php         ;flags after load/store s:=ence
00148F  1  49 C3                eor #$c3
001491  1  AA                   tax
001492  1  E0 00                cpx #0      ;test result
001494  1  F0 03 20 58          trap_ne
001498  1  44           
001499  1  68                   pla         ;load status
00149A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00149C  1  CD 1F 02             cmp fLDx+3  ;test flags
00149F  1  F0 03 20 58          trap_ne
0014A3  1  44           
0014A4  1               
0014A4  1  A9 00 48 28          set_stat 0
0014A8  1  AE 17 02             ldx abs1
0014AB  1  08                   php         ;test stores do not alter flags
0014AC  1  8A                   txa
0014AD  1  49 C3                eor #$c3
0014AF  1  AA                   tax
0014B0  1  28                   plp
0014B1  1  86 rr                stx zpt
0014B3  1  08                   php         ;flags after load/store s:=ence
0014B4  1  49 C3                eor #$c3
0014B6  1  C5 rr                cmp zp1     ;test result
0014B8  1  F0 03 20 58          trap_ne
0014BC  1  44           
0014BD  1  68                   pla         ;load status
0014BE  1  49 30                eor_flag 0
0014C0  1  CD 1C 02             cmp fLDx    ;test flags
0014C3  1  F0 03 20 58          trap_ne
0014C7  1  44           
0014C8  1  A9 00 48 28          set_stat 0
0014CC  1  AE 18 02             ldx abs1+1
0014CF  1  08                   php         ;test stores do not alter flags
0014D0  1  8A                   txa
0014D1  1  49 C3                eor #$c3
0014D3  1  AA                   tax
0014D4  1  28                   plp
0014D5  1  86 rr                stx zpt+1
0014D7  1  08                   php         ;flags after load/store s:=ence
0014D8  1  49 C3                eor #$c3
0014DA  1  C5 rr                cmp zp1+1   ;test result
0014DC  1  F0 03 20 58          trap_ne
0014E0  1  44           
0014E1  1  68                   pla         ;load status
0014E2  1  49 30                eor_flag 0
0014E4  1  CD 1D 02             cmp fLDx+1  ;test flags
0014E7  1  F0 03 20 58          trap_ne
0014EB  1  44           
0014EC  1  A9 00 48 28          set_stat 0
0014F0  1  AE 19 02             ldx abs1+2
0014F3  1  08                   php         ;test stores do not alter flags
0014F4  1  8A                   txa
0014F5  1  49 C3                eor #$c3
0014F7  1  AA                   tax
0014F8  1  28                   plp
0014F9  1  86 rr                stx zpt+2
0014FB  1  08                   php         ;flags after load/store s:=ence
0014FC  1  49 C3                eor #$c3
0014FE  1  C5 rr                cmp zp1+2   ;test result
001500  1  F0 03 20 58          trap_ne
001504  1  44           
001505  1  68                   pla         ;load status
001506  1  49 30                eor_flag 0
001508  1  CD 1E 02             cmp fLDx+2  ;test flags
00150B  1  F0 03 20 58          trap_ne
00150F  1  44           
001510  1  A9 00 48 28          set_stat 0
001514  1  AE 1A 02             ldx abs1+3
001517  1  08                   php         ;test stores do not alter flags
001518  1  8A                   txa
001519  1  49 C3                eor #$c3
00151B  1  AA                   tax
00151C  1  28                   plp
00151D  1  86 rr                stx zpt+3
00151F  1  08                   php         ;flags after load/store s:=ence
001520  1  49 C3                eor #$c3
001522  1  C5 rr                cmp zp1+3   ;test result
001524  1  F0 03 20 58          trap_ne
001528  1  44           
001529  1  68                   pla         ;load status
00152A  1  49 30                eor_flag 0
00152C  1  CD 1F 02             cmp fLDx+3  ;test flags
00152F  1  F0 03 20 58          trap_ne
001533  1  44           
001534  1               
001534  1  A9 FF 48 28          set_stat $ff
001538  1  AE 17 02             ldx abs1
00153B  1  08                   php         ;test stores do not alter flags
00153C  1  8A                   txa
00153D  1  49 C3                eor #$c3
00153F  1  AA                   tax
001540  1  28                   plp
001541  1  86 rr                stx zpt
001543  1  08                   php         ;flags after load/store s:=ence
001544  1  49 C3                eor #$c3
001546  1  AA                   tax
001547  1  E4 rr                cpx zp1     ;test result
001549  1  F0 03 20 58          trap_ne
00154D  1  44           
00154E  1  68                   pla         ;load status
00154F  1  49 7D                eor_flag <~fnz ;mask bits not altered
001551  1  CD 1C 02             cmp fLDx    ;test flags
001554  1  F0 03 20 58          trap_ne
001558  1  44           
001559  1  A9 FF 48 28          set_stat $ff
00155D  1  AE 18 02             ldx abs1+1
001560  1  08                   php         ;test stores do not alter flags
001561  1  8A                   txa
001562  1  49 C3                eor #$c3
001564  1  AA                   tax
001565  1  28                   plp
001566  1  86 rr                stx zpt+1
001568  1  08                   php         ;flags after load/store s:=ence
001569  1  49 C3                eor #$c3
00156B  1  AA                   tax
00156C  1  E4 rr                cpx zp1+1   ;test result
00156E  1  F0 03 20 58          trap_ne
001572  1  44           
001573  1  68                   pla         ;load status
001574  1  49 7D                eor_flag <~fnz ;mask bits not altered
001576  1  CD 1D 02             cmp fLDx+1  ;test flags
001579  1  F0 03 20 58          trap_ne
00157D  1  44           
00157E  1  A9 FF 48 28          set_stat $ff
001582  1  AE 19 02             ldx abs1+2
001585  1  08                   php         ;test stores do not alter flags
001586  1  8A                   txa
001587  1  49 C3                eor #$c3
001589  1  AA                   tax
00158A  1  28                   plp
00158B  1  86 rr                stx zpt+2
00158D  1  08                   php         ;flags after load/store s:=ence
00158E  1  49 C3                eor #$c3
001590  1  AA                   tax
001591  1  E4 rr                cpx zp1+2   ;test result
001593  1  F0 03 20 58          trap_ne
001597  1  44           
001598  1  68                   pla         ;load status
001599  1  49 7D                eor_flag <~fnz ;mask bits not altered
00159B  1  CD 1E 02             cmp fLDx+2  ;test flags
00159E  1  F0 03 20 58          trap_ne
0015A2  1  44           
0015A3  1  A9 FF 48 28          set_stat $ff
0015A7  1  AE 1A 02             ldx abs1+3
0015AA  1  08                   php         ;test stores do not alter flags
0015AB  1  8A                   txa
0015AC  1  49 C3                eor #$c3
0015AE  1  AA                   tax
0015AF  1  28                   plp
0015B0  1  86 rr                stx zpt+3
0015B2  1  08                   php         ;flags after load/store s:=ence
0015B3  1  49 C3                eor #$c3
0015B5  1  AA                   tax
0015B6  1  E4 rr                cpx zp1+3   ;test result
0015B8  1  F0 03 20 58          trap_ne
0015BC  1  44           
0015BD  1  68                   pla         ;load status
0015BE  1  49 7D                eor_flag <~fnz ;mask bits not altered
0015C0  1  CD 1F 02             cmp fLDx+3  ;test flags
0015C3  1  F0 03 20 58          trap_ne
0015C7  1  44           
0015C8  1               
0015C8  1  A9 00 48 28          set_stat 0
0015CC  1  A2 C3                ldx #$c3
0015CE  1  08                   php
0015CF  1  EC 17 02             cpx abs1    ;test result
0015D2  1  F0 03 20 58          trap_ne
0015D6  1  44           
0015D7  1  68                   pla         ;load status
0015D8  1  49 30                eor_flag 0
0015DA  1  CD 1C 02             cmp fLDx    ;test flags
0015DD  1  F0 03 20 58          trap_ne
0015E1  1  44           
0015E2  1  A9 00 48 28          set_stat 0
0015E6  1  A2 82                ldx #$82
0015E8  1  08                   php
0015E9  1  EC 18 02             cpx abs1+1  ;test result
0015EC  1  F0 03 20 58          trap_ne
0015F0  1  44           
0015F1  1  68                   pla         ;load status
0015F2  1  49 30                eor_flag 0
0015F4  1  CD 1D 02             cmp fLDx+1  ;test flags
0015F7  1  F0 03 20 58          trap_ne
0015FB  1  44           
0015FC  1  A9 00 48 28          set_stat 0
001600  1  A2 41                ldx #$41
001602  1  08                   php
001603  1  EC 19 02             cpx abs1+2  ;test result
001606  1  F0 03 20 58          trap_ne
00160A  1  44           
00160B  1  68                   pla         ;load status
00160C  1  49 30                eor_flag 0
00160E  1  CD 1E 02             cmp fLDx+2  ;test flags
001611  1  F0 03 20 58          trap_ne
001615  1  44           
001616  1  A9 00 48 28          set_stat 0
00161A  1  A2 00                ldx #0
00161C  1  08                   php
00161D  1  EC 1A 02             cpx abs1+3  ;test result
001620  1  F0 03 20 58          trap_ne
001624  1  44           
001625  1  68                   pla         ;load status
001626  1  49 30                eor_flag 0
001628  1  CD 1F 02             cmp fLDx+3  ;test flags
00162B  1  F0 03 20 58          trap_ne
00162F  1  44           
001630  1               
001630  1  A9 FF 48 28          set_stat $ff
001634  1  A2 C3                ldx #$c3
001636  1  08                   php
001637  1  EC 17 02             cpx abs1    ;test result
00163A  1  F0 03 20 58          trap_ne
00163E  1  44           
00163F  1  68                   pla         ;load status
001640  1  49 7D                eor_flag <~fnz ;mask bits not altered
001642  1  CD 1C 02             cmp fLDx    ;test flags
001645  1  F0 03 20 58          trap_ne
001649  1  44           
00164A  1  A9 FF 48 28          set_stat $ff
00164E  1  A2 82                ldx #$82
001650  1  08                   php
001651  1  EC 18 02             cpx abs1+1  ;test result
001654  1  F0 03 20 58          trap_ne
001658  1  44           
001659  1  68                   pla         ;load status
00165A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00165C  1  CD 1D 02             cmp fLDx+1  ;test flags
00165F  1  F0 03 20 58          trap_ne
001663  1  44           
001664  1  A9 FF 48 28          set_stat $ff
001668  1  A2 41                ldx #$41
00166A  1  08                   php
00166B  1  EC 19 02             cpx abs1+2  ;test result
00166E  1  F0 03 20 58          trap_ne
001672  1  44           
001673  1  68                   pla         ;load status
001674  1  49 7D                eor_flag <~fnz ;mask bits not altered
001676  1  CD 1E 02             cmp fLDx+2  ;test flags
001679  1  F0 03 20 58          trap_ne
00167D  1  44           
00167E  1  A9 FF 48 28          set_stat $ff
001682  1  A2 00                ldx #0
001684  1  08                   php
001685  1  EC 1A 02             cpx abs1+3  ;test result
001688  1  F0 03 20 58          trap_ne
00168C  1  44           
00168D  1  68                   pla         ;load status
00168E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001690  1  CD 1F 02             cmp fLDx+3  ;test flags
001693  1  F0 03 20 58          trap_ne
001697  1  44           
001698  1               
001698  1  A2 00                ldx #0
00169A  1  A5 rr                lda zpt
00169C  1  49 C3                eor #$c3
00169E  1  C5 rr                cmp zp1
0016A0  1  F0 03 20 58          trap_ne     ;store to zp data
0016A4  1  44           
0016A5  1  86 rr                stx zpt     ;clear
0016A7  1  AD 03 02             lda abst
0016AA  1  49 C3                eor #$c3
0016AC  1  CD 17 02             cmp abs1
0016AF  1  F0 03 20 58          trap_ne     ;store to abs data
0016B3  1  44           
0016B4  1  8E 03 02             stx abst    ;clear
0016B7  1  A5 rr                lda zpt+1
0016B9  1  49 C3                eor #$c3
0016BB  1  C5 rr                cmp zp1+1
0016BD  1  F0 03 20 58          trap_ne     ;store to zp data
0016C1  1  44           
0016C2  1  86 rr                stx zpt+1   ;clear
0016C4  1  AD 04 02             lda abst+1
0016C7  1  49 C3                eor #$c3
0016C9  1  CD 18 02             cmp abs1+1
0016CC  1  F0 03 20 58          trap_ne     ;store to abs data
0016D0  1  44           
0016D1  1  8E 04 02             stx abst+1  ;clear
0016D4  1  A5 rr                lda zpt+2
0016D6  1  49 C3                eor #$c3
0016D8  1  C5 rr                cmp zp1+2
0016DA  1  F0 03 20 58          trap_ne     ;store to zp data
0016DE  1  44           
0016DF  1  86 rr                stx zpt+2   ;clear
0016E1  1  AD 05 02             lda abst+2
0016E4  1  49 C3                eor #$c3
0016E6  1  CD 19 02             cmp abs1+2
0016E9  1  F0 03 20 58          trap_ne     ;store to abs data
0016ED  1  44           
0016EE  1  8E 05 02             stx abst+2  ;clear
0016F1  1  A5 rr                lda zpt+3
0016F3  1  49 C3                eor #$c3
0016F5  1  C5 rr                cmp zp1+3
0016F7  1  F0 03 20 58          trap_ne     ;store to zp data
0016FB  1  44           
0016FC  1  86 rr                stx zpt+3   ;clear
0016FE  1  AD 06 02             lda abst+3
001701  1  49 C3                eor #$c3
001703  1  CD 1A 02             cmp abs1+3
001706  1  F0 03 20 58          trap_ne     ;store to abs data
00170A  1  44           
00170B  1  8E 06 02             stx abst+3  ;clear
00170E  1  AD 00 02 C9          next_test
001712  1  13 F0 03 20  
001716  1  58 44 A9 14  
00171D  1               
00171D  1               ; LDY / STY - zp / abs / #
00171D  1  A9 00 48 28          set_stat 0
001721  1  A4 rr                ldy zp1
001723  1  08                   php         ;test stores do not alter flags
001724  1  98                   tya
001725  1  49 C3                eor #$c3
001727  1  A8                   tay
001728  1  28                   plp
001729  1  8C 03 02             sty abst
00172C  1  08                   php         ;flags after load/store s:=ence
00172D  1  49 C3                eor #$c3
00172F  1  A8                   tay
001730  1  C0 C3                cpy #$c3    ;test result
001732  1  F0 03 20 58          trap_ne
001736  1  44           
001737  1  68                   pla         ;load status
001738  1  49 30                eor_flag 0
00173A  1  CD 1C 02             cmp fLDx    ;test flags
00173D  1  F0 03 20 58          trap_ne
001741  1  44           
001742  1  A9 00 48 28          set_stat 0
001746  1  A4 rr                ldy zp1+1
001748  1  08                   php         ;test stores do not alter flags
001749  1  98                   tya
00174A  1  49 C3                eor #$c3
00174C  1  A8                   tay
00174D  1  28                   plp
00174E  1  8C 04 02             sty abst+1
001751  1  08                   php         ;flags after load/store s:=ence
001752  1  49 C3                eor #$c3
001754  1  A8                   tay
001755  1  C0 82                cpy #$82    ;test result
001757  1  F0 03 20 58          trap_ne
00175B  1  44           
00175C  1  68                   pla         ;load status
00175D  1  49 30                eor_flag 0
00175F  1  CD 1D 02             cmp fLDx+1  ;test flags
001762  1  F0 03 20 58          trap_ne
001766  1  44           
001767  1  A9 00 48 28          set_stat 0
00176B  1  A4 rr                ldy zp1+2
00176D  1  08                   php         ;test stores do not alter flags
00176E  1  98                   tya
00176F  1  49 C3                eor #$c3
001771  1  A8                   tay
001772  1  28                   plp
001773  1  8C 05 02             sty abst+2
001776  1  08                   php         ;flags after load/store s:=ence
001777  1  49 C3                eor #$c3
001779  1  A8                   tay
00177A  1  C0 41                cpy #$41    ;test result
00177C  1  F0 03 20 58          trap_ne
001780  1  44           
001781  1  68                   pla         ;load status
001782  1  49 30                eor_flag 0
001784  1  CD 1E 02             cmp fLDx+2  ;test flags
001787  1  F0 03 20 58          trap_ne
00178B  1  44           
00178C  1  A9 00 48 28          set_stat 0
001790  1  A4 rr                ldy zp1+3
001792  1  08                   php         ;test stores do not alter flags
001793  1  98                   tya
001794  1  49 C3                eor #$c3
001796  1  A8                   tay
001797  1  28                   plp
001798  1  8C 06 02             sty abst+3
00179B  1  08                   php         ;flags after load/store s:=ence
00179C  1  49 C3                eor #$c3
00179E  1  A8                   tay
00179F  1  C0 00                cpy #0      ;test result
0017A1  1  F0 03 20 58          trap_ne
0017A5  1  44           
0017A6  1  68                   pla         ;load status
0017A7  1  49 30                eor_flag 0
0017A9  1  CD 1F 02             cmp fLDx+3  ;test flags
0017AC  1  F0 03 20 58          trap_ne
0017B0  1  44           
0017B1  1               
0017B1  1  A9 FF 48 28          set_stat $ff
0017B5  1  A4 rr                ldy zp1
0017B7  1  08                   php         ;test stores do not alter flags
0017B8  1  98                   tya
0017B9  1  49 C3                eor #$c3
0017BB  1  A8                   tay
0017BC  1  28                   plp
0017BD  1  8C 03 02             sty abst
0017C0  1  08                   php         ;flags after load/store s:=ence
0017C1  1  49 C3                eor #$c3
0017C3  1  A8                   tay
0017C4  1  C0 C3                cpy #$c3    ;test result
0017C6  1  F0 03 20 58          trap_ne
0017CA  1  44           
0017CB  1  68                   pla         ;load status
0017CC  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017CE  1  CD 1C 02             cmp fLDx    ;test flags
0017D1  1  F0 03 20 58          trap_ne
0017D5  1  44           
0017D6  1  A9 FF 48 28          set_stat $ff
0017DA  1  A4 rr                ldy zp1+1
0017DC  1  08                   php         ;test stores do not alter flags
0017DD  1  98                   tya
0017DE  1  49 C3                eor #$c3
0017E0  1  A8                   tay
0017E1  1  28                   plp
0017E2  1  8C 04 02             sty abst+1
0017E5  1  08                   php         ;flags after load/store s:=ence
0017E6  1  49 C3                eor #$c3
0017E8  1  A8                   tay
0017E9  1  C0 82                cpy #$82   ;test result
0017EB  1  F0 03 20 58          trap_ne
0017EF  1  44           
0017F0  1  68                   pla         ;load status
0017F1  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017F3  1  CD 1D 02             cmp fLDx+1  ;test flags
0017F6  1  F0 03 20 58          trap_ne
0017FA  1  44           
0017FB  1  A9 FF 48 28          set_stat $ff
0017FF  1  A4 rr                ldy zp1+2
001801  1  08                   php         ;test stores do not alter flags
001802  1  98                   tya
001803  1  49 C3                eor #$c3
001805  1  A8                   tay
001806  1  28                   plp
001807  1  8C 05 02             sty abst+2
00180A  1  08                   php         ;flags after load/store s:=ence
00180B  1  49 C3                eor #$c3
00180D  1  A8                   tay
00180E  1  C0 41                cpy #$41    ;test result
001810  1  F0 03 20 58          trap_ne
001814  1  44           
001815  1  68                   pla         ;load status
001816  1  49 7D                eor_flag <~fnz ;mask bits not altered
001818  1  CD 1E 02             cmp fLDx+2  ;test flags
00181B  1  F0 03 20 58          trap_ne
00181F  1  44           
001820  1  A9 FF 48 28          set_stat $ff
001824  1  A4 rr                ldy zp1+3
001826  1  08                   php         ;test stores do not alter flags
001827  1  98                   tya
001828  1  49 C3                eor #$c3
00182A  1  A8                   tay
00182B  1  28                   plp
00182C  1  8C 06 02             sty abst+3
00182F  1  08                   php         ;flags after load/store s:=ence
001830  1  49 C3                eor #$c3
001832  1  A8                   tay
001833  1  C0 00                cpy #0      ;test result
001835  1  F0 03 20 58          trap_ne
001839  1  44           
00183A  1  68                   pla         ;load status
00183B  1  49 7D                eor_flag <~fnz ;mask bits not altered
00183D  1  CD 1F 02             cmp fLDx+3  ;test flags
001840  1  F0 03 20 58          trap_ne
001844  1  44           
001845  1               
001845  1  A9 00 48 28          set_stat 0
001849  1  AC 17 02             ldy abs1
00184C  1  08                   php         ;test stores do not alter flags
00184D  1  98                   tya
00184E  1  49 C3                eor #$c3
001850  1  A8                   tay
001851  1  28                   plp
001852  1  84 rr                sty zpt
001854  1  08                   php         ;flags after load/store s:=ence
001855  1  49 C3                eor #$c3
001857  1  A8                   tay
001858  1  C4 rr                cpy zp1     ;test result
00185A  1  F0 03 20 58          trap_ne
00185E  1  44           
00185F  1  68                   pla         ;load status
001860  1  49 30                eor_flag 0
001862  1  CD 1C 02             cmp fLDx    ;test flags
001865  1  F0 03 20 58          trap_ne
001869  1  44           
00186A  1  A9 00 48 28          set_stat 0
00186E  1  AC 18 02             ldy abs1+1
001871  1  08                   php         ;test stores do not alter flags
001872  1  98                   tya
001873  1  49 C3                eor #$c3
001875  1  A8                   tay
001876  1  28                   plp
001877  1  84 rr                sty zpt+1
001879  1  08                   php         ;flags after load/store s:=ence
00187A  1  49 C3                eor #$c3
00187C  1  A8                   tay
00187D  1  C4 rr                cpy zp1+1   ;test result
00187F  1  F0 03 20 58          trap_ne
001883  1  44           
001884  1  68                   pla         ;load status
001885  1  49 30                eor_flag 0
001887  1  CD 1D 02             cmp fLDx+1  ;test flags
00188A  1  F0 03 20 58          trap_ne
00188E  1  44           
00188F  1  A9 00 48 28          set_stat 0
001893  1  AC 19 02             ldy abs1+2
001896  1  08                   php         ;test stores do not alter flags
001897  1  98                   tya
001898  1  49 C3                eor #$c3
00189A  1  A8                   tay
00189B  1  28                   plp
00189C  1  84 rr                sty zpt+2
00189E  1  08                   php         ;flags after load/store s:=ence
00189F  1  49 C3                eor #$c3
0018A1  1  A8                   tay
0018A2  1  C4 rr                cpy zp1+2   ;test result
0018A4  1  F0 03 20 58          trap_ne
0018A8  1  44           
0018A9  1  68                   pla         ;load status
0018AA  1  49 30                eor_flag 0
0018AC  1  CD 1E 02             cmp fLDx+2  ;test flags
0018AF  1  F0 03 20 58          trap_ne
0018B3  1  44           
0018B4  1  A9 00 48 28          set_stat 0
0018B8  1  AC 1A 02             ldy abs1+3
0018BB  1  08                   php         ;test stores do not alter flags
0018BC  1  98                   tya
0018BD  1  49 C3                eor #$c3
0018BF  1  A8                   tay
0018C0  1  28                   plp
0018C1  1  84 rr                sty zpt+3
0018C3  1  08                   php         ;flags after load/store s:=ence
0018C4  1  49 C3                eor #$c3
0018C6  1  A8                   tay
0018C7  1  C4 rr                cpy zp1+3   ;test result
0018C9  1  F0 03 20 58          trap_ne
0018CD  1  44           
0018CE  1  68                   pla         ;load status
0018CF  1  49 30                eor_flag 0
0018D1  1  CD 1F 02             cmp fLDx+3  ;test flags
0018D4  1  F0 03 20 58          trap_ne
0018D8  1  44           
0018D9  1               
0018D9  1  A9 FF 48 28          set_stat $ff
0018DD  1  AC 17 02             ldy abs1
0018E0  1  08                   php         ;test stores do not alter flags
0018E1  1  98                   tya
0018E2  1  49 C3                eor #$c3
0018E4  1  A8                   tay
0018E5  1  28                   plp
0018E6  1  84 rr                sty zpt
0018E8  1  08                   php         ;flags after load/store s:=ence
0018E9  1  49 C3                eor #$c3
0018EB  1  A8                   tay
0018EC  1  C5 rr                cmp zp1     ;test result
0018EE  1  F0 03 20 58          trap_ne
0018F2  1  44           
0018F3  1  68                   pla         ;load status
0018F4  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018F6  1  CD 1C 02             cmp fLDx    ;test flags
0018F9  1  F0 03 20 58          trap_ne
0018FD  1  44           
0018FE  1  A9 FF 48 28          set_stat $ff
001902  1  AC 18 02             ldy abs1+1
001905  1  08                   php         ;test stores do not alter flags
001906  1  98                   tya
001907  1  49 C3                eor #$c3
001909  1  A8                   tay
00190A  1  28                   plp
00190B  1  84 rr                sty zpt+1
00190D  1  08                   php         ;flags after load/store s:=ence
00190E  1  49 C3                eor #$c3
001910  1  A8                   tay
001911  1  C5 rr                cmp zp1+1   ;test result
001913  1  F0 03 20 58          trap_ne
001917  1  44           
001918  1  68                   pla         ;load status
001919  1  49 7D                eor_flag <~fnz ;mask bits not altered
00191B  1  CD 1D 02             cmp fLDx+1  ;test flags
00191E  1  F0 03 20 58          trap_ne
001922  1  44           
001923  1  A9 FF 48 28          set_stat $ff
001927  1  AC 19 02             ldy abs1+2
00192A  1  08                   php         ;test stores do not alter flags
00192B  1  98                   tya
00192C  1  49 C3                eor #$c3
00192E  1  A8                   tay
00192F  1  28                   plp
001930  1  84 rr                sty zpt+2
001932  1  08                   php         ;flags after load/store s:=ence
001933  1  49 C3                eor #$c3
001935  1  A8                   tay
001936  1  C5 rr                cmp zp1+2   ;test result
001938  1  F0 03 20 58          trap_ne
00193C  1  44           
00193D  1  68                   pla         ;load status
00193E  1  49 7D                eor_flag <~fnz ;mask bits not altered
001940  1  CD 1E 02             cmp fLDx+2  ;test flags
001943  1  F0 03 20 58          trap_ne
001947  1  44           
001948  1  A9 FF 48 28          set_stat $ff
00194C  1  AC 1A 02             ldy abs1+3
00194F  1  08                   php         ;test stores do not alter flags
001950  1  98                   tya
001951  1  49 C3                eor #$c3
001953  1  A8                   tay
001954  1  28                   plp
001955  1  84 rr                sty zpt+3
001957  1  08                   php         ;flags after load/store s:=ence
001958  1  49 C3                eor #$c3
00195A  1  A8                   tay
00195B  1  C5 rr                cmp zp1+3   ;test result
00195D  1  F0 03 20 58          trap_ne
001961  1  44           
001962  1  68                   pla         ;load status
001963  1  49 7D                eor_flag <~fnz ;mask bits not altered
001965  1  CD 1F 02             cmp fLDx+3  ;test flags
001968  1  F0 03 20 58          trap_ne
00196C  1  44           
00196D  1               
00196D  1               
00196D  1  A9 00 48 28          set_stat 0
001971  1  A0 C3                ldy #$c3
001973  1  08                   php
001974  1  CC 17 02             cpy abs1    ;test result
001977  1  F0 03 20 58          trap_ne
00197B  1  44           
00197C  1  68                   pla         ;load status
00197D  1  49 30                eor_flag 0
00197F  1  CD 1C 02             cmp fLDx    ;test flags
001982  1  F0 03 20 58          trap_ne
001986  1  44           
001987  1  A9 00 48 28          set_stat 0
00198B  1  A0 82                ldy #$82
00198D  1  08                   php
00198E  1  CC 18 02             cpy abs1+1  ;test result
001991  1  F0 03 20 58          trap_ne
001995  1  44           
001996  1  68                   pla         ;load status
001997  1  49 30                eor_flag 0
001999  1  CD 1D 02             cmp fLDx+1  ;test flags
00199C  1  F0 03 20 58          trap_ne
0019A0  1  44           
0019A1  1  A9 00 48 28          set_stat 0
0019A5  1  A0 41                ldy #$41
0019A7  1  08                   php
0019A8  1  CC 19 02             cpy abs1+2  ;test result
0019AB  1  F0 03 20 58          trap_ne
0019AF  1  44           
0019B0  1  68                   pla         ;load status
0019B1  1  49 30                eor_flag 0
0019B3  1  CD 1E 02             cmp fLDx+2  ;test flags
0019B6  1  F0 03 20 58          trap_ne
0019BA  1  44           
0019BB  1  A9 00 48 28          set_stat 0
0019BF  1  A0 00                ldy #0
0019C1  1  08                   php
0019C2  1  CC 1A 02             cpy abs1+3  ;test result
0019C5  1  F0 03 20 58          trap_ne
0019C9  1  44           
0019CA  1  68                   pla         ;load status
0019CB  1  49 30                eor_flag 0
0019CD  1  CD 1F 02             cmp fLDx+3  ;test flags
0019D0  1  F0 03 20 58          trap_ne
0019D4  1  44           
0019D5  1               
0019D5  1  A9 FF 48 28          set_stat $ff
0019D9  1  A0 C3                ldy #$c3
0019DB  1  08                   php
0019DC  1  CC 17 02             cpy abs1    ;test result
0019DF  1  F0 03 20 58          trap_ne
0019E3  1  44           
0019E4  1  68                   pla         ;load status
0019E5  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019E7  1  CD 1C 02             cmp fLDx    ;test flags
0019EA  1  F0 03 20 58          trap_ne
0019EE  1  44           
0019EF  1  A9 FF 48 28          set_stat $ff
0019F3  1  A0 82                ldy #$82
0019F5  1  08                   php
0019F6  1  CC 18 02             cpy abs1+1  ;test result
0019F9  1  F0 03 20 58          trap_ne
0019FD  1  44           
0019FE  1  68                   pla         ;load status
0019FF  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A01  1  CD 1D 02             cmp fLDx+1  ;test flags
001A04  1  F0 03 20 58          trap_ne
001A08  1  44           
001A09  1  A9 FF 48 28          set_stat $ff
001A0D  1  A0 41                ldy #$41
001A0F  1  08                   php
001A10  1  CC 19 02             cpy abs1+2   ;test result
001A13  1  F0 03 20 58          trap_ne
001A17  1  44           
001A18  1  68                   pla         ;load status
001A19  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A1B  1  CD 1E 02             cmp fLDx+2  ;test flags
001A1E  1  F0 03 20 58          trap_ne
001A22  1  44           
001A23  1  A9 FF 48 28          set_stat $ff
001A27  1  A0 00                ldy #0
001A29  1  08                   php
001A2A  1  CC 1A 02             cpy abs1+3  ;test result
001A2D  1  F0 03 20 58          trap_ne
001A31  1  44           
001A32  1  68                   pla         ;load status
001A33  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A35  1  CD 1F 02             cmp fLDx+3  ;test flags
001A38  1  F0 03 20 58          trap_ne
001A3C  1  44           
001A3D  1               
001A3D  1  A0 00                ldy #0
001A3F  1  A5 rr                lda zpt
001A41  1  49 C3                eor #$c3
001A43  1  C5 rr                cmp zp1
001A45  1  F0 03 20 58          trap_ne     ;store to zp   data
001A49  1  44           
001A4A  1  84 rr                sty zpt     ;clear
001A4C  1  AD 03 02             lda abst
001A4F  1  49 C3                eor #$c3
001A51  1  CD 17 02             cmp abs1
001A54  1  F0 03 20 58          trap_ne     ;store to abs   data
001A58  1  44           
001A59  1  8C 03 02             sty abst    ;clear
001A5C  1  A5 rr                lda zpt+1
001A5E  1  49 C3                eor #$c3
001A60  1  C5 rr                cmp zp1+1
001A62  1  F0 03 20 58          trap_ne     ;store to zp+1 data
001A66  1  44           
001A67  1  84 rr                sty zpt+1   ;clear
001A69  1  AD 04 02             lda abst+1
001A6C  1  49 C3                eor #$c3
001A6E  1  CD 18 02             cmp abs1+1
001A71  1  F0 03 20 58          trap_ne     ;store to abs+1 data
001A75  1  44           
001A76  1  8C 04 02             sty abst+1  ;clear
001A79  1  A5 rr                lda zpt+2
001A7B  1  49 C3                eor #$c3
001A7D  1  C5 rr                cmp zp1+2
001A7F  1  F0 03 20 58          trap_ne     ;store to zp+2 data
001A83  1  44           
001A84  1  84 rr                sty zpt+2   ;clear
001A86  1  AD 05 02             lda abst+2
001A89  1  49 C3                eor #$c3
001A8B  1  CD 19 02             cmp abs1+2
001A8E  1  F0 03 20 58          trap_ne     ;store to abs+2 data
001A92  1  44           
001A93  1  8C 05 02             sty abst+2  ;clear
001A96  1  A5 rr                lda zpt+3
001A98  1  49 C3                eor #$c3
001A9A  1  C5 rr                cmp zp1+3
001A9C  1  F0 03 20 58          trap_ne     ;store to zp+3 data
001AA0  1  44           
001AA1  1  84 rr                sty zpt+3   ;clear
001AA3  1  AD 06 02             lda abst+3
001AA6  1  49 C3                eor #$c3
001AA8  1  CD 1A 02             cmp abs1+3
001AAB  1  F0 03 20 58          trap_ne     ;store to abs+3 data
001AAF  1  44           
001AB0  1  8C 06 02             sty abst+3  ;clear
001AB3  1  AD 00 02 C9          next_test
001AB7  1  14 F0 03 20  
001ABB  1  58 44 A9 15  
001AC2  1               
001AC2  1               ; testing load / store accumulator LDA / STA all addressing modes
001AC2  1               ; LDA / STA - zp,x / abs,x
001AC2  1  A2 03                ldx #3
001AC4  1               tldax:
001AC4  1  A9 00 48 28          set_stat 0
001AC8  1  B5 rr                lda zp1,x
001ACA  1  08                   php         ;test stores do not alter flags
001ACB  1  49 C3                eor #$c3
001ACD  1  28                   plp
001ACE  1  9D 03 02             sta abst,x
001AD1  1  08                   php         ;flags after load/store s:=ence
001AD2  1  49 C3                eor #$c3
001AD4  1  DD 17 02             cmp abs1,x  ;test result
001AD7  1  F0 03 20 58          trap_ne
001ADB  1  44           
001ADC  1  68                   pla         ;load status
001ADD  1  49 30                eor_flag 0
001ADF  1  DD 1C 02             cmp fLDx,x  ;test flags
001AE2  1  F0 03 20 58          trap_ne
001AE6  1  44           
001AE7  1  CA                   dex
001AE8  1  10 DA                bpl tldax
001AEA  1               
001AEA  1  A2 03                ldx #3
001AEC  1               tldax1:
001AEC  1  A9 FF 48 28          set_stat $ff
001AF0  1  B5 rr                lda zp1,x
001AF2  1  08                   php         ;test stores do not alter flags
001AF3  1  49 C3                eor #$c3
001AF5  1  28                   plp
001AF6  1  9D 03 02             sta abst,x
001AF9  1  08                   php         ;flags after load/store s:=ence
001AFA  1  49 C3                eor #$c3
001AFC  1  DD 17 02             cmp abs1,x   ;test result
001AFF  1  F0 03 20 58          trap_ne
001B03  1  44           
001B04  1  68                   pla         ;load status
001B05  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B07  1  DD 1C 02             cmp fLDx,x  ;test flags
001B0A  1  F0 03 20 58          trap_ne
001B0E  1  44           
001B0F  1  CA                   dex
001B10  1  10 DA                bpl tldax1
001B12  1               
001B12  1  A2 03                ldx #3
001B14  1               tldax2:
001B14  1  A9 00 48 28          set_stat 0
001B18  1  BD 17 02             lda abs1,x
001B1B  1  08                   php         ;test stores do not alter flags
001B1C  1  49 C3                eor #$c3
001B1E  1  28                   plp
001B1F  1  95 rr                sta zpt,x
001B21  1  08                   php         ;flags after load/store s:=ence
001B22  1  49 C3                eor #$c3
001B24  1  D5 rr                cmp zp1,x   ;test result
001B26  1  F0 03 20 58          trap_ne
001B2A  1  44           
001B2B  1  68                   pla         ;load status
001B2C  1  49 30                eor_flag 0
001B2E  1  DD 1C 02             cmp fLDx,x  ;test flags
001B31  1  F0 03 20 58          trap_ne
001B35  1  44           
001B36  1  CA                   dex
001B37  1  10 DB                bpl tldax2
001B39  1               
001B39  1  A2 03                ldx #3
001B3B  1               tldax3:
001B3B  1  A9 FF 48 28          set_stat $ff
001B3F  1  BD 17 02             lda abs1,x
001B42  1  08                   php         ;test stores do not alter flags
001B43  1  49 C3                eor #$c3
001B45  1  28                   plp
001B46  1  95 rr                sta zpt,x
001B48  1  08                   php         ;flags after load/store s:=ence
001B49  1  49 C3                eor #$c3
001B4B  1  D5 rr                cmp zp1,x   ;test result
001B4D  1  F0 03 20 58          trap_ne
001B51  1  44           
001B52  1  68                   pla         ;load status
001B53  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B55  1  DD 1C 02             cmp fLDx,x  ;test flags
001B58  1  F0 03 20 58          trap_ne
001B5C  1  44           
001B5D  1  CA                   dex
001B5E  1  10 DB                bpl tldax3
001B60  1               
001B60  1  A2 03                ldx #3      ;testing store result
001B62  1  A0 00                ldy #0
001B64  1  B5 rr        tstax:   lda zpt,x
001B66  1  49 C3                eor #$c3
001B68  1  D5 rr                cmp zp1,x
001B6A  1  F0 03 20 58          trap_ne     ;store to zp,x data
001B6E  1  44           
001B6F  1  94 rr                sty zpt,x   ;clear
001B71  1  BD 03 02             lda abst,x
001B74  1  49 C3                eor #$c3
001B76  1  DD 17 02             cmp abs1,x
001B79  1  F0 03 20 58          trap_ne     ;store to abs,x data
001B7D  1  44           
001B7E  1  8A                   txa
001B7F  1  9D 03 02             sta abst,x  ;clear
001B82  1  CA                   dex
001B83  1  10 DF                bpl tstax
001B85  1  AD 00 02 C9          next_test
001B89  1  15 F0 03 20  
001B8D  1  58 44 A9 16  
001B94  1               
001B94  1               ; LDA / STA - (zp),y / abs,y / (zp,x)
001B94  1  A0 03                ldy #3
001B96  1               tlday:
001B96  1  A9 00 48 28          set_stat 0
001B9A  1  B1 rr                lda (ind1),y
001B9C  1  08                   php         ;test stores do not alter flags
001B9D  1  49 C3                eor #$c3
001B9F  1  28                   plp
001BA0  1  99 03 02             sta abst,y
001BA3  1  08                   php         ;flags after load/store s:=ence
001BA4  1  49 C3                eor #$c3
001BA6  1  D9 17 02             cmp abs1,y  ;test result
001BA9  1  F0 03 20 58          trap_ne
001BAD  1  44           
001BAE  1  68                   pla         ;load status
001BAF  1  49 30                eor_flag 0
001BB1  1  D9 1C 02             cmp fLDx,y  ;test flags
001BB4  1  F0 03 20 58          trap_ne
001BB8  1  44           
001BB9  1  88                   dey
001BBA  1  10 DA                bpl tlday
001BBC  1               
001BBC  1  A0 03                ldy #3
001BBE  1               tlday1:
001BBE  1  A9 FF 48 28          set_stat $ff
001BC2  1  B1 rr                lda (ind1),y
001BC4  1  08                   php         ;test stores do not alter flags
001BC5  1  49 C3                eor #$c3
001BC7  1  28                   plp
001BC8  1  99 03 02             sta abst,y
001BCB  1  08                   php         ;flags after load/store s:=ence
001BCC  1  49 C3                eor #$c3
001BCE  1  D9 17 02             cmp abs1,y  ;test result
001BD1  1  F0 03 20 58          trap_ne
001BD5  1  44           
001BD6  1  68                   pla         ;load status
001BD7  1  49 7D                eor_flag <~fnz ;mask bits not altered
001BD9  1  D9 1C 02             cmp fLDx,y  ;test flags
001BDC  1  F0 03 20 58          trap_ne
001BE0  1  44           
001BE1  1  88                   dey
001BE2  1  10 DA                bpl tlday1
001BE4  1               
001BE4  1  A0 03                ldy #3      ;testing store result
001BE6  1  A2 00                ldx #0
001BE8  1  B9 03 02     tstay:   lda abst,y
001BEB  1  49 C3                eor #$c3
001BED  1  D9 17 02             cmp abs1,y
001BF0  1  F0 03 20 58          trap_ne     ;store to abs data
001BF4  1  44           
001BF5  1  8A                   txa
001BF6  1  99 03 02             sta abst,y  ;clear
001BF9  1  88                   dey
001BFA  1  10 EC                bpl tstay
001BFC  1               
001BFC  1  A0 03                ldy #3
001BFE  1               tlday2:
001BFE  1  A9 00 48 28          set_stat 0
001C02  1  B9 17 02             lda abs1,y
001C05  1  08                   php         ;test stores do not alter flags
001C06  1  49 C3                eor #$c3
001C08  1  28                   plp
001C09  1  91 rr                sta (indt),y
001C0B  1  08                   php         ;flags after load/store s:=ence
001C0C  1  49 C3                eor #$c3
001C0E  1  D1 rr                cmp (ind1),y    ;test result
001C10  1  F0 03 20 58          trap_ne
001C14  1  44           
001C15  1  68                   pla         ;load status
001C16  1  49 30                eor_flag 0
001C18  1  D9 1C 02             cmp fLDx,y  ;test flags
001C1B  1  F0 03 20 58          trap_ne
001C1F  1  44           
001C20  1  88                   dey
001C21  1  10 DB                bpl tlday2
001C23  1               
001C23  1  A0 03                ldy #3
001C25  1               tlday3:
001C25  1  A9 FF 48 28          set_stat $ff
001C29  1  B9 17 02             lda abs1,y
001C2C  1  08                   php         ;test stores do not alter flags
001C2D  1  49 C3                eor #$c3
001C2F  1  28                   plp
001C30  1  91 rr                sta (indt),y
001C32  1  08                   php         ;flags after load/store s:=ence
001C33  1  49 C3                eor #$c3
001C35  1  D1 rr                cmp (ind1),y   ;test result
001C37  1  F0 03 20 58          trap_ne
001C3B  1  44           
001C3C  1  68                   pla         ;load status
001C3D  1  49 7D                eor_flag <~fnz ;mask bits not altered
001C3F  1  D9 1C 02             cmp fLDx,y  ;test flags
001C42  1  F0 03 20 58          trap_ne
001C46  1  44           
001C47  1  88                   dey
001C48  1  10 DB                bpl tlday3
001C4A  1               
001C4A  1  A0 03                ldy #3      ;testing store result
001C4C  1  A2 00                ldx #0
001C4E  1  B9 03 02     tstay1:  lda abst,y
001C51  1  49 C3                eor #$c3
001C53  1  D9 17 02             cmp abs1,y
001C56  1  F0 03 20 58          trap_ne     ;store to abs data
001C5A  1  44           
001C5B  1  8A                   txa
001C5C  1  99 03 02             sta abst,y  ;clear
001C5F  1  88                   dey
001C60  1  10 EC                bpl tstay1
001C62  1               
001C62  1  A2 06                ldx #6
001C64  1  A0 03                ldy #3
001C66  1               tldax4:
001C66  1  A9 00 48 28          set_stat 0
001C6A  1  A1 rr                lda (ind1,x)
001C6C  1  08                   php         ;test stores do not alter flags
001C6D  1  49 C3                eor #$c3
001C6F  1  28                   plp
001C70  1  81 rr                sta (indt,x)
001C72  1  08                   php         ;flags after load/store s:=ence
001C73  1  49 C3                eor #$c3
001C75  1  D9 17 02             cmp abs1,y  ;test result
001C78  1  F0 03 20 58          trap_ne
001C7C  1  44           
001C7D  1  68                   pla         ;load status
001C7E  1  49 30                eor_flag 0
001C80  1  D9 1C 02             cmp fLDx,y  ;test flags
001C83  1  F0 03 20 58          trap_ne
001C87  1  44           
001C88  1  CA                   dex
001C89  1  CA                   dex
001C8A  1  88                   dey
001C8B  1  10 D9                bpl tldax4
001C8D  1               
001C8D  1  A2 06                ldx #6
001C8F  1  A0 03                ldy #3
001C91  1               tldax5:
001C91  1  A9 FF 48 28          set_stat $ff
001C95  1  A1 rr                lda (ind1,x)
001C97  1  08                   php         ;test stores do not alter flags
001C98  1  49 C3                eor #$c3
001C9A  1  28                   plp
001C9B  1  81 rr                sta (indt,x)
001C9D  1  08                   php         ;flags after load/store s:=ence
001C9E  1  49 C3                eor #$c3
001CA0  1  D9 17 02             cmp abs1,y  ;test result
001CA3  1  F0 03 20 58          trap_ne
001CA7  1  44           
001CA8  1  68                   pla         ;load status
001CA9  1  49 7D                eor_flag <~fnz ;mask bits not altered
001CAB  1  D9 1C 02             cmp fLDx,y  ;test flags
001CAE  1  F0 03 20 58          trap_ne
001CB2  1  44           
001CB3  1  CA                   dex
001CB4  1  CA                   dex
001CB5  1  88                   dey
001CB6  1  10 D9                bpl tldax5
001CB8  1               
001CB8  1  A0 03                ldy #3      ;testing store result
001CBA  1  A2 00                ldx #0
001CBC  1  B9 03 02     tstay2:  lda abst,y
001CBF  1  49 C3                eor #$c3
001CC1  1  D9 17 02             cmp abs1,y
001CC4  1  F0 03 20 58          trap_ne     ;store to abs data
001CC8  1  44           
001CC9  1  8A                   txa
001CCA  1  99 03 02             sta abst,y  ;clear
001CCD  1  88                   dey
001CCE  1  10 EC                bpl tstay2
001CD0  1  AD 00 02 C9          next_test
001CD4  1  16 F0 03 20  
001CD8  1  58 44 A9 17  
001CDF  1               
001CDF  1               ; indexed wraparound test (only zp should wrap)
001CDF  1  A2 FD                ldx #3+$fa
001CE1  1  B5 rr        tldax6:  lda <(zp1-$fa),x   ;wrap on indexed zp
001CE3  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
001CE6  1  CA                   dex
001CE7  1  E0 FA                cpx #$fa
001CE9  1  B0 F6                bcs tldax6
001CEB  1  A2 FD                ldx #3+$fa
001CED  1  BD 1D 01     tldax7:  lda abs1-$fa,x      ;no wrap on indexed abs
001CF0  1  95 rr                sta <(zpt-$fa),x
001CF2  1  CA                   dex
001CF3  1  E0 FA                cpx #$fa
001CF5  1  B0 F6                bcs tldax7
001CF7  1               
001CF7  1  A2 03                ldx #3      ;testing wraparound result
001CF9  1  A0 00                ldy #0
001CFB  1  B5 rr        tstax1:  lda zpt,x
001CFD  1  D5 rr                cmp zp1,x
001CFF  1  F0 03 20 58          trap_ne     ;store to zp,x data
001D03  1  44           
001D04  1  94 rr                sty zpt,x   ;clear
001D06  1  BD 03 02             lda abst,x
001D09  1  DD 17 02             cmp abs1,x
001D0C  1  F0 03 20 58          trap_ne     ;store to abs,x data
001D10  1  44           
001D11  1  8A                   txa
001D12  1  9D 03 02             sta abst,x  ;clear
001D15  1  CA                   dex
001D16  1  10 E3                bpl tstax1
001D18  1               
001D18  1  A0 FB                ldy #3+$f8
001D1A  1  A2 FE                ldx #6+$f8
001D1C  1  A1 rr        tlday4:  lda (<(ind1-$f8),x) ;wrap on indexed zp indirect
001D1E  1  99 0B 01             sta abst-$f8,y
001D21  1  CA                   dex
001D22  1  CA                   dex
001D23  1  88                   dey
001D24  1  C0 F8                cpy #$f8
001D26  1  B0 F4                bcs tlday4
001D28  1  A0 03                ldy #3      ;testing wraparound result
001D2A  1  A2 00                ldx #0
001D2C  1  B9 03 02     tstay4:  lda abst,y
001D2F  1  D9 17 02             cmp abs1,y
001D32  1  F0 03 20 58          trap_ne     ;store to abs data
001D36  1  44           
001D37  1  8A                   txa
001D38  1  99 03 02             sta abst,y  ;clear
001D3B  1  88                   dey
001D3C  1  10 EE                bpl tstay4
001D3E  1               
001D3E  1  A0 FB                ldy #3+$f8
001D40  1  B9 1F 01     tlday5:  lda abs1-$f8,y  ;no wrap on indexed abs
001D43  1  91 rr                sta (inwt),y
001D45  1  88                   dey
001D46  1  C0 F8                cpy #$f8
001D48  1  B0 F6                bcs tlday5
001D4A  1  A0 03                ldy #3      ;testing wraparound result
001D4C  1  A2 00                ldx #0
001D4E  1  B9 03 02     tstay5:  lda abst,y
001D51  1  D9 17 02             cmp abs1,y
001D54  1  F0 03 20 58          trap_ne     ;store to abs data
001D58  1  44           
001D59  1  8A                   txa
001D5A  1  99 03 02             sta abst,y  ;clear
001D5D  1  88                   dey
001D5E  1  10 EE                bpl tstay5
001D60  1               
001D60  1  A0 FB                ldy #3+$f8
001D62  1  A2 FE                ldx #6+$f8
001D64  1  B1 rr        tlday6:  lda (inw1),y    ;no wrap on zp indirect indexed
001D66  1  81 rr                sta (<(indt-$f8),x)
001D68  1  CA                   dex
001D69  1  CA                   dex
001D6A  1  88                   dey
001D6B  1  C0 F8                cpy #$f8
001D6D  1  B0 F5                bcs tlday6
001D6F  1  A0 03                ldy #3      ;testing wraparound result
001D71  1  A2 00                ldx #0
001D73  1  B9 03 02     tstay6:  lda abst,y
001D76  1  D9 17 02             cmp abs1,y
001D79  1  F0 03 20 58          trap_ne     ;store to abs data
001D7D  1  44           
001D7E  1  8A                   txa
001D7F  1  99 03 02             sta abst,y  ;clear
001D82  1  88                   dey
001D83  1  10 EE                bpl tstay6
001D85  1  AD 00 02 C9          next_test
001D89  1  17 F0 03 20  
001D8D  1  58 44 A9 18  
001D94  1               
001D94  1               ; LDA / STA - zp / abs / #
001D94  1  A9 00 48 28          set_stat 0
001D98  1  A5 rr                lda zp1
001D9A  1  08                   php         ;test stores do not alter flags
001D9B  1  49 C3                eor #$c3
001D9D  1  28                   plp
001D9E  1  8D 03 02             sta abst
001DA1  1  08                   php         ;flags after load/store s:=ence
001DA2  1  49 C3                eor #$c3
001DA4  1  C9 C3                cmp #$c3    ;test result
001DA6  1  F0 03 20 58          trap_ne
001DAA  1  44           
001DAB  1  68                   pla         ;load status
001DAC  1  49 30                eor_flag 0
001DAE  1  CD 1C 02             cmp fLDx    ;test flags
001DB1  1  F0 03 20 58          trap_ne
001DB5  1  44           
001DB6  1  A9 00 48 28          set_stat 0
001DBA  1  A5 rr                lda zp1+1
001DBC  1  08                   php         ;test stores do not alter flags
001DBD  1  49 C3                eor #$c3
001DBF  1  28                   plp
001DC0  1  8D 04 02             sta abst+1
001DC3  1  08                   php         ;flags after load/store s:=ence
001DC4  1  49 C3                eor #$c3
001DC6  1  C9 82                cmp #$82    ;test result
001DC8  1  F0 03 20 58          trap_ne
001DCC  1  44           
001DCD  1  68                   pla         ;load status
001DCE  1  49 30                eor_flag 0
001DD0  1  CD 1D 02             cmp fLDx+1  ;test flags
001DD3  1  F0 03 20 58          trap_ne
001DD7  1  44           
001DD8  1  A9 00 48 28          set_stat 0
001DDC  1  A5 rr                lda zp1+2
001DDE  1  08                   php         ;test stores do not alter flags
001DDF  1  49 C3                eor #$c3
001DE1  1  28                   plp
001DE2  1  8D 05 02             sta abst+2
001DE5  1  08                   php         ;flags after load/store s:=ence
001DE6  1  49 C3                eor #$c3
001DE8  1  C9 41                cmp #$41    ;test result
001DEA  1  F0 03 20 58          trap_ne
001DEE  1  44           
001DEF  1  68                   pla         ;load status
001DF0  1  49 30                eor_flag 0
001DF2  1  CD 1E 02             cmp fLDx+2  ;test flags
001DF5  1  F0 03 20 58          trap_ne
001DF9  1  44           
001DFA  1  A9 00 48 28          set_stat 0
001DFE  1  A5 rr                lda zp1+3
001E00  1  08                   php         ;test stores do not alter flags
001E01  1  49 C3                eor #$c3
001E03  1  28                   plp
001E04  1  8D 06 02             sta abst+3
001E07  1  08                   php         ;flags after load/store s:=ence
001E08  1  49 C3                eor #$c3
001E0A  1  C9 00                cmp #0      ;test result
001E0C  1  F0 03 20 58          trap_ne
001E10  1  44           
001E11  1  68                   pla         ;load status
001E12  1  49 30                eor_flag 0
001E14  1  CD 1F 02             cmp fLDx+3  ;test flags
001E17  1  F0 03 20 58          trap_ne
001E1B  1  44           
001E1C  1  A9 FF 48 28          set_stat $ff
001E20  1  A5 rr                lda zp1
001E22  1  08                   php         ;test stores do not alter flags
001E23  1  49 C3                eor #$c3
001E25  1  28                   plp
001E26  1  8D 03 02             sta abst
001E29  1  08                   php         ;flags after load/store s:=ence
001E2A  1  49 C3                eor #$c3
001E2C  1  C9 C3                cmp #$c3    ;test result
001E2E  1  F0 03 20 58          trap_ne
001E32  1  44           
001E33  1  68                   pla         ;load status
001E34  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E36  1  CD 1C 02             cmp fLDx    ;test flags
001E39  1  F0 03 20 58          trap_ne
001E3D  1  44           
001E3E  1  A9 FF 48 28          set_stat $ff
001E42  1  A5 rr                lda zp1+1
001E44  1  08                   php         ;test stores do not alter flags
001E45  1  49 C3                eor #$c3
001E47  1  28                   plp
001E48  1  8D 04 02             sta abst+1
001E4B  1  08                   php         ;flags after load/store s:=ence
001E4C  1  49 C3                eor #$c3
001E4E  1  C9 82                cmp #$82    ;test result
001E50  1  F0 03 20 58          trap_ne
001E54  1  44           
001E55  1  68                   pla         ;load status
001E56  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E58  1  CD 1D 02             cmp fLDx+1  ;test flags
001E5B  1  F0 03 20 58          trap_ne
001E5F  1  44           
001E60  1  A9 FF 48 28          set_stat $ff
001E64  1  A5 rr                lda zp1+2
001E66  1  08                   php         ;test stores do not alter flags
001E67  1  49 C3                eor #$c3
001E69  1  28                   plp
001E6A  1  8D 05 02             sta abst+2
001E6D  1  08                   php         ;flags after load/store s:=ence
001E6E  1  49 C3                eor #$c3
001E70  1  C9 41                cmp #$41    ;test result
001E72  1  F0 03 20 58          trap_ne
001E76  1  44           
001E77  1  68                   pla         ;load status
001E78  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E7A  1  CD 1E 02             cmp fLDx+2  ;test flags
001E7D  1  F0 03 20 58          trap_ne
001E81  1  44           
001E82  1  A9 FF 48 28          set_stat $ff
001E86  1  A5 rr                lda zp1+3
001E88  1  08                   php         ;test stores do not alter flags
001E89  1  49 C3                eor #$c3
001E8B  1  28                   plp
001E8C  1  8D 06 02             sta abst+3
001E8F  1  08                   php         ;flags after load/store s:=ence
001E90  1  49 C3                eor #$c3
001E92  1  C9 00                cmp #0      ;test result
001E94  1  F0 03 20 58          trap_ne
001E98  1  44           
001E99  1  68                   pla         ;load status
001E9A  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E9C  1  CD 1F 02             cmp fLDx+3  ;test flags
001E9F  1  F0 03 20 58          trap_ne
001EA3  1  44           
001EA4  1  A9 00 48 28          set_stat 0
001EA8  1  AD 17 02             lda abs1
001EAB  1  08                   php         ;test stores do not alter flags
001EAC  1  49 C3                eor #$c3
001EAE  1  28                   plp
001EAF  1  85 rr                sta zpt
001EB1  1  08                   php         ;flags after load/store s:=ence
001EB2  1  49 C3                eor #$c3
001EB4  1  C5 rr                cmp zp1     ;test result
001EB6  1  F0 03 20 58          trap_ne
001EBA  1  44           
001EBB  1  68                   pla         ;load status
001EBC  1  49 30                eor_flag 0
001EBE  1  CD 1C 02             cmp fLDx    ;test flags
001EC1  1  F0 03 20 58          trap_ne
001EC5  1  44           
001EC6  1  A9 00 48 28          set_stat 0
001ECA  1  AD 18 02             lda abs1+1
001ECD  1  08                   php         ;test stores do not alter flags
001ECE  1  49 C3                eor #$c3
001ED0  1  28                   plp
001ED1  1  85 rr                sta zpt+1
001ED3  1  08                   php         ;flags after load/store s:=ence
001ED4  1  49 C3                eor #$c3
001ED6  1  C5 rr                cmp zp1+1   ;test result
001ED8  1  F0 03 20 58          trap_ne
001EDC  1  44           
001EDD  1  68                   pla         ;load status
001EDE  1  49 30                eor_flag 0
001EE0  1  CD 1D 02             cmp fLDx+1  ;test flags
001EE3  1  F0 03 20 58          trap_ne
001EE7  1  44           
001EE8  1  A9 00 48 28          set_stat 0
001EEC  1  AD 19 02             lda abs1+2
001EEF  1  08                   php         ;test stores do not alter flags
001EF0  1  49 C3                eor #$c3
001EF2  1  28                   plp
001EF3  1  85 rr                sta zpt+2
001EF5  1  08                   php         ;flags after load/store s:=ence
001EF6  1  49 C3                eor #$c3
001EF8  1  C5 rr                cmp zp1+2   ;test result
001EFA  1  F0 03 20 58          trap_ne
001EFE  1  44           
001EFF  1  68                   pla         ;load status
001F00  1  49 30                eor_flag 0
001F02  1  CD 1E 02             cmp fLDx+2  ;test flags
001F05  1  F0 03 20 58          trap_ne
001F09  1  44           
001F0A  1  A9 00 48 28          set_stat 0
001F0E  1  AD 1A 02             lda abs1+3
001F11  1  08                   php         ;test stores do not alter flags
001F12  1  49 C3                eor #$c3
001F14  1  28                   plp
001F15  1  85 rr                sta zpt+3
001F17  1  08                   php         ;flags after load/store s:=ence
001F18  1  49 C3                eor #$c3
001F1A  1  C5 rr                cmp zp1+3   ;test result
001F1C  1  F0 03 20 58          trap_ne
001F20  1  44           
001F21  1  68                   pla         ;load status
001F22  1  49 30                eor_flag 0
001F24  1  CD 1F 02             cmp fLDx+3  ;test flags
001F27  1  F0 03 20 58          trap_ne
001F2B  1  44           
001F2C  1  A9 FF 48 28          set_stat $ff
001F30  1  AD 17 02             lda abs1
001F33  1  08                   php         ;test stores do not alter flags
001F34  1  49 C3                eor #$c3
001F36  1  28                   plp
001F37  1  85 rr                sta zpt
001F39  1  08                   php         ;flags after load/store s:=ence
001F3A  1  49 C3                eor #$c3
001F3C  1  C5 rr                cmp zp1     ;test result
001F3E  1  F0 03 20 58          trap_ne
001F42  1  44           
001F43  1  68                   pla         ;load status
001F44  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F46  1  CD 1C 02             cmp fLDx    ;test flags
001F49  1  F0 03 20 58          trap_ne
001F4D  1  44           
001F4E  1  A9 FF 48 28          set_stat $ff
001F52  1  AD 18 02             lda abs1+1
001F55  1  08                   php         ;test stores do not alter flags
001F56  1  49 C3                eor #$c3
001F58  1  28                   plp
001F59  1  85 rr                sta zpt+1
001F5B  1  08                   php         ;flags after load/store s:=ence
001F5C  1  49 C3                eor #$c3
001F5E  1  C5 rr                cmp zp1+1   ;test result
001F60  1  F0 03 20 58          trap_ne
001F64  1  44           
001F65  1  68                   pla         ;load status
001F66  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F68  1  CD 1D 02             cmp fLDx+1  ;test flags
001F6B  1  F0 03 20 58          trap_ne
001F6F  1  44           
001F70  1  A9 FF 48 28          set_stat $ff
001F74  1  AD 19 02             lda abs1+2
001F77  1  08                   php         ;test stores do not alter flags
001F78  1  49 C3                eor #$c3
001F7A  1  28                   plp
001F7B  1  85 rr                sta zpt+2
001F7D  1  08                   php         ;flags after load/store s:=ence
001F7E  1  49 C3                eor #$c3
001F80  1  C5 rr                cmp zp1+2   ;test result
001F82  1  F0 03 20 58          trap_ne
001F86  1  44           
001F87  1  68                   pla         ;load status
001F88  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F8A  1  CD 1E 02             cmp fLDx+2  ;test flags
001F8D  1  F0 03 20 58          trap_ne
001F91  1  44           
001F92  1  A9 FF 48 28          set_stat $ff
001F96  1  AD 1A 02             lda abs1+3
001F99  1  08                   php         ;test stores do not alter flags
001F9A  1  49 C3                eor #$c3
001F9C  1  28                   plp
001F9D  1  85 rr                sta zpt+3
001F9F  1  08                   php         ;flags after load/store s:=ence
001FA0  1  49 C3                eor #$c3
001FA2  1  C5 rr                cmp zp1+3   ;test result
001FA4  1  F0 03 20 58          trap_ne
001FA8  1  44           
001FA9  1  68                   pla         ;load status
001FAA  1  49 7D                eor_flag <~fnz ;mask bits not altered
001FAC  1  CD 1F 02             cmp fLDx+3  ;test flags
001FAF  1  F0 03 20 58          trap_ne
001FB3  1  44           
001FB4  1  A9 00 48 28          set_stat 0
001FB8  1  A9 C3                lda #$c3
001FBA  1  08                   php
001FBB  1  CD 17 02             cmp abs1    ;test result
001FBE  1  F0 03 20 58          trap_ne
001FC2  1  44           
001FC3  1  68                   pla         ;load status
001FC4  1  49 30                eor_flag 0
001FC6  1  CD 1C 02             cmp fLDx    ;test flags
001FC9  1  F0 03 20 58          trap_ne
001FCD  1  44           
001FCE  1  A9 00 48 28          set_stat 0
001FD2  1  A9 82                lda #$82
001FD4  1  08                   php
001FD5  1  CD 18 02             cmp abs1+1  ;test result
001FD8  1  F0 03 20 58          trap_ne
001FDC  1  44           
001FDD  1  68                   pla         ;load status
001FDE  1  49 30                eor_flag 0
001FE0  1  CD 1D 02             cmp fLDx+1  ;test flags
001FE3  1  F0 03 20 58          trap_ne
001FE7  1  44           
001FE8  1  A9 00 48 28          set_stat 0
001FEC  1  A9 41                lda #$41
001FEE  1  08                   php
001FEF  1  CD 19 02             cmp abs1+2  ;test result
001FF2  1  F0 03 20 58          trap_ne
001FF6  1  44           
001FF7  1  68                   pla         ;load status
001FF8  1  49 30                eor_flag 0
001FFA  1  CD 1E 02             cmp fLDx+2  ;test flags
001FFD  1  F0 03 20 58          trap_ne
002001  1  44           
002002  1  A9 00 48 28          set_stat 0
002006  1  A9 00                lda #0
002008  1  08                   php
002009  1  CD 1A 02             cmp abs1+3  ;test result
00200C  1  F0 03 20 58          trap_ne
002010  1  44           
002011  1  68                   pla         ;load status
002012  1  49 30                eor_flag 0
002014  1  CD 1F 02             cmp fLDx+3  ;test flags
002017  1  F0 03 20 58          trap_ne
00201B  1  44           
00201C  1               
00201C  1  A9 FF 48 28          set_stat $ff
002020  1  A9 C3                lda #$c3
002022  1  08                   php
002023  1  CD 17 02             cmp abs1    ;test result
002026  1  F0 03 20 58          trap_ne
00202A  1  44           
00202B  1  68                   pla         ;load status
00202C  1  49 7D                eor_flag <~fnz ;mask bits not altered
00202E  1  CD 1C 02             cmp fLDx    ;test flags
002031  1  F0 03 20 58          trap_ne
002035  1  44           
002036  1  A9 FF 48 28          set_stat $ff
00203A  1  A9 82                lda #$82
00203C  1  08                   php
00203D  1  CD 18 02             cmp abs1+1  ;test result
002040  1  F0 03 20 58          trap_ne
002044  1  44           
002045  1  68                   pla         ;load status
002046  1  49 7D                eor_flag <~fnz ;mask bits not altered
002048  1  CD 1D 02             cmp fLDx+1  ;test flags
00204B  1  F0 03 20 58          trap_ne
00204F  1  44           
002050  1  A9 FF 48 28          set_stat $ff
002054  1  A9 41                lda #$41
002056  1  08                   php
002057  1  CD 19 02             cmp abs1+2  ;test result
00205A  1  F0 03 20 58          trap_ne
00205E  1  44           
00205F  1  68                   pla         ;load status
002060  1  49 7D                eor_flag <~fnz ;mask bits not altered
002062  1  CD 1E 02             cmp fLDx+2  ;test flags
002065  1  F0 03 20 58          trap_ne
002069  1  44           
00206A  1  A9 FF 48 28          set_stat $ff
00206E  1  A9 00                lda #0
002070  1  08                   php
002071  1  CD 1A 02             cmp abs1+3  ;test result
002074  1  F0 03 20 58          trap_ne
002078  1  44           
002079  1  68                   pla         ;load status
00207A  1  49 7D                eor_flag <~fnz ;mask bits not altered
00207C  1  CD 1F 02             cmp fLDx+3  ;test flags
00207F  1  F0 03 20 58          trap_ne
002083  1  44           
002084  1               
002084  1  A2 00                ldx #0
002086  1  A5 rr                lda zpt
002088  1  49 C3                eor #$c3
00208A  1  C5 rr                cmp zp1
00208C  1  F0 03 20 58          trap_ne     ;store to zp data
002090  1  44           
002091  1  86 rr                stx zpt     ;clear
002093  1  AD 03 02             lda abst
002096  1  49 C3                eor #$c3
002098  1  CD 17 02             cmp abs1
00209B  1  F0 03 20 58          trap_ne     ;store to abs data
00209F  1  44           
0020A0  1  8E 03 02             stx abst    ;clear
0020A3  1  A5 rr                lda zpt+1
0020A5  1  49 C3                eor #$c3
0020A7  1  C5 rr                cmp zp1+1
0020A9  1  F0 03 20 58          trap_ne     ;store to zp data
0020AD  1  44           
0020AE  1  86 rr                stx zpt+1   ;clear
0020B0  1  AD 04 02             lda abst+1
0020B3  1  49 C3                eor #$c3
0020B5  1  CD 18 02             cmp abs1+1
0020B8  1  F0 03 20 58          trap_ne     ;store to abs data
0020BC  1  44           
0020BD  1  8E 04 02             stx abst+1  ;clear
0020C0  1  A5 rr                lda zpt+2
0020C2  1  49 C3                eor #$c3
0020C4  1  C5 rr                cmp zp1+2
0020C6  1  F0 03 20 58          trap_ne     ;store to zp data
0020CA  1  44           
0020CB  1  86 rr                stx zpt+2   ;clear
0020CD  1  AD 05 02             lda abst+2
0020D0  1  49 C3                eor #$c3
0020D2  1  CD 19 02             cmp abs1+2
0020D5  1  F0 03 20 58          trap_ne     ;store to abs data
0020D9  1  44           
0020DA  1  8E 05 02             stx abst+2  ;clear
0020DD  1  A5 rr                lda zpt+3
0020DF  1  49 C3                eor #$c3
0020E1  1  C5 rr                cmp zp1+3
0020E3  1  F0 03 20 58          trap_ne     ;store to zp data
0020E7  1  44           
0020E8  1  86 rr                stx zpt+3   ;clear
0020EA  1  AD 06 02             lda abst+3
0020ED  1  49 C3                eor #$c3
0020EF  1  CD 1A 02             cmp abs1+3
0020F2  1  F0 03 20 58          trap_ne     ;store to abs data
0020F6  1  44           
0020F7  1  8E 06 02             stx abst+3  ;clear
0020FA  1  AD 00 02 C9          next_test
0020FE  1  18 F0 03 20  
002102  1  58 44 A9 19  
002109  1               
002109  1               ; testing bit test & compares BIT CPX CPY CMP all addressing modes
002109  1               ; BIT - zp / abs
002109  1  A9 00 48 A9          set_a $ff,0
00210D  1  FF 28        
00210F  1  24 rr                bit zp1+3   ;00 - should set Z / clear  NV
002111  1  08 C9 FF F0          tst_a $ff,fz
002115  1  03 20 58 44  
002119  1  68 48 C9 32  
002123  1  A9 00 48 A9          set_a 1,0
002127  1  01 28        
002129  1  24 rr                bit zp1+2   ;41 - should set V (M6) / clear NZ
00212B  1  08 C9 01 F0          tst_a 1,fv
00212F  1  03 20 58 44  
002133  1  68 48 C9 70  
00213D  1  A9 00 48 A9          set_a 1,0
002141  1  01 28        
002143  1  24 rr                bit zp1+1   ;82 - should set N (M7) & Z / clear V
002145  1  08 C9 01 F0          tst_a 1,fnz
002149  1  03 20 58 44  
00214D  1  68 48 C9 B2  
002157  1  A9 00 48 A9          set_a 1,0
00215B  1  01 28        
00215D  1  24 rr                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
00215F  1  08 C9 01 F0          tst_a 1,fnv
002163  1  03 20 58 44  
002167  1  68 48 C9 F0  
002171  1               
002171  1  A9 FF 48 A9          set_a $ff,$ff
002175  1  FF 28        
002177  1  24 rr                bit zp1+3   ;00 - should set Z / clear  NV
002179  1  08 C9 FF F0          tst_a $ff,~fnv
00217D  1  03 20 58 44  
002181  1  68 48 C9 3F  
00218B  1  A9 FF 48 A9          set_a 1,$ff
00218F  1  01 28        
002191  1  24 rr                bit zp1+2   ;41 - should set V (M6) / clear NZ
002193  1  08 C9 01 F0          tst_a 1,~fnz
002197  1  03 20 58 44  
00219B  1  68 48 C9 7D  
0021A5  1  A9 FF 48 A9          set_a 1,$ff
0021A9  1  01 28        
0021AB  1  24 rr                bit zp1+1   ;82 - should set N (M7) & Z / clear V
0021AD  1  08 C9 01 F0          tst_a 1,~fv
0021B1  1  03 20 58 44  
0021B5  1  68 48 C9 BF  
0021BF  1  A9 FF 48 A9          set_a 1,$ff
0021C3  1  01 28        
0021C5  1  24 rr                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
0021C7  1  08 C9 01 F0          tst_a 1,~fz
0021CB  1  03 20 58 44  
0021CF  1  68 48 C9 FD  
0021D9  1               
0021D9  1  A9 00 48 A9          set_a $ff,0
0021DD  1  FF 28        
0021DF  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
0021E2  1  08 C9 FF F0          tst_a $ff,fz
0021E6  1  03 20 58 44  
0021EA  1  68 48 C9 32  
0021F4  1  A9 00 48 A9          set_a 1,0
0021F8  1  01 28        
0021FA  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
0021FD  1  08 C9 01 F0          tst_a 1,fv
002201  1  03 20 58 44  
002205  1  68 48 C9 70  
00220F  1  A9 00 48 A9          set_a 1,0
002213  1  01 28        
002215  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
002218  1  08 C9 01 F0          tst_a 1,fnz
00221C  1  03 20 58 44  
002220  1  68 48 C9 B2  
00222A  1  A9 00 48 A9          set_a 1,0
00222E  1  01 28        
002230  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
002233  1  08 C9 01 F0          tst_a 1,fnv
002237  1  03 20 58 44  
00223B  1  68 48 C9 F0  
002245  1               
002245  1  A9 FF 48 A9          set_a $ff,$ff
002249  1  FF 28        
00224B  1  2C 1A 02             bit abs1+3  ;00 - should set Z / clear  NV
00224E  1  08 C9 FF F0          tst_a $ff,~fnv
002252  1  03 20 58 44  
002256  1  68 48 C9 3F  
002260  1  A9 FF 48 A9          set_a 1,$ff
002264  1  01 28        
002266  1  2C 19 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
002269  1  08 C9 01 F0          tst_a 1,~fnz
00226D  1  03 20 58 44  
002271  1  68 48 C9 7D  
00227B  1  A9 FF 48 A9          set_a 1,$ff
00227F  1  01 28        
002281  1  2C 18 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
002284  1  08 C9 01 F0          tst_a 1,~fv
002288  1  03 20 58 44  
00228C  1  68 48 C9 BF  
002296  1  A9 FF 48 A9          set_a 1,$ff
00229A  1  01 28        
00229C  1  2C 17 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
00229F  1  08 C9 01 F0          tst_a 1,~fz
0022A3  1  03 20 58 44  
0022A7  1  68 48 C9 FD  
0022B1  1  AD 00 02 C9          next_test
0022B5  1  19 F0 03 20  
0022B9  1  58 44 A9 1A  
0022C0  1               
0022C0  1               ; CPX - zp / abs / #
0022C0  1  A9 00 48 A2          set_x $80,0
0022C4  1  80 28        
0022C6  1  E4 rr                cpx zp7f
0022C8  1  08 68 48 C9          tst_stat fc
0022CC  1  31 F0 03 20  
0022D0  1  58 44 28     
0022D3  1  CA                   dex
0022D4  1  E4 rr                cpx zp7f
0022D6  1  08 68 48 C9          tst_stat fzc
0022DA  1  33 F0 03 20  
0022DE  1  58 44 28     
0022E1  1  CA                   dex
0022E2  1  E4 rr                cpx zp7f
0022E4  1  08 E0 7E F0          tst_x $7e,fn
0022E8  1  03 20 58 44  
0022EC  1  68 48 C9 B0  
0022F6  1  A9 FF 48 A2          set_x $80,$ff
0022FA  1  80 28        
0022FC  1  E4 rr                cpx zp7f
0022FE  1  08 68 48 C9          tst_stat ~fnz
002302  1  7D F0 03 20  
002306  1  58 44 28     
002309  1  CA                   dex
00230A  1  E4 rr                cpx zp7f
00230C  1  08 68 48 C9          tst_stat ~fn
002310  1  7F F0 03 20  
002314  1  58 44 28     
002317  1  CA                   dex
002318  1  E4 rr                cpx zp7f
00231A  1  08 E0 7E F0          tst_x $7e,~fzc
00231E  1  03 20 58 44  
002322  1  68 48 C9 FC  
00232C  1               
00232C  1  A9 00 48 A2          set_x $80,0
002330  1  80 28        
002332  1  EC 1B 02             cpx abs7f
002335  1  08 68 48 C9          tst_stat fc
002339  1  31 F0 03 20  
00233D  1  58 44 28     
002340  1  CA                   dex
002341  1  EC 1B 02             cpx abs7f
002344  1  08 68 48 C9          tst_stat fzc
002348  1  33 F0 03 20  
00234C  1  58 44 28     
00234F  1  CA                   dex
002350  1  EC 1B 02             cpx abs7f
002353  1  08 E0 7E F0          tst_x $7e,fn
002357  1  03 20 58 44  
00235B  1  68 48 C9 B0  
002365  1  A9 FF 48 A2          set_x $80,$ff
002369  1  80 28        
00236B  1  EC 1B 02             cpx abs7f
00236E  1  08 68 48 C9          tst_stat ~fnz
002372  1  7D F0 03 20  
002376  1  58 44 28     
002379  1  CA                   dex
00237A  1  EC 1B 02             cpx abs7f
00237D  1  08 68 48 C9          tst_stat ~fn
002381  1  7F F0 03 20  
002385  1  58 44 28     
002388  1  CA                   dex
002389  1  EC 1B 02             cpx abs7f
00238C  1  08 E0 7E F0          tst_x $7e,~fzc
002390  1  03 20 58 44  
002394  1  68 48 C9 FC  
00239E  1               
00239E  1  A9 00 48 A2          set_x $80,0
0023A2  1  80 28        
0023A4  1  E0 7F                cpx #$7f
0023A6  1  08 68 48 C9          tst_stat fc
0023AA  1  31 F0 03 20  
0023AE  1  58 44 28     
0023B1  1  CA                   dex
0023B2  1  E0 7F                cpx #$7f
0023B4  1  08 68 48 C9          tst_stat fzc
0023B8  1  33 F0 03 20  
0023BC  1  58 44 28     
0023BF  1  CA                   dex
0023C0  1  E0 7F                cpx #$7f
0023C2  1  08 E0 7E F0          tst_x $7e,fn
0023C6  1  03 20 58 44  
0023CA  1  68 48 C9 B0  
0023D4  1  A9 FF 48 A2          set_x $80,$ff
0023D8  1  80 28        
0023DA  1  E0 7F                cpx #$7f
0023DC  1  08 68 48 C9          tst_stat ~fnz
0023E0  1  7D F0 03 20  
0023E4  1  58 44 28     
0023E7  1  CA                   dex
0023E8  1  E0 7F                cpx #$7f
0023EA  1  08 68 48 C9          tst_stat ~fn
0023EE  1  7F F0 03 20  
0023F2  1  58 44 28     
0023F5  1  CA                   dex
0023F6  1  E0 7F                cpx #$7f
0023F8  1  08 E0 7E F0          tst_x $7e,~fzc
0023FC  1  03 20 58 44  
002400  1  68 48 C9 FC  
00240A  1  AD 00 02 C9          next_test
00240E  1  1A F0 03 20  
002412  1  58 44 A9 1B  
002419  1               
002419  1               ; CPY - zp / abs / #
002419  1  A9 00 48 A0          set_y $80,0
00241D  1  80 28        
00241F  1  C4 rr                cpy zp7f
002421  1  08 68 48 C9          tst_stat fc
002425  1  31 F0 03 20  
002429  1  58 44 28     
00242C  1  88                   dey
00242D  1  C4 rr                cpy zp7f
00242F  1  08 68 48 C9          tst_stat fzc
002433  1  33 F0 03 20  
002437  1  58 44 28     
00243A  1  88                   dey
00243B  1  C4 rr                cpy zp7f
00243D  1  08 C0 7E F0          tst_y $7e,fn
002441  1  03 20 58 44  
002445  1  68 48 C9 B0  
00244F  1  A9 FF 48 A0          set_y $80,$ff
002453  1  80 28        
002455  1  C4 rr                cpy zp7f
002457  1  08 68 48 C9          tst_stat ~fnz
00245B  1  7D F0 03 20  
00245F  1  58 44 28     
002462  1  88                   dey
002463  1  C4 rr                cpy zp7f
002465  1  08 68 48 C9          tst_stat ~fn
002469  1  7F F0 03 20  
00246D  1  58 44 28     
002470  1  88                   dey
002471  1  C4 rr                cpy zp7f
002473  1  08 C0 7E F0          tst_y $7e,~fzc
002477  1  03 20 58 44  
00247B  1  68 48 C9 FC  
002485  1               
002485  1  A9 00 48 A0          set_y $80,0
002489  1  80 28        
00248B  1  CC 1B 02             cpy abs7f
00248E  1  08 68 48 C9          tst_stat fc
002492  1  31 F0 03 20  
002496  1  58 44 28     
002499  1  88                   dey
00249A  1  CC 1B 02             cpy abs7f
00249D  1  08 68 48 C9          tst_stat fzc
0024A1  1  33 F0 03 20  
0024A5  1  58 44 28     
0024A8  1  88                   dey
0024A9  1  CC 1B 02             cpy abs7f
0024AC  1  08 C0 7E F0          tst_y $7e,fn
0024B0  1  03 20 58 44  
0024B4  1  68 48 C9 B0  
0024BE  1  A9 FF 48 A0          set_y $80,$ff
0024C2  1  80 28        
0024C4  1  CC 1B 02             cpy abs7f
0024C7  1  08 68 48 C9          tst_stat ~fnz
0024CB  1  7D F0 03 20  
0024CF  1  58 44 28     
0024D2  1  88                   dey
0024D3  1  CC 1B 02             cpy abs7f
0024D6  1  08 68 48 C9          tst_stat ~fn
0024DA  1  7F F0 03 20  
0024DE  1  58 44 28     
0024E1  1  88                   dey
0024E2  1  CC 1B 02             cpy abs7f
0024E5  1  08 C0 7E F0          tst_y $7e,~fzc
0024E9  1  03 20 58 44  
0024ED  1  68 48 C9 FC  
0024F7  1               
0024F7  1  A9 00 48 A0          set_y $80,0
0024FB  1  80 28        
0024FD  1  C0 7F                cpy #$7f
0024FF  1  08 68 48 C9          tst_stat fc
002503  1  31 F0 03 20  
002507  1  58 44 28     
00250A  1  88                   dey
00250B  1  C0 7F                cpy #$7f
00250D  1  08 68 48 C9          tst_stat fzc
002511  1  33 F0 03 20  
002515  1  58 44 28     
002518  1  88                   dey
002519  1  C0 7F                cpy #$7f
00251B  1  08 C0 7E F0          tst_y $7e,fn
00251F  1  03 20 58 44  
002523  1  68 48 C9 B0  
00252D  1  A9 FF 48 A0          set_y $80,$ff
002531  1  80 28        
002533  1  C0 7F                cpy #$7f
002535  1  08 68 48 C9          tst_stat ~fnz
002539  1  7D F0 03 20  
00253D  1  58 44 28     
002540  1  88                   dey
002541  1  C0 7F                cpy #$7f
002543  1  08 68 48 C9          tst_stat ~fn
002547  1  7F F0 03 20  
00254B  1  58 44 28     
00254E  1  88                   dey
00254F  1  C0 7F                cpy #$7f
002551  1  08 C0 7E F0          tst_y $7e,~fzc
002555  1  03 20 58 44  
002559  1  68 48 C9 FC  
002563  1  AD 00 02 C9          next_test
002567  1  1B F0 03 20  
00256B  1  58 44 A9 1C  
002572  1               
002572  1               ; CMP - zp / abs / #
002572  1  A9 00 48 A9          set_a $80,0
002576  1  80 28        
002578  1  C5 rr                cmp zp7f
00257A  1  08 C9 80 F0          tst_a $80,fc
00257E  1  03 20 58 44  
002582  1  68 48 C9 31  
00258C  1  A9 00 48 A9          set_a $7f,0
002590  1  7F 28        
002592  1  C5 rr                cmp zp7f
002594  1  08 C9 7F F0          tst_a $7f,fzc
002598  1  03 20 58 44  
00259C  1  68 48 C9 33  
0025A6  1  A9 00 48 A9          set_a $7e,0
0025AA  1  7E 28        
0025AC  1  C5 rr                cmp zp7f
0025AE  1  08 C9 7E F0          tst_a $7e,fn
0025B2  1  03 20 58 44  
0025B6  1  68 48 C9 B0  
0025C0  1  A9 FF 48 A9          set_a $80,$ff
0025C4  1  80 28        
0025C6  1  C5 rr                cmp zp7f
0025C8  1  08 C9 80 F0          tst_a $80,~fnz
0025CC  1  03 20 58 44  
0025D0  1  68 48 C9 7D  
0025DA  1  A9 FF 48 A9          set_a $7f,$ff
0025DE  1  7F 28        
0025E0  1  C5 rr                cmp zp7f
0025E2  1  08 C9 7F F0          tst_a $7f,~fn
0025E6  1  03 20 58 44  
0025EA  1  68 48 C9 7F  
0025F4  1  A9 FF 48 A9          set_a $7e,$ff
0025F8  1  7E 28        
0025FA  1  C5 rr                cmp zp7f
0025FC  1  08 C9 7E F0          tst_a $7e,~fzc
002600  1  03 20 58 44  
002604  1  68 48 C9 FC  
00260E  1               
00260E  1  A9 00 48 A9          set_a $80,0
002612  1  80 28        
002614  1  CD 1B 02             cmp abs7f
002617  1  08 C9 80 F0          tst_a $80,fc
00261B  1  03 20 58 44  
00261F  1  68 48 C9 31  
002629  1  A9 00 48 A9          set_a $7f,0
00262D  1  7F 28        
00262F  1  CD 1B 02             cmp abs7f
002632  1  08 C9 7F F0          tst_a $7f,fzc
002636  1  03 20 58 44  
00263A  1  68 48 C9 33  
002644  1  A9 00 48 A9          set_a $7e,0
002648  1  7E 28        
00264A  1  CD 1B 02             cmp abs7f
00264D  1  08 C9 7E F0          tst_a $7e,fn
002651  1  03 20 58 44  
002655  1  68 48 C9 B0  
00265F  1  A9 FF 48 A9          set_a $80,$ff
002663  1  80 28        
002665  1  CD 1B 02             cmp abs7f
002668  1  08 C9 80 F0          tst_a $80,~fnz
00266C  1  03 20 58 44  
002670  1  68 48 C9 7D  
00267A  1  A9 FF 48 A9          set_a $7f,$ff
00267E  1  7F 28        
002680  1  CD 1B 02             cmp abs7f
002683  1  08 C9 7F F0          tst_a $7f,~fn
002687  1  03 20 58 44  
00268B  1  68 48 C9 7F  
002695  1  A9 FF 48 A9          set_a $7e,$ff
002699  1  7E 28        
00269B  1  CD 1B 02             cmp abs7f
00269E  1  08 C9 7E F0          tst_a $7e,~fzc
0026A2  1  03 20 58 44  
0026A6  1  68 48 C9 FC  
0026B0  1               
0026B0  1  A9 00 48 A9          set_a $80,0
0026B4  1  80 28        
0026B6  1  C9 7F                cmp #$7f
0026B8  1  08 C9 80 F0          tst_a $80,fc
0026BC  1  03 20 58 44  
0026C0  1  68 48 C9 31  
0026CA  1  A9 00 48 A9          set_a $7f,0
0026CE  1  7F 28        
0026D0  1  C9 7F                cmp #$7f
0026D2  1  08 C9 7F F0          tst_a $7f,fzc
0026D6  1  03 20 58 44  
0026DA  1  68 48 C9 33  
0026E4  1  A9 00 48 A9          set_a $7e,0
0026E8  1  7E 28        
0026EA  1  C9 7F                cmp #$7f
0026EC  1  08 C9 7E F0          tst_a $7e,fn
0026F0  1  03 20 58 44  
0026F4  1  68 48 C9 B0  
0026FE  1  A9 FF 48 A9          set_a $80,$ff
002702  1  80 28        
002704  1  C9 7F                cmp #$7f
002706  1  08 C9 80 F0          tst_a $80,~fnz
00270A  1  03 20 58 44  
00270E  1  68 48 C9 7D  
002718  1  A9 FF 48 A9          set_a $7f,$ff
00271C  1  7F 28        
00271E  1  C9 7F                cmp #$7f
002720  1  08 C9 7F F0          tst_a $7f,~fn
002724  1  03 20 58 44  
002728  1  68 48 C9 7F  
002732  1  A9 FF 48 A9          set_a $7e,$ff
002736  1  7E 28        
002738  1  C9 7F                cmp #$7f
00273A  1  08 C9 7E F0          tst_a $7e,~fzc
00273E  1  03 20 58 44  
002742  1  68 48 C9 FC  
00274C  1               
00274C  1  A2 04                ldx #4          ;with indexing by X
00274E  1  A9 00 48 A9          set_a $80,0
002752  1  80 28        
002754  1  D5 rr                cmp zp1,x
002756  1  08 C9 80 F0          tst_a $80,fc
00275A  1  03 20 58 44  
00275E  1  68 48 C9 31  
002768  1  A9 00 48 A9          set_a $7f,0
00276C  1  7F 28        
00276E  1  D5 rr                cmp zp1,x
002770  1  08 C9 7F F0          tst_a $7f,fzc
002774  1  03 20 58 44  
002778  1  68 48 C9 33  
002782  1  A9 00 48 A9          set_a $7e,0
002786  1  7E 28        
002788  1  D5 rr                cmp zp1,x
00278A  1  08 C9 7E F0          tst_a $7e,fn
00278E  1  03 20 58 44  
002792  1  68 48 C9 B0  
00279C  1  A9 FF 48 A9          set_a $80,$ff
0027A0  1  80 28        
0027A2  1  D5 rr                cmp zp1,x
0027A4  1  08 C9 80 F0          tst_a $80,~fnz
0027A8  1  03 20 58 44  
0027AC  1  68 48 C9 7D  
0027B6  1  A9 FF 48 A9          set_a $7f,$ff
0027BA  1  7F 28        
0027BC  1  D5 rr                cmp zp1,x
0027BE  1  08 C9 7F F0          tst_a $7f,~fn
0027C2  1  03 20 58 44  
0027C6  1  68 48 C9 7F  
0027D0  1  A9 FF 48 A9          set_a $7e,$ff
0027D4  1  7E 28        
0027D6  1  D5 rr                cmp zp1,x
0027D8  1  08 C9 7E F0          tst_a $7e,~fzc
0027DC  1  03 20 58 44  
0027E0  1  68 48 C9 FC  
0027EA  1               
0027EA  1  A9 00 48 A9          set_a $80,0
0027EE  1  80 28        
0027F0  1  DD 17 02             cmp abs1,x
0027F3  1  08 C9 80 F0          tst_a $80,fc
0027F7  1  03 20 58 44  
0027FB  1  68 48 C9 31  
002805  1  A9 00 48 A9          set_a $7f,0
002809  1  7F 28        
00280B  1  DD 17 02             cmp abs1,x
00280E  1  08 C9 7F F0          tst_a $7f,fzc
002812  1  03 20 58 44  
002816  1  68 48 C9 33  
002820  1  A9 00 48 A9          set_a $7e,0
002824  1  7E 28        
002826  1  DD 17 02             cmp abs1,x
002829  1  08 C9 7E F0          tst_a $7e,fn
00282D  1  03 20 58 44  
002831  1  68 48 C9 B0  
00283B  1  A9 FF 48 A9          set_a $80,$ff
00283F  1  80 28        
002841  1  DD 17 02             cmp abs1,x
002844  1  08 C9 80 F0          tst_a $80,~fnz
002848  1  03 20 58 44  
00284C  1  68 48 C9 7D  
002856  1  A9 FF 48 A9          set_a $7f,$ff
00285A  1  7F 28        
00285C  1  DD 17 02             cmp abs1,x
00285F  1  08 C9 7F F0          tst_a $7f,~fn
002863  1  03 20 58 44  
002867  1  68 48 C9 7F  
002871  1  A9 FF 48 A9          set_a $7e,$ff
002875  1  7E 28        
002877  1  DD 17 02             cmp abs1,x
00287A  1  08 C9 7E F0          tst_a $7e,~fzc
00287E  1  03 20 58 44  
002882  1  68 48 C9 FC  
00288C  1               
00288C  1  A0 04                ldy #4          ;with indexing by Y
00288E  1  A2 08                ldx #8          ;with indexed indirect
002890  1  A9 00 48 A9          set_a $80,0
002894  1  80 28        
002896  1  D9 17 02             cmp abs1,y
002899  1  08 C9 80 F0          tst_a $80,fc
00289D  1  03 20 58 44  
0028A1  1  68 48 C9 31  
0028AB  1  A9 00 48 A9          set_a $7f,0
0028AF  1  7F 28        
0028B1  1  D9 17 02             cmp abs1,y
0028B4  1  08 C9 7F F0          tst_a $7f,fzc
0028B8  1  03 20 58 44  
0028BC  1  68 48 C9 33  
0028C6  1  A9 00 48 A9          set_a $7e,0
0028CA  1  7E 28        
0028CC  1  D9 17 02             cmp abs1,y
0028CF  1  08 C9 7E F0          tst_a $7e,fn
0028D3  1  03 20 58 44  
0028D7  1  68 48 C9 B0  
0028E1  1  A9 FF 48 A9          set_a $80,$ff
0028E5  1  80 28        
0028E7  1  D9 17 02             cmp abs1,y
0028EA  1  08 C9 80 F0          tst_a $80,~fnz
0028EE  1  03 20 58 44  
0028F2  1  68 48 C9 7D  
0028FC  1  A9 FF 48 A9          set_a $7f,$ff
002900  1  7F 28        
002902  1  D9 17 02             cmp abs1,y
002905  1  08 C9 7F F0          tst_a $7f,~fn
002909  1  03 20 58 44  
00290D  1  68 48 C9 7F  
002917  1  A9 FF 48 A9          set_a $7e,$ff
00291B  1  7E 28        
00291D  1  D9 17 02             cmp abs1,y
002920  1  08 C9 7E F0          tst_a $7e,~fzc
002924  1  03 20 58 44  
002928  1  68 48 C9 FC  
002932  1               
002932  1  A9 00 48 A9          set_a $80,0
002936  1  80 28        
002938  1  C1 rr                cmp (ind1,x)
00293A  1  08 C9 80 F0          tst_a $80,fc
00293E  1  03 20 58 44  
002942  1  68 48 C9 31  
00294C  1  A9 00 48 A9          set_a $7f,0
002950  1  7F 28        
002952  1  C1 rr                cmp (ind1,x)
002954  1  08 C9 7F F0          tst_a $7f,fzc
002958  1  03 20 58 44  
00295C  1  68 48 C9 33  
002966  1  A9 00 48 A9          set_a $7e,0
00296A  1  7E 28        
00296C  1  C1 rr                cmp (ind1,x)
00296E  1  08 C9 7E F0          tst_a $7e,fn
002972  1  03 20 58 44  
002976  1  68 48 C9 B0  
002980  1  A9 FF 48 A9          set_a $80,$ff
002984  1  80 28        
002986  1  C1 rr                cmp (ind1,x)
002988  1  08 C9 80 F0          tst_a $80,~fnz
00298C  1  03 20 58 44  
002990  1  68 48 C9 7D  
00299A  1  A9 FF 48 A9          set_a $7f,$ff
00299E  1  7F 28        
0029A0  1  C1 rr                cmp (ind1,x)
0029A2  1  08 C9 7F F0          tst_a $7f,~fn
0029A6  1  03 20 58 44  
0029AA  1  68 48 C9 7F  
0029B4  1  A9 FF 48 A9          set_a $7e,$ff
0029B8  1  7E 28        
0029BA  1  C1 rr                cmp (ind1,x)
0029BC  1  08 C9 7E F0          tst_a $7e,~fzc
0029C0  1  03 20 58 44  
0029C4  1  68 48 C9 FC  
0029CE  1               
0029CE  1  A9 00 48 A9          set_a $80,0
0029D2  1  80 28        
0029D4  1  D1 rr                cmp (ind1),y
0029D6  1  08 C9 80 F0          tst_a $80,fc
0029DA  1  03 20 58 44  
0029DE  1  68 48 C9 31  
0029E8  1  A9 00 48 A9          set_a $7f,0
0029EC  1  7F 28        
0029EE  1  D1 rr                cmp (ind1),y
0029F0  1  08 C9 7F F0          tst_a $7f,fzc
0029F4  1  03 20 58 44  
0029F8  1  68 48 C9 33  
002A02  1  A9 00 48 A9          set_a $7e,0
002A06  1  7E 28        
002A08  1  D1 rr                cmp (ind1),y
002A0A  1  08 C9 7E F0          tst_a $7e,fn
002A0E  1  03 20 58 44  
002A12  1  68 48 C9 B0  
002A1C  1  A9 FF 48 A9          set_a $80,$ff
002A20  1  80 28        
002A22  1  D1 rr                cmp (ind1),y
002A24  1  08 C9 80 F0          tst_a $80,~fnz
002A28  1  03 20 58 44  
002A2C  1  68 48 C9 7D  
002A36  1  A9 FF 48 A9          set_a $7f,$ff
002A3A  1  7F 28        
002A3C  1  D1 rr                cmp (ind1),y
002A3E  1  08 C9 7F F0          tst_a $7f,~fn
002A42  1  03 20 58 44  
002A46  1  68 48 C9 7F  
002A50  1  A9 FF 48 A9          set_a $7e,$ff
002A54  1  7E 28        
002A56  1  D1 rr                cmp (ind1),y
002A58  1  08 C9 7E F0          tst_a $7e,~fzc
002A5C  1  03 20 58 44  
002A60  1  68 48 C9 FC  
002A6A  1  AD 00 02 C9          next_test
002A6E  1  1C F0 03 20  
002A72  1  58 44 A9 1D  
002A79  1               
002A79  1               ; testing shifts - ASL LSR ROL ROR all addressing modes
002A79  1               ; shifts - accumulator
002A79  1  A2 03                ldx #3
002A7B  1               tasl:
002A7B  1  A9 00 48 B5          set_ax zp1,0
002A7F  1  rr 28        
002A81  1  0A                   asl a
002A82  1  08 DD 20 02          tst_ax rASL,fASL,0
002A86  1  F0 03 20 58  
002A8A  1  44 68 49 30  
002A96  1  CA                   dex
002A97  1  10 E2                bpl tasl
002A99  1  A2 03                ldx #3
002A9B  1               tasl1:
002A9B  1  A9 FF 48 B5          set_ax zp1,$ff
002A9F  1  rr 28        
002AA1  1  0A                   asl a
002AA2  1  08 DD 20 02          tst_ax rASL,fASL,$ff-fnzc
002AA6  1  F0 03 20 58  
002AAA  1  44 68 49 7C  
002AB6  1  CA                   dex
002AB7  1  10 E2                bpl tasl1
002AB9  1               
002AB9  1  A2 03                ldx #3
002ABB  1               tlsr:
002ABB  1  A9 00 48 B5          set_ax zp1,0
002ABF  1  rr 28        
002AC1  1  4A                   lsr a
002AC2  1  08 DD 28 02          tst_ax rLSR,fLSR,0
002AC6  1  F0 03 20 58  
002ACA  1  44 68 49 30  
002AD6  1  CA                   dex
002AD7  1  10 E2                bpl tlsr
002AD9  1  A2 03                ldx #3
002ADB  1               tlsr1:
002ADB  1  A9 FF 48 B5          set_ax zp1,$ff
002ADF  1  rr 28        
002AE1  1  4A                   lsr a
002AE2  1  08 DD 28 02          tst_ax rLSR,fLSR,$ff-fnzc
002AE6  1  F0 03 20 58  
002AEA  1  44 68 49 7C  
002AF6  1  CA                   dex
002AF7  1  10 E2                bpl tlsr1
002AF9  1               
002AF9  1  A2 03                ldx #3
002AFB  1               trol:
002AFB  1  A9 00 48 B5          set_ax zp1,0
002AFF  1  rr 28        
002B01  1  2A                   rol a
002B02  1  08 DD 20 02          tst_ax rROL,fROL,0
002B06  1  F0 03 20 58  
002B0A  1  44 68 49 30  
002B16  1  CA                   dex
002B17  1  10 E2                bpl trol
002B19  1  A2 03                ldx #3
002B1B  1               trol1:
002B1B  1  A9 FE 48 B5          set_ax zp1,$ff-fc
002B1F  1  rr 28        
002B21  1  2A                   rol a
002B22  1  08 DD 20 02          tst_ax rROL,fROL,$ff-fnzc
002B26  1  F0 03 20 58  
002B2A  1  44 68 49 7C  
002B36  1  CA                   dex
002B37  1  10 E2                bpl trol1
002B39  1               
002B39  1  A2 03                ldx #3
002B3B  1               trolc:
002B3B  1  A9 01 48 B5          set_ax zp1,fc
002B3F  1  rr 28        
002B41  1  2A                   rol a
002B42  1  08 DD 24 02          tst_ax rROLc,fROLc,0
002B46  1  F0 03 20 58  
002B4A  1  44 68 49 30  
002B56  1  CA                   dex
002B57  1  10 E2                bpl trolc
002B59  1  A2 03                ldx #3
002B5B  1               trolc1:
002B5B  1  A9 FF 48 B5          set_ax zp1,$ff
002B5F  1  rr 28        
002B61  1  2A                   rol a
002B62  1  08 DD 24 02          tst_ax rROLc,fROLc,$ff-fnzc
002B66  1  F0 03 20 58  
002B6A  1  44 68 49 7C  
002B76  1  CA                   dex
002B77  1  10 E2                bpl trolc1
002B79  1               
002B79  1  A2 03                ldx #3
002B7B  1               tror:
002B7B  1  A9 00 48 B5          set_ax zp1,0
002B7F  1  rr 28        
002B81  1  6A                   ror a
002B82  1  08 DD 28 02          tst_ax rROR,fROR,0
002B86  1  F0 03 20 58  
002B8A  1  44 68 49 30  
002B96  1  CA                   dex
002B97  1  10 E2                bpl tror
002B99  1  A2 03                ldx #3
002B9B  1               tror1:
002B9B  1  A9 FE 48 B5          set_ax zp1,$ff-fc
002B9F  1  rr 28        
002BA1  1  6A                   ror a
002BA2  1  08 DD 28 02          tst_ax rROR,fROR,$ff-fnzc
002BA6  1  F0 03 20 58  
002BAA  1  44 68 49 7C  
002BB6  1  CA                   dex
002BB7  1  10 E2                bpl tror1
002BB9  1               
002BB9  1  A2 03                ldx #3
002BBB  1               trorc:
002BBB  1  A9 01 48 B5          set_ax zp1,fc
002BBF  1  rr 28        
002BC1  1  6A                   ror a
002BC2  1  08 DD 2C 02          tst_ax rRORc,fRORc,0
002BC6  1  F0 03 20 58  
002BCA  1  44 68 49 30  
002BD6  1  CA                   dex
002BD7  1  10 E2                bpl trorc
002BD9  1  A2 03                ldx #3
002BDB  1               trorc1:
002BDB  1  A9 FF 48 B5          set_ax zp1,$ff
002BDF  1  rr 28        
002BE1  1  6A                   ror a
002BE2  1  08 DD 2C 02          tst_ax rRORc,fRORc,$ff-fnzc
002BE6  1  F0 03 20 58  
002BEA  1  44 68 49 7C  
002BF6  1  CA                   dex
002BF7  1  10 E2                bpl trorc1
002BF9  1  AD 00 02 C9          next_test
002BFD  1  1D F0 03 20  
002C01  1  58 44 A9 1E  
002C08  1               
002C08  1               ; shifts - zeropage
002C08  1  A2 03                ldx #3
002C0A  1               tasl2:
002C0A  1  A9 00 48 B5          set_z zp1,0
002C0E  1  rr 85 rr 28  
002C12  1  06 rr                asl zpt
002C14  1  08 A5 rr DD          tst_z rASL,fASL,0
002C18  1  20 02 F0 03  
002C1C  1  20 58 44 68  
002C2A  1  CA                   dex
002C2B  1  10 DD                bpl tasl2
002C2D  1  A2 03                ldx #3
002C2F  1               tasl3:
002C2F  1  A9 FF 48 B5          set_z zp1,$ff
002C33  1  rr 85 rr 28  
002C37  1  06 rr                asl zpt
002C39  1  08 A5 rr DD          tst_z rASL,fASL,$ff-fnzc
002C3D  1  20 02 F0 03  
002C41  1  20 58 44 68  
002C4F  1  CA                   dex
002C50  1  10 DD                bpl tasl3
002C52  1               
002C52  1  A2 03                ldx #3
002C54  1               tlsr2:
002C54  1  A9 00 48 B5          set_z zp1,0
002C58  1  rr 85 rr 28  
002C5C  1  46 rr                lsr zpt
002C5E  1  08 A5 rr DD          tst_z rLSR,fLSR,0
002C62  1  28 02 F0 03  
002C66  1  20 58 44 68  
002C74  1  CA                   dex
002C75  1  10 DD                bpl tlsr2
002C77  1  A2 03                ldx #3
002C79  1               tlsr3:
002C79  1  A9 FF 48 B5          set_z zp1,$ff
002C7D  1  rr 85 rr 28  
002C81  1  46 rr                lsr zpt
002C83  1  08 A5 rr DD          tst_z rLSR,fLSR,$ff-fnzc
002C87  1  28 02 F0 03  
002C8B  1  20 58 44 68  
002C99  1  CA                   dex
002C9A  1  10 DD                bpl tlsr3
002C9C  1               
002C9C  1  A2 03                ldx #3
002C9E  1               trol2:
002C9E  1  A9 00 48 B5          set_z zp1,0
002CA2  1  rr 85 rr 28  
002CA6  1  26 rr                rol zpt
002CA8  1  08 A5 rr DD          tst_z rROL,fROL,0
002CAC  1  20 02 F0 03  
002CB0  1  20 58 44 68  
002CBE  1  CA                   dex
002CBF  1  10 DD                bpl trol2
002CC1  1  A2 03                ldx #3
002CC3  1               trol3:
002CC3  1  A9 FE 48 B5          set_z zp1,$ff-fc
002CC7  1  rr 85 rr 28  
002CCB  1  26 rr                rol zpt
002CCD  1  08 A5 rr DD          tst_z rROL,fROL,$ff-fnzc
002CD1  1  20 02 F0 03  
002CD5  1  20 58 44 68  
002CE3  1  CA                   dex
002CE4  1  10 DD                bpl trol3
002CE6  1               
002CE6  1  A2 03                ldx #3
002CE8  1               trolc2:
002CE8  1  A9 01 48 B5          set_z zp1,fc
002CEC  1  rr 85 rr 28  
002CF0  1  26 rr                rol zpt
002CF2  1  08 A5 rr DD          tst_z rROLc,fROLc,0
002CF6  1  24 02 F0 03  
002CFA  1  20 58 44 68  
002D08  1  CA                   dex
002D09  1  10 DD                bpl trolc2
002D0B  1  A2 03                ldx #3
002D0D  1               trolc3:
002D0D  1  A9 FF 48 B5          set_z zp1,$ff
002D11  1  rr 85 rr 28  
002D15  1  26 rr                rol zpt
002D17  1  08 A5 rr DD          tst_z rROLc,fROLc,$ff-fnzc
002D1B  1  24 02 F0 03  
002D1F  1  20 58 44 68  
002D2D  1  CA                   dex
002D2E  1  10 DD                bpl trolc3
002D30  1               
002D30  1  A2 03                ldx #3
002D32  1               tror2:
002D32  1  A9 00 48 B5          set_z zp1,0
002D36  1  rr 85 rr 28  
002D3A  1  66 rr                ror zpt
002D3C  1  08 A5 rr DD          tst_z rROR,fROR,0
002D40  1  28 02 F0 03  
002D44  1  20 58 44 68  
002D52  1  CA                   dex
002D53  1  10 DD                bpl tror2
002D55  1  A2 03                ldx #3
002D57  1               tror3:
002D57  1  A9 FE 48 B5          set_z zp1,$ff-fc
002D5B  1  rr 85 rr 28  
002D5F  1  66 rr                ror zpt
002D61  1  08 A5 rr DD          tst_z rROR,fROR,$ff-fnzc
002D65  1  28 02 F0 03  
002D69  1  20 58 44 68  
002D77  1  CA                   dex
002D78  1  10 DD                bpl tror3
002D7A  1               
002D7A  1  A2 03                ldx #3
002D7C  1               trorc2:
002D7C  1  A9 01 48 B5          set_z zp1,fc
002D80  1  rr 85 rr 28  
002D84  1  66 rr                ror zpt
002D86  1  08 A5 rr DD          tst_z rRORc,fRORc,0
002D8A  1  2C 02 F0 03  
002D8E  1  20 58 44 68  
002D9C  1  CA                   dex
002D9D  1  10 DD                bpl trorc2
002D9F  1  A2 03                ldx #3
002DA1  1               trorc3:
002DA1  1  A9 FF 48 B5          set_z zp1,$ff
002DA5  1  rr 85 rr 28  
002DA9  1  66 rr                ror zpt
002DAB  1  08 A5 rr DD          tst_z rRORc,fRORc,$ff-fnzc
002DAF  1  2C 02 F0 03  
002DB3  1  20 58 44 68  
002DC1  1  CA                   dex
002DC2  1  10 DD                bpl trorc3
002DC4  1  AD 00 02 C9          next_test
002DC8  1  1E F0 03 20  
002DCC  1  58 44 A9 1F  
002DD3  1               
002DD3  1               ; shifts - absolute
002DD3  1  A2 03                ldx #3
002DD5  1               tasl4:
002DD5  1  A9 00 48 B5          set_abs zp1,0
002DD9  1  rr 8D 03 02  
002DDD  1  28           
002DDE  1  0E 03 02             asl abst
002DE1  1  08 AD 03 02          tst_abs rASL,fASL,0
002DE5  1  DD 20 02 F0  
002DE9  1  03 20 58 44  
002DF8  1  CA                   dex
002DF9  1  10 DA                bpl tasl4
002DFB  1  A2 03                ldx #3
002DFD  1               tasl5:
002DFD  1  A9 FF 48 B5          set_abs zp1,$ff
002E01  1  rr 8D 03 02  
002E05  1  28           
002E06  1  0E 03 02             asl abst
002E09  1  08 AD 03 02          tst_abs rASL,fASL,$ff-fnzc
002E0D  1  DD 20 02 F0  
002E11  1  03 20 58 44  
002E20  1  CA                   dex
002E21  1  10 DA                bpl tasl5
002E23  1               
002E23  1  A2 03                ldx #3
002E25  1               tlsr4:
002E25  1  A9 00 48 B5          set_abs zp1,0
002E29  1  rr 8D 03 02  
002E2D  1  28           
002E2E  1  4E 03 02             lsr abst
002E31  1  08 AD 03 02          tst_abs rLSR,fLSR,0
002E35  1  DD 28 02 F0  
002E39  1  03 20 58 44  
002E48  1  CA                   dex
002E49  1  10 DA                bpl tlsr4
002E4B  1  A2 03                ldx #3
002E4D  1               tlsr5:
002E4D  1  A9 FF 48 B5          set_abs zp1,$ff
002E51  1  rr 8D 03 02  
002E55  1  28           
002E56  1  4E 03 02             lsr abst
002E59  1  08 AD 03 02          tst_abs rLSR,fLSR,$ff-fnzc
002E5D  1  DD 28 02 F0  
002E61  1  03 20 58 44  
002E70  1  CA                   dex
002E71  1  10 DA                bpl tlsr5
002E73  1               
002E73  1  A2 03                ldx #3
002E75  1               trol4:
002E75  1  A9 00 48 B5          set_abs zp1,0
002E79  1  rr 8D 03 02  
002E7D  1  28           
002E7E  1  2E 03 02             rol abst
002E81  1  08 AD 03 02          tst_abs rROL,fROL,0
002E85  1  DD 20 02 F0  
002E89  1  03 20 58 44  
002E98  1  CA                   dex
002E99  1  10 DA                bpl trol4
002E9B  1  A2 03                ldx #3
002E9D  1               trol5:
002E9D  1  A9 FE 48 B5          set_abs zp1,$ff-fc
002EA1  1  rr 8D 03 02  
002EA5  1  28           
002EA6  1  2E 03 02             rol abst
002EA9  1  08 AD 03 02          tst_abs rROL,fROL,$ff-fnzc
002EAD  1  DD 20 02 F0  
002EB1  1  03 20 58 44  
002EC0  1  CA                   dex
002EC1  1  10 DA                bpl trol5
002EC3  1               
002EC3  1  A2 03                ldx #3
002EC5  1               trolc4:
002EC5  1  A9 01 48 B5          set_abs zp1,fc
002EC9  1  rr 8D 03 02  
002ECD  1  28           
002ECE  1  2E 03 02             rol abst
002ED1  1  08 AD 03 02          tst_abs rROLc,fROLc,0
002ED5  1  DD 24 02 F0  
002ED9  1  03 20 58 44  
002EE8  1  CA                   dex
002EE9  1  10 DA                bpl trolc4
002EEB  1  A2 03                ldx #3
002EED  1               trolc5:
002EED  1  A9 FF 48 B5          set_abs zp1,$ff
002EF1  1  rr 8D 03 02  
002EF5  1  28           
002EF6  1  2E 03 02             rol abst
002EF9  1  08 AD 03 02          tst_abs rROLc,fROLc,$ff-fnzc
002EFD  1  DD 24 02 F0  
002F01  1  03 20 58 44  
002F10  1  CA                   dex
002F11  1  10 DA                bpl trolc5
002F13  1               
002F13  1  A2 03                ldx #3
002F15  1               tror4:
002F15  1  A9 00 48 B5          set_abs zp1,0
002F19  1  rr 8D 03 02  
002F1D  1  28           
002F1E  1  6E 03 02             ror abst
002F21  1  08 AD 03 02          tst_abs rROR,fROR,0
002F25  1  DD 28 02 F0  
002F29  1  03 20 58 44  
002F38  1  CA                   dex
002F39  1  10 DA                bpl tror4
002F3B  1  A2 03                ldx #3
002F3D  1               tror5:
002F3D  1  A9 FE 48 B5          set_abs zp1,$ff-fc
002F41  1  rr 8D 03 02  
002F45  1  28           
002F46  1  6E 03 02             ror abst
002F49  1  08 AD 03 02          tst_abs rROR,fROR,$ff-fnzc
002F4D  1  DD 28 02 F0  
002F51  1  03 20 58 44  
002F60  1  CA                   dex
002F61  1  10 DA                bpl tror5
002F63  1               
002F63  1  A2 03                ldx #3
002F65  1               trorc4:
002F65  1  A9 01 48 B5          set_abs zp1,fc
002F69  1  rr 8D 03 02  
002F6D  1  28           
002F6E  1  6E 03 02             ror abst
002F71  1  08 AD 03 02          tst_abs rRORc,fRORc,0
002F75  1  DD 2C 02 F0  
002F79  1  03 20 58 44  
002F88  1  CA                   dex
002F89  1  10 DA                bpl trorc4
002F8B  1  A2 03                ldx #3
002F8D  1               trorc5:
002F8D  1  A9 FF 48 B5          set_abs zp1,$ff
002F91  1  rr 8D 03 02  
002F95  1  28           
002F96  1  6E 03 02             ror abst
002F99  1  08 AD 03 02          tst_abs rRORc,fRORc,$ff-fnzc
002F9D  1  DD 2C 02 F0  
002FA1  1  03 20 58 44  
002FB0  1  CA                   dex
002FB1  1  10 DA                bpl trorc5
002FB3  1  AD 00 02 C9          next_test
002FB7  1  1F F0 03 20  
002FBB  1  58 44 A9 20  
002FC2  1               
002FC2  1               ; shifts - zp indexed
002FC2  1  A2 03                ldx #3
002FC4  1               tasl6:
002FC4  1  A9 00 48 B5          set_zx zp1,0
002FC8  1  rr 95 rr 28  
002FCC  1  16 rr                asl zpt,x
002FCE  1  08 B5 rr DD          tst_zx rASL,fASL,0
002FD2  1  20 02 F0 03  
002FD6  1  20 58 44 68  
002FE4  1  CA                   dex
002FE5  1  10 DD                bpl tasl6
002FE7  1  A2 03                ldx #3
002FE9  1               tasl7:
002FE9  1  A9 FF 48 B5          set_zx zp1,$ff
002FED  1  rr 95 rr 28  
002FF1  1  16 rr                asl zpt,x
002FF3  1  08 B5 rr DD          tst_zx rASL,fASL,$ff-fnzc
002FF7  1  20 02 F0 03  
002FFB  1  20 58 44 68  
003009  1  CA                   dex
00300A  1  10 DD                bpl tasl7
00300C  1               
00300C  1  A2 03                ldx #3
00300E  1               tlsr6:
00300E  1  A9 00 48 B5          set_zx zp1,0
003012  1  rr 95 rr 28  
003016  1  56 rr                lsr zpt,x
003018  1  08 B5 rr DD          tst_zx rLSR,fLSR,0
00301C  1  28 02 F0 03  
003020  1  20 58 44 68  
00302E  1  CA                   dex
00302F  1  10 DD                bpl tlsr6
003031  1  A2 03                ldx #3
003033  1               tlsr7:
003033  1  A9 FF 48 B5          set_zx zp1,$ff
003037  1  rr 95 rr 28  
00303B  1  56 rr                lsr zpt,x
00303D  1  08 B5 rr DD          tst_zx rLSR,fLSR,$ff-fnzc
003041  1  28 02 F0 03  
003045  1  20 58 44 68  
003053  1  CA                   dex
003054  1  10 DD                bpl tlsr7
003056  1               
003056  1  A2 03                ldx #3
003058  1               trol6:
003058  1  A9 00 48 B5          set_zx zp1,0
00305C  1  rr 95 rr 28  
003060  1  36 rr                rol zpt,x
003062  1  08 B5 rr DD          tst_zx rROL,fROL,0
003066  1  20 02 F0 03  
00306A  1  20 58 44 68  
003078  1  CA                   dex
003079  1  10 DD                bpl trol6
00307B  1  A2 03                ldx #3
00307D  1               trol7:
00307D  1  A9 FE 48 B5          set_zx zp1,$ff-fc
003081  1  rr 95 rr 28  
003085  1  36 rr                rol zpt,x
003087  1  08 B5 rr DD          tst_zx rROL,fROL,$ff-fnzc
00308B  1  20 02 F0 03  
00308F  1  20 58 44 68  
00309D  1  CA                   dex
00309E  1  10 DD                bpl trol7
0030A0  1               
0030A0  1  A2 03                ldx #3
0030A2  1               trolc6:
0030A2  1  A9 01 48 B5          set_zx zp1,fc
0030A6  1  rr 95 rr 28  
0030AA  1  36 rr                rol zpt,x
0030AC  1  08 B5 rr DD          tst_zx rROLc,fROLc,0
0030B0  1  24 02 F0 03  
0030B4  1  20 58 44 68  
0030C2  1  CA                   dex
0030C3  1  10 DD                bpl trolc6
0030C5  1  A2 03                ldx #3
0030C7  1               trolc7:
0030C7  1  A9 FF 48 B5          set_zx zp1,$ff
0030CB  1  rr 95 rr 28  
0030CF  1  36 rr                rol zpt,x
0030D1  1  08 B5 rr DD          tst_zx rROLc,fROLc,$ff-fnzc
0030D5  1  24 02 F0 03  
0030D9  1  20 58 44 68  
0030E7  1  CA                   dex
0030E8  1  10 DD                bpl trolc7
0030EA  1               
0030EA  1  A2 03                ldx #3
0030EC  1               tror6:
0030EC  1  A9 00 48 B5          set_zx zp1,0
0030F0  1  rr 95 rr 28  
0030F4  1  76 rr                ror zpt,x
0030F6  1  08 B5 rr DD          tst_zx rROR,fROR,0
0030FA  1  28 02 F0 03  
0030FE  1  20 58 44 68  
00310C  1  CA                   dex
00310D  1  10 DD                bpl tror6
00310F  1  A2 03                ldx #3
003111  1               tror7:
003111  1  A9 FE 48 B5          set_zx zp1,$ff-fc
003115  1  rr 95 rr 28  
003119  1  76 rr                ror zpt,x
00311B  1  08 B5 rr DD          tst_zx rROR,fROR,$ff-fnzc
00311F  1  28 02 F0 03  
003123  1  20 58 44 68  
003131  1  CA                   dex
003132  1  10 DD                bpl tror7
003134  1               
003134  1  A2 03                ldx #3
003136  1               trorc6:
003136  1  A9 01 48 B5          set_zx zp1,fc
00313A  1  rr 95 rr 28  
00313E  1  76 rr                ror zpt,x
003140  1  08 B5 rr DD          tst_zx rRORc,fRORc,0
003144  1  2C 02 F0 03  
003148  1  20 58 44 68  
003156  1  CA                   dex
003157  1  10 DD                bpl trorc6
003159  1  A2 03                ldx #3
00315B  1               trorc7:
00315B  1  A9 FF 48 B5          set_zx zp1,$ff
00315F  1  rr 95 rr 28  
003163  1  76 rr                ror zpt,x
003165  1  08 B5 rr DD          tst_zx rRORc,fRORc,$ff-fnzc
003169  1  2C 02 F0 03  
00316D  1  20 58 44 68  
00317B  1  CA                   dex
00317C  1  10 DD                bpl trorc7
00317E  1  AD 00 02 C9          next_test
003182  1  20 F0 03 20  
003186  1  58 44 A9 21  
00318D  1               
00318D  1               ; shifts - abs indexed
00318D  1  A2 03                ldx #3
00318F  1               tasl8:
00318F  1  A9 00 48 B5          set_absx zp1,0
003193  1  rr 9D 03 02  
003197  1  28           
003198  1  1E 03 02             asl abst,x
00319B  1  08 BD 03 02          tst_absx rASL,fASL,0
00319F  1  DD 20 02 F0  
0031A3  1  03 20 58 44  
0031B2  1  CA                   dex
0031B3  1  10 DA                bpl tasl8
0031B5  1  A2 03                ldx #3
0031B7  1               tasl9:
0031B7  1  A9 FF 48 B5          set_absx zp1,$ff
0031BB  1  rr 9D 03 02  
0031BF  1  28           
0031C0  1  1E 03 02             asl abst,x
0031C3  1  08 BD 03 02          tst_absx rASL,fASL,$ff-fnzc
0031C7  1  DD 20 02 F0  
0031CB  1  03 20 58 44  
0031DA  1  CA                   dex
0031DB  1  10 DA                bpl tasl9
0031DD  1               
0031DD  1  A2 03                ldx #3
0031DF  1               tlsr8:
0031DF  1  A9 00 48 B5          set_absx zp1,0
0031E3  1  rr 9D 03 02  
0031E7  1  28           
0031E8  1  5E 03 02             lsr abst,x
0031EB  1  08 BD 03 02          tst_absx rLSR,fLSR,0
0031EF  1  DD 28 02 F0  
0031F3  1  03 20 58 44  
003202  1  CA                   dex
003203  1  10 DA                bpl tlsr8
003205  1  A2 03                ldx #3
003207  1               tlsr9:
003207  1  A9 FF 48 B5          set_absx zp1,$ff
00320B  1  rr 9D 03 02  
00320F  1  28           
003210  1  5E 03 02             lsr abst,x
003213  1  08 BD 03 02          tst_absx rLSR,fLSR,$ff-fnzc
003217  1  DD 28 02 F0  
00321B  1  03 20 58 44  
00322A  1  CA                   dex
00322B  1  10 DA                bpl tlsr9
00322D  1               
00322D  1  A2 03                ldx #3
00322F  1               trol8:
00322F  1  A9 00 48 B5          set_absx zp1,0
003233  1  rr 9D 03 02  
003237  1  28           
003238  1  3E 03 02             rol abst,x
00323B  1  08 BD 03 02          tst_absx rROL,fROL,0
00323F  1  DD 20 02 F0  
003243  1  03 20 58 44  
003252  1  CA                   dex
003253  1  10 DA                bpl trol8
003255  1  A2 03                ldx #3
003257  1               trol9:
003257  1  A9 FE 48 B5          set_absx zp1,$ff-fc
00325B  1  rr 9D 03 02  
00325F  1  28           
003260  1  3E 03 02             rol abst,x
003263  1  08 BD 03 02          tst_absx rROL,fROL,$ff-fnzc
003267  1  DD 20 02 F0  
00326B  1  03 20 58 44  
00327A  1  CA                   dex
00327B  1  10 DA                bpl trol9
00327D  1               
00327D  1  A2 03                ldx #3
00327F  1               trolc8:
00327F  1  A9 01 48 B5          set_absx zp1,fc
003283  1  rr 9D 03 02  
003287  1  28           
003288  1  3E 03 02             rol abst,x
00328B  1  08 BD 03 02          tst_absx rROLc,fROLc,0
00328F  1  DD 24 02 F0  
003293  1  03 20 58 44  
0032A2  1  CA                   dex
0032A3  1  10 DA                bpl trolc8
0032A5  1  A2 03                ldx #3
0032A7  1               trolc9:
0032A7  1  A9 FF 48 B5          set_absx zp1,$ff
0032AB  1  rr 9D 03 02  
0032AF  1  28           
0032B0  1  3E 03 02             rol abst,x
0032B3  1  08 BD 03 02          tst_absx rROLc,fROLc,$ff-fnzc
0032B7  1  DD 24 02 F0  
0032BB  1  03 20 58 44  
0032CA  1  CA                   dex
0032CB  1  10 DA                bpl trolc9
0032CD  1               
0032CD  1  A2 03                ldx #3
0032CF  1               tror8:
0032CF  1  A9 00 48 B5          set_absx zp1,0
0032D3  1  rr 9D 03 02  
0032D7  1  28           
0032D8  1  7E 03 02             ror abst,x
0032DB  1  08 BD 03 02          tst_absx rROR,fROR,0
0032DF  1  DD 28 02 F0  
0032E3  1  03 20 58 44  
0032F2  1  CA                   dex
0032F3  1  10 DA                bpl tror8
0032F5  1  A2 03                ldx #3
0032F7  1               tror9:
0032F7  1  A9 FE 48 B5          set_absx zp1,$ff-fc
0032FB  1  rr 9D 03 02  
0032FF  1  28           
003300  1  7E 03 02             ror abst,x
003303  1  08 BD 03 02          tst_absx rROR,fROR,$ff-fnzc
003307  1  DD 28 02 F0  
00330B  1  03 20 58 44  
00331A  1  CA                   dex
00331B  1  10 DA                bpl tror9
00331D  1               
00331D  1  A2 03                ldx #3
00331F  1               trorc8:
00331F  1  A9 01 48 B5          set_absx zp1,fc
003323  1  rr 9D 03 02  
003327  1  28           
003328  1  7E 03 02             ror abst,x
00332B  1  08 BD 03 02          tst_absx rRORc,fRORc,0
00332F  1  DD 2C 02 F0  
003333  1  03 20 58 44  
003342  1  CA                   dex
003343  1  10 DA                bpl trorc8
003345  1  A2 03                ldx #3
003347  1               trorc9:
003347  1  A9 FF 48 B5          set_absx zp1,$ff
00334B  1  rr 9D 03 02  
00334F  1  28           
003350  1  7E 03 02             ror abst,x
003353  1  08 BD 03 02          tst_absx rRORc,fRORc,$ff-fnzc
003357  1  DD 2C 02 F0  
00335B  1  03 20 58 44  
00336A  1  CA                   dex
00336B  1  10 DA                bpl trorc9
00336D  1  AD 00 02 C9          next_test
003371  1  21 F0 03 20  
003375  1  58 44 A9 22  
00337C  1               
00337C  1               ; testing memory increment/decrement - INC DEC all addressing modes
00337C  1               ; zeropage
00337C  1  A2 00                ldx #0
00337E  1  A9 7E                lda #$7e
003380  1  85 rr                sta zpt
003382  1               tinc:
003382  1  A9 00 48 28          set_stat 0
003386  1  E6 rr                inc zpt
003388  1  08 A5 rr DD          tst_z rINC,fINC,0
00338C  1  40 02 F0 03  
003390  1  20 58 44 68  
00339E  1  E8                   inx
00339F  1  E0 02                cpx #2
0033A1  1  D0 04                bne tinc1
0033A3  1  A9 FE                lda #$fe
0033A5  1  85 rr                sta zpt
0033A7  1  E0 05        tinc1:   cpx #5
0033A9  1  D0 D7                bne tinc
0033AB  1  CA                   dex
0033AC  1  E6 rr                inc zpt
0033AE  1               tdec:
0033AE  1  A9 00 48 28          set_stat 0
0033B2  1  C6 rr                dec zpt
0033B4  1  08 A5 rr DD          tst_z rINC,fINC,0
0033B8  1  40 02 F0 03  
0033BC  1  20 58 44 68  
0033CA  1  CA                   dex
0033CB  1  30 0A                bmi tdec1
0033CD  1  E0 01                cpx #1
0033CF  1  D0 DD                bne tdec
0033D1  1  A9 81                lda #$81
0033D3  1  85 rr                sta zpt
0033D5  1  D0 D7                bne tdec
0033D7  1               tdec1:
0033D7  1  A2 00                ldx #0
0033D9  1  A9 7E                lda #$7e
0033DB  1  85 rr                sta zpt
0033DD  1               tinc10:
0033DD  1  A9 FF 48 28          set_stat $ff
0033E1  1  E6 rr                inc zpt
0033E3  1  08 A5 rr DD          tst_z rINC,fINC,$ff-fnz
0033E7  1  40 02 F0 03  
0033EB  1  20 58 44 68  
0033F9  1  E8                   inx
0033FA  1  E0 02                cpx #2
0033FC  1  D0 04                bne tinc11
0033FE  1  A9 FE                lda #$fe
003400  1  85 rr                sta zpt
003402  1  E0 05        tinc11:  cpx #5
003404  1  D0 D7                bne tinc10
003406  1  CA                   dex
003407  1  E6 rr                inc zpt
003409  1               tdec10:
003409  1  A9 FF 48 28          set_stat $ff
00340D  1  C6 rr                dec zpt
00340F  1  08 A5 rr DD          tst_z rINC,fINC,$ff-fnz
003413  1  40 02 F0 03  
003417  1  20 58 44 68  
003425  1  CA                   dex
003426  1  30 0A                bmi tdec11
003428  1  E0 01                cpx #1
00342A  1  D0 DD                bne tdec10
00342C  1  A9 81                lda #$81
00342E  1  85 rr                sta zpt
003430  1  D0 D7                bne tdec10
003432  1               tdec11:
003432  1  AD 00 02 C9          next_test
003436  1  22 F0 03 20  
00343A  1  58 44 A9 23  
003441  1               
003441  1               ; absolute memory
003441  1  A2 00                ldx #0
003443  1  A9 7E                lda #$7e
003445  1  8D 03 02             sta abst
003448  1               tinc2:
003448  1  A9 00 48 28          set_stat 0
00344C  1  EE 03 02             inc abst
00344F  1  08 AD 03 02          tst_abs rINC,fINC,0
003453  1  DD 40 02 F0  
003457  1  03 20 58 44  
003466  1  E8                   inx
003467  1  E0 02                cpx #2
003469  1  D0 05                bne tinc3
00346B  1  A9 FE                lda #$fe
00346D  1  8D 03 02             sta abst
003470  1  E0 05        tinc3:   cpx #5
003472  1  D0 D4                bne tinc2
003474  1  CA                   dex
003475  1  EE 03 02             inc abst
003478  1               tdec2:
003478  1  A9 00 48 28          set_stat 0
00347C  1  CE 03 02             dec abst
00347F  1  08 AD 03 02          tst_abs rINC,fINC,0
003483  1  DD 40 02 F0  
003487  1  03 20 58 44  
003496  1  CA                   dex
003497  1  30 0B                bmi tdec3
003499  1  E0 01                cpx #1
00349B  1  D0 DB                bne tdec2
00349D  1  A9 81                lda #$81
00349F  1  8D 03 02             sta abst
0034A2  1  D0 D4                bne tdec2
0034A4  1               tdec3:
0034A4  1  A2 00                ldx #0
0034A6  1  A9 7E                lda #$7e
0034A8  1  8D 03 02             sta abst
0034AB  1               tinc12:
0034AB  1  A9 FF 48 28          set_stat $ff
0034AF  1  EE 03 02             inc abst
0034B2  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
0034B6  1  DD 40 02 F0  
0034BA  1  03 20 58 44  
0034C9  1  E8                   inx
0034CA  1  E0 02                cpx #2
0034CC  1  D0 05                bne tinc13
0034CE  1  A9 FE                lda #$fe
0034D0  1  8D 03 02             sta abst
0034D3  1  E0 05        tinc13:   cpx #5
0034D5  1  D0 D4                bne tinc12
0034D7  1  CA                   dex
0034D8  1  EE 03 02             inc abst
0034DB  1               tdec12:
0034DB  1  A9 FF 48 28          set_stat $ff
0034DF  1  CE 03 02             dec abst
0034E2  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
0034E6  1  DD 40 02 F0  
0034EA  1  03 20 58 44  
0034F9  1  CA                   dex
0034FA  1  30 0B                bmi tdec13
0034FC  1  E0 01                cpx #1
0034FE  1  D0 DB                bne tdec12
003500  1  A9 81                lda #$81
003502  1  8D 03 02             sta abst
003505  1  D0 D4                bne tdec12
003507  1               tdec13:
003507  1  AD 00 02 C9          next_test
00350B  1  23 F0 03 20  
00350F  1  58 44 A9 24  
003516  1               
003516  1               ; zeropage indexed
003516  1  A2 00                ldx #0
003518  1  A9 7E                lda #$7e
00351A  1  95 rr        tinc4:   sta zpt,x
00351C  1  A9 00 48 28          set_stat 0
003520  1  F6 rr                inc zpt,x
003522  1  08 B5 rr DD          tst_zx rINC,fINC,0
003526  1  40 02 F0 03  
00352A  1  20 58 44 68  
003538  1  B5 rr                lda zpt,x
00353A  1  E8                   inx
00353B  1  E0 02                cpx #2
00353D  1  D0 02                bne tinc5
00353F  1  A9 FE                lda #$fe
003541  1  E0 05        tinc5:   cpx #5
003543  1  D0 D5                bne tinc4
003545  1  CA                   dex
003546  1  A9 02                lda #2
003548  1  95 rr        tdec4:   sta zpt,x
00354A  1  A9 00 48 28          set_stat 0
00354E  1  D6 rr                dec zpt,x
003550  1  08 B5 rr DD          tst_zx rINC,fINC,0
003554  1  40 02 F0 03  
003558  1  20 58 44 68  
003566  1  B5 rr                lda zpt,x
003568  1  CA                   dex
003569  1  30 08                bmi tdec5
00356B  1  E0 01                cpx #1
00356D  1  D0 D9                bne tdec4
00356F  1  A9 81                lda #$81
003571  1  D0 D5                bne tdec4
003573  1               tdec5:
003573  1  A2 00                ldx #0
003575  1  A9 7E                lda #$7e
003577  1  95 rr        tinc14:  sta zpt,x
003579  1  A9 FF 48 28          set_stat $ff
00357D  1  F6 rr                inc zpt,x
00357F  1  08 B5 rr DD          tst_zx rINC,fINC,$ff-fnz
003583  1  40 02 F0 03  
003587  1  20 58 44 68  
003595  1  B5 rr                lda zpt,x
003597  1  E8                   inx
003598  1  E0 02                cpx #2
00359A  1  D0 02                bne tinc15
00359C  1  A9 FE                lda #$fe
00359E  1  E0 05        tinc15:  cpx #5
0035A0  1  D0 D5                bne tinc14
0035A2  1  CA                   dex
0035A3  1  A9 02                lda #2
0035A5  1  95 rr        tdec14:  sta zpt,x
0035A7  1  A9 FF 48 28          set_stat $ff
0035AB  1  D6 rr                dec zpt,x
0035AD  1  08 B5 rr DD          tst_zx rINC,fINC,$ff-fnz
0035B1  1  40 02 F0 03  
0035B5  1  20 58 44 68  
0035C3  1  B5 rr                lda zpt,x
0035C5  1  CA                   dex
0035C6  1  30 08                bmi tdec15
0035C8  1  E0 01                cpx #1
0035CA  1  D0 D9                bne tdec14
0035CC  1  A9 81                lda #$81
0035CE  1  D0 D5                bne tdec14
0035D0  1               tdec15:
0035D0  1  AD 00 02 C9          next_test
0035D4  1  24 F0 03 20  
0035D8  1  58 44 A9 25  
0035DF  1               
0035DF  1               ; memory indexed
0035DF  1  A2 00                ldx #0
0035E1  1  A9 7E                lda #$7e
0035E3  1  9D 03 02     tinc6:   sta abst,x
0035E6  1  A9 00 48 28          set_stat 0
0035EA  1  FE 03 02             inc abst,x
0035ED  1  08 BD 03 02          tst_absx rINC,fINC,0
0035F1  1  DD 40 02 F0  
0035F5  1  03 20 58 44  
003604  1  BD 03 02             lda abst,x
003607  1  E8                   inx
003608  1  E0 02                cpx #2
00360A  1  D0 02                bne tinc7
00360C  1  A9 FE                lda #$fe
00360E  1  E0 05        tinc7:   cpx #5
003610  1  D0 D1                bne tinc6
003612  1  CA                   dex
003613  1  A9 02                lda #2
003615  1  9D 03 02     tdec6:   sta abst,x
003618  1  A9 00 48 28          set_stat 0
00361C  1  DE 03 02             dec abst,x
00361F  1  08 BD 03 02          tst_absx rINC,fINC,0
003623  1  DD 40 02 F0  
003627  1  03 20 58 44  
003636  1  BD 03 02             lda abst,x
003639  1  CA                   dex
00363A  1  30 08                bmi tdec7
00363C  1  E0 01                cpx #1
00363E  1  D0 D5                bne tdec6
003640  1  A9 81                lda #$81
003642  1  D0 D1                bne tdec6
003644  1               tdec7:
003644  1  A2 00                ldx #0
003646  1  A9 7E                lda #$7e
003648  1  9D 03 02     tinc16:  sta abst,x
00364B  1  A9 FF 48 28          set_stat $ff
00364F  1  FE 03 02             inc abst,x
003652  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
003656  1  DD 40 02 F0  
00365A  1  03 20 58 44  
003669  1  BD 03 02             lda abst,x
00366C  1  E8                   inx
00366D  1  E0 02                cpx #2
00366F  1  D0 02                bne tinc17
003671  1  A9 FE                lda #$fe
003673  1  E0 05        tinc17:  cpx #5
003675  1  D0 D1                bne tinc16
003677  1  CA                   dex
003678  1  A9 02                lda #2
00367A  1  9D 03 02     tdec16:  sta abst,x
00367D  1  A9 FF 48 28          set_stat $ff
003681  1  DE 03 02             dec abst,x
003684  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
003688  1  DD 40 02 F0  
00368C  1  03 20 58 44  
00369B  1  BD 03 02             lda abst,x
00369E  1  CA                   dex
00369F  1  30 08                bmi tdec17
0036A1  1  E0 01                cpx #1
0036A3  1  D0 D5                bne tdec16
0036A5  1  A9 81                lda #$81
0036A7  1  D0 D1                bne tdec16
0036A9  1               tdec17:
0036A9  1  AD 00 02 C9          next_test
0036AD  1  25 F0 03 20  
0036B1  1  58 44 A9 26  
0036B8  1               
0036B8  1               ; testing logical instructions - AND EOR ORA all addressing modes
0036B8  1               ; AND
0036B8  1  A2 03                ldx #3          ;immediate
0036BA  1  B5 rr        tand:    lda zpAN,x
0036BC  1  8D 09 02             sta ex_andi+1   ;set AND # operand
0036BF  1  A9 00 48 BD          set_ax  absANa,0
0036C3  1  5A 02 28     
0036C6  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
0036C9  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0036CD  1  F0 03 20 58  
0036D1  1  44 68 49 30  
0036DD  1  CA                   dex
0036DE  1  10 DA                bpl tand
0036E0  1  A2 03                ldx #3
0036E2  1  B5 rr        tand1:   lda zpAN,x
0036E4  1  8D 09 02             sta ex_andi+1   ;set AND # operand
0036E7  1  A9 FF 48 BD          set_ax  absANa,$ff
0036EB  1  5A 02 28     
0036EE  1  20 08 02             jsr ex_andi     ;execute AND # in RAM
0036F1  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0036F5  1  F0 03 20 58  
0036F9  1  44 68 49 7D  
003705  1  CA                   dex
003706  1  10 DA                bpl tand1
003708  1               
003708  1  A2 03                ldx #3      ;zp
00370A  1  B5 rr        tand2:   lda zpAN,x
00370C  1  85 rr                sta zpt
00370E  1  A9 00 48 BD          set_ax  absANa,0
003712  1  5A 02 28     
003715  1  25 rr                and zpt
003717  1  08 DD 62 02          tst_ax  absrlo,absflo,0
00371B  1  F0 03 20 58  
00371F  1  44 68 49 30  
00372B  1  CA                   dex
00372C  1  10 DC                bpl tand2
00372E  1  A2 03                ldx #3
003730  1  B5 rr        tand3:   lda zpAN,x
003732  1  85 rr                sta zpt
003734  1  A9 FF 48 BD          set_ax  absANa,$ff
003738  1  5A 02 28     
00373B  1  25 rr                and zpt
00373D  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003741  1  F0 03 20 58  
003745  1  44 68 49 7D  
003751  1  CA                   dex
003752  1  10 DC                bpl tand3
003754  1               
003754  1  A2 03                ldx #3      ;abs
003756  1  B5 rr        tand4:   lda zpAN,x
003758  1  8D 03 02             sta abst
00375B  1  A9 00 48 BD          set_ax  absANa,0
00375F  1  5A 02 28     
003762  1  2D 03 02             and abst
003765  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003769  1  F0 03 20 58  
00376D  1  44 68 49 30  
003779  1  CA                   dex
00377A  1  10 DA                bpl tand4
00377C  1  A2 03                ldx #3
00377E  1  B5 rr        tand5:   lda zpAN,x
003780  1  8D 03 02             sta abst
003783  1  A9 FF 48 BD          set_ax  absANa,$ff
003787  1  5A 02 28     
00378A  1  2D 03 02             and abst
00378D  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003791  1  F0 03 20 58  
003795  1  44 68 49 7D  
0037A1  1  CA                   dex
0037A2  1  10 02                bpl tand6
0037A4  1               
0037A4  1  A2 03                ldx #3      ;zp,x
0037A6  1               tand6:
0037A6  1  A9 00 48 BD          set_ax  absANa,0
0037AA  1  5A 02 28     
0037AD  1  35 rr                and zpAN,x
0037AF  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0037B3  1  F0 03 20 58  
0037B7  1  44 68 49 30  
0037C3  1  CA                   dex
0037C4  1  10 E0                bpl tand6
0037C6  1  A2 03                ldx #3
0037C8  1               tand7:
0037C8  1  A9 FF 48 BD          set_ax  absANa,$ff
0037CC  1  5A 02 28     
0037CF  1  35 rr                and zpAN,x
0037D1  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0037D5  1  F0 03 20 58  
0037D9  1  44 68 49 7D  
0037E5  1  CA                   dex
0037E6  1  10 E0                bpl tand7
0037E8  1               
0037E8  1  A2 03                ldx #3      ;abs,x
0037EA  1               tand8:
0037EA  1  A9 00 48 BD          set_ax  absANa,0
0037EE  1  5A 02 28     
0037F1  1  3D 4E 02             and absAN,x
0037F4  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0037F8  1  F0 03 20 58  
0037FC  1  44 68 49 30  
003808  1  CA                   dex
003809  1  10 DF                bpl tand8
00380B  1  A2 03                ldx #3
00380D  1               tand9:
00380D  1  A9 FF 48 BD          set_ax  absANa,$ff
003811  1  5A 02 28     
003814  1  3D 4E 02             and absAN,x
003817  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00381B  1  F0 03 20 58  
00381F  1  44 68 49 7D  
00382B  1  CA                   dex
00382C  1  10 DF                bpl tand9
00382E  1               
00382E  1  A0 03                ldy #3      ;abs,y
003830  1               tand10:
003830  1  A9 00 48 B9          set_ay  absANa,0
003834  1  5A 02 28     
003837  1  39 4E 02             and absAN,y
00383A  1  08 D9 62 02          tst_ay  absrlo,absflo,0
00383E  1  F0 03 20 58  
003842  1  44 68 49 30  
00384E  1  88                   dey
00384F  1  10 DF                bpl tand10
003851  1  A0 03                ldy #3
003853  1               tand11:
003853  1  A9 FF 48 B9          set_ay  absANa,$ff
003857  1  5A 02 28     
00385A  1  39 4E 02             and absAN,y
00385D  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003861  1  F0 03 20 58  
003865  1  44 68 49 7D  
003871  1  88                   dey
003872  1  10 DF                bpl tand11
003874  1               
003874  1  A2 06                ldx #6      ;(zp,x)
003876  1  A0 03                ldy #3
003878  1               tand12:
003878  1  A9 00 48 B9          set_ay  absANa,0
00387C  1  5A 02 28     
00387F  1  21 rr                and (indAN,x)
003881  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003885  1  F0 03 20 58  
003889  1  44 68 49 30  
003895  1  CA                   dex
003896  1  CA                   dex
003897  1  88                   dey
003898  1  10 DE                bpl tand12
00389A  1  A2 06                ldx #6
00389C  1  A0 03                ldy #3
00389E  1               tand13:
00389E  1  A9 FF 48 B9          set_ay  absANa,$ff
0038A2  1  5A 02 28     
0038A5  1  21 rr                and (indAN,x)
0038A7  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0038AB  1  F0 03 20 58  
0038AF  1  44 68 49 7D  
0038BB  1  CA                   dex
0038BC  1  CA                   dex
0038BD  1  88                   dey
0038BE  1  10 DE                bpl tand13
0038C0  1               
0038C0  1  A0 03                ldy #3      ;(zp),y
0038C2  1               tand14:
0038C2  1  A9 00 48 B9          set_ay  absANa,0
0038C6  1  5A 02 28     
0038C9  1  31 rr                and (indAN),y
0038CB  1  08 D9 62 02          tst_ay  absrlo,absflo,0
0038CF  1  F0 03 20 58  
0038D3  1  44 68 49 30  
0038DF  1  88                   dey
0038E0  1  10 E0                bpl tand14
0038E2  1  A0 03                ldy #3
0038E4  1               tand15:
0038E4  1  A9 FF 48 B9          set_ay  absANa,$ff
0038E8  1  5A 02 28     
0038EB  1  31 rr                and (indAN),y
0038ED  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
0038F1  1  F0 03 20 58  
0038F5  1  44 68 49 7D  
003901  1  88                   dey
003902  1  10 E0                bpl tand15
003904  1  AD 00 02 C9          next_test
003908  1  26 F0 03 20  
00390C  1  58 44 A9 27  
003913  1               
003913  1               ; EOR
003913  1  A2 03                ldx #3          ;immediate - self modifying code
003915  1  B5 rr        teor:    lda zpEO,x
003917  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
00391A  1  A9 00 48 BD          set_ax  absEOa,0
00391E  1  5E 02 28     
003921  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
003924  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003928  1  F0 03 20 58  
00392C  1  44 68 49 30  
003938  1  CA                   dex
003939  1  10 DA                bpl teor
00393B  1  A2 03                ldx #3
00393D  1  B5 rr        teor1:   lda zpEO,x
00393F  1  8D 0C 02             sta ex_eori+1   ;set EOR # operand
003942  1  A9 FF 48 BD          set_ax  absEOa,$ff
003946  1  5E 02 28     
003949  1  20 0B 02             jsr ex_eori     ;execute EOR # in RAM
00394C  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003950  1  F0 03 20 58  
003954  1  44 68 49 7D  
003960  1  CA                   dex
003961  1  10 DA                bpl teor1
003963  1               
003963  1  A2 03                ldx #3      ;zp
003965  1  B5 rr        teor2:    lda zpEO,x
003967  1  85 rr                sta zpt
003969  1  A9 00 48 BD          set_ax  absEOa,0
00396D  1  5E 02 28     
003970  1  45 rr                eor zpt
003972  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003976  1  F0 03 20 58  
00397A  1  44 68 49 30  
003986  1  CA                   dex
003987  1  10 DC                bpl teor2
003989  1  A2 03                ldx #3
00398B  1  B5 rr        teor3:   lda zpEO,x
00398D  1  85 rr                sta zpt
00398F  1  A9 FF 48 BD          set_ax  absEOa,$ff
003993  1  5E 02 28     
003996  1  45 rr                eor zpt
003998  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
00399C  1  F0 03 20 58  
0039A0  1  44 68 49 7D  
0039AC  1  CA                   dex
0039AD  1  10 DC                bpl teor3
0039AF  1               
0039AF  1  A2 03                ldx #3      ;abs
0039B1  1  B5 rr        teor4:   lda zpEO,x
0039B3  1  8D 03 02             sta abst
0039B6  1  A9 00 48 BD          set_ax  absEOa,0
0039BA  1  5E 02 28     
0039BD  1  4D 03 02             eor abst
0039C0  1  08 DD 62 02          tst_ax  absrlo,absflo,0
0039C4  1  F0 03 20 58  
0039C8  1  44 68 49 30  
0039D4  1  CA                   dex
0039D5  1  10 DA                bpl teor4
0039D7  1  A2 03                ldx #3
0039D9  1  B5 rr        teor5:   lda zpEO,x
0039DB  1  8D 03 02             sta abst
0039DE  1  A9 FF 48 BD          set_ax  absEOa,$ff
0039E2  1  5E 02 28     
0039E5  1  4D 03 02             eor abst
0039E8  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
0039EC  1  F0 03 20 58  
0039F0  1  44 68 49 7D  
0039FC  1  CA                   dex
0039FD  1  10 02                bpl teor6
0039FF  1               
0039FF  1  A2 03                ldx #3      ;zp,x
003A01  1               teor6:
003A01  1  A9 00 48 BD          set_ax  absEOa,0
003A05  1  5E 02 28     
003A08  1  55 rr                eor zpEO,x
003A0A  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003A0E  1  F0 03 20 58  
003A12  1  44 68 49 30  
003A1E  1  CA                   dex
003A1F  1  10 E0                bpl teor6
003A21  1  A2 03                ldx #3
003A23  1               teor7:
003A23  1  A9 FF 48 BD          set_ax  absEOa,$ff
003A27  1  5E 02 28     
003A2A  1  55 rr                eor zpEO,x
003A2C  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003A30  1  F0 03 20 58  
003A34  1  44 68 49 7D  
003A40  1  CA                   dex
003A41  1  10 E0                bpl teor7
003A43  1               
003A43  1  A2 03                ldx #3      ;abs,x
003A45  1               teor8:
003A45  1  A9 00 48 BD          set_ax  absEOa,0
003A49  1  5E 02 28     
003A4C  1  5D 52 02             eor absEO,x
003A4F  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003A53  1  F0 03 20 58  
003A57  1  44 68 49 30  
003A63  1  CA                   dex
003A64  1  10 DF                bpl teor8
003A66  1  A2 03                ldx #3
003A68  1               teor9:
003A68  1  A9 FF 48 BD          set_ax  absEOa,$ff
003A6C  1  5E 02 28     
003A6F  1  5D 52 02             eor absEO,x
003A72  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003A76  1  F0 03 20 58  
003A7A  1  44 68 49 7D  
003A86  1  CA                   dex
003A87  1  10 DF                bpl teor9
003A89  1               
003A89  1  A0 03                ldy #3      ;abs,y
003A8B  1               teor10:
003A8B  1  A9 00 48 B9          set_ay  absEOa,0
003A8F  1  5E 02 28     
003A92  1  59 52 02             eor absEO,y
003A95  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003A99  1  F0 03 20 58  
003A9D  1  44 68 49 30  
003AA9  1  88                   dey
003AAA  1  10 DF                bpl teor10
003AAC  1  A0 03                ldy #3
003AAE  1               teor11:
003AAE  1  A9 FF 48 B9          set_ay  absEOa,$ff
003AB2  1  5E 02 28     
003AB5  1  59 52 02             eor absEO,y
003AB8  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003ABC  1  F0 03 20 58  
003AC0  1  44 68 49 7D  
003ACC  1  88                   dey
003ACD  1  10 DF                bpl teor11
003ACF  1               
003ACF  1  A2 06                ldx #6      ;(zp,x)
003AD1  1  A0 03                ldy #3
003AD3  1               teor12:
003AD3  1  A9 00 48 B9          set_ay  absEOa,0
003AD7  1  5E 02 28     
003ADA  1  41 rr                eor (indEO,x)
003ADC  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003AE0  1  F0 03 20 58  
003AE4  1  44 68 49 30  
003AF0  1  CA                   dex
003AF1  1  CA                   dex
003AF2  1  88                   dey
003AF3  1  10 DE                bpl teor12
003AF5  1  A2 06                ldx #6
003AF7  1  A0 03                ldy #3
003AF9  1               teor13:
003AF9  1  A9 FF 48 B9          set_ay  absEOa,$ff
003AFD  1  5E 02 28     
003B00  1  41 rr                eor (indEO,x)
003B02  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003B06  1  F0 03 20 58  
003B0A  1  44 68 49 7D  
003B16  1  CA                   dex
003B17  1  CA                   dex
003B18  1  88                   dey
003B19  1  10 DE                bpl teor13
003B1B  1               
003B1B  1  A0 03                ldy #3      ;(zp),y
003B1D  1               teor14:
003B1D  1  A9 00 48 B9          set_ay  absEOa,0
003B21  1  5E 02 28     
003B24  1  51 rr                eor (indEO),y
003B26  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003B2A  1  F0 03 20 58  
003B2E  1  44 68 49 30  
003B3A  1  88                   dey
003B3B  1  10 E0                bpl teor14
003B3D  1  A0 03                ldy #3
003B3F  1               teor15:
003B3F  1  A9 FF 48 B9          set_ay  absEOa,$ff
003B43  1  5E 02 28     
003B46  1  51 rr                eor (indEO),y
003B48  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003B4C  1  F0 03 20 58  
003B50  1  44 68 49 7D  
003B5C  1  88                   dey
003B5D  1  10 E0                bpl teor15
003B5F  1  AD 00 02 C9          next_test
003B63  1  27 F0 03 20  
003B67  1  58 44 A9 28  
003B6E  1               
003B6E  1               ; OR
003B6E  1  A2 03                ldx #3          ;immediate - self modifying code
003B70  1  B5 rr        tora:    lda zpOR,x
003B72  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
003B75  1  A9 00 48 BD          set_ax  absORa,0
003B79  1  56 02 28     
003B7C  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003B7F  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003B83  1  F0 03 20 58  
003B87  1  44 68 49 30  
003B93  1  CA                   dex
003B94  1  10 DA                bpl tora
003B96  1  A2 03                ldx #3
003B98  1  B5 rr        tora1:   lda zpOR,x
003B9A  1  8D 0F 02             sta ex_orai+1   ;set ORA # operand
003B9D  1  A9 FF 48 BD          set_ax  absORa,$ff
003BA1  1  56 02 28     
003BA4  1  20 0E 02             jsr ex_orai     ;execute ORA # in RAM
003BA7  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003BAB  1  F0 03 20 58  
003BAF  1  44 68 49 7D  
003BBB  1  CA                   dex
003BBC  1  10 DA                bpl tora1
003BBE  1               
003BBE  1  A2 03                ldx #3      ;zp
003BC0  1  B5 rr        tora2:   lda zpOR,x
003BC2  1  85 rr                sta zpt
003BC4  1  A9 00 48 BD          set_ax  absORa,0
003BC8  1  56 02 28     
003BCB  1  05 rr                ora zpt
003BCD  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003BD1  1  F0 03 20 58  
003BD5  1  44 68 49 30  
003BE1  1  CA                   dex
003BE2  1  10 DC                bpl tora2
003BE4  1  A2 03                ldx #3
003BE6  1  B5 rr        tora3:   lda zpOR,x
003BE8  1  85 rr                sta zpt
003BEA  1  A9 FF 48 BD          set_ax  absORa,$ff
003BEE  1  56 02 28     
003BF1  1  05 rr                ora zpt
003BF3  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003BF7  1  F0 03 20 58  
003BFB  1  44 68 49 7D  
003C07  1  CA                   dex
003C08  1  10 DC                bpl tora3
003C0A  1               
003C0A  1  A2 03                ldx #3      ;abs
003C0C  1  B5 rr        tora4:   lda zpOR,x
003C0E  1  8D 03 02             sta abst
003C11  1  A9 00 48 BD          set_ax  absORa,0
003C15  1  56 02 28     
003C18  1  0D 03 02             ora abst
003C1B  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003C1F  1  F0 03 20 58  
003C23  1  44 68 49 30  
003C2F  1  CA                   dex
003C30  1  10 DA                bpl tora4
003C32  1  A2 03                ldx #3
003C34  1  B5 rr        tora5:   lda zpOR,x
003C36  1  8D 03 02             sta abst
003C39  1  A9 FF 48 BD          set_ax  absORa,$ff
003C3D  1  56 02 28     
003C40  1  0D 03 02             ora abst
003C43  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003C47  1  F0 03 20 58  
003C4B  1  44 68 49 7D  
003C57  1  CA                   dex
003C58  1  10 02                bpl tora6
003C5A  1               
003C5A  1  A2 03                ldx #3      ;zp,x
003C5C  1               tora6:
003C5C  1  A9 00 48 BD          set_ax  absORa,0
003C60  1  56 02 28     
003C63  1  15 rr                ora zpOR,x
003C65  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003C69  1  F0 03 20 58  
003C6D  1  44 68 49 30  
003C79  1  CA                   dex
003C7A  1  10 E0                bpl tora6
003C7C  1  A2 03                ldx #3
003C7E  1               tora7:
003C7E  1  A9 FF 48 BD          set_ax  absORa,$ff
003C82  1  56 02 28     
003C85  1  15 rr                ora zpOR,x
003C87  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003C8B  1  F0 03 20 58  
003C8F  1  44 68 49 7D  
003C9B  1  CA                   dex
003C9C  1  10 E0                bpl tora7
003C9E  1               
003C9E  1  A2 03                ldx #3      ;abs,x
003CA0  1               tora8:
003CA0  1  A9 00 48 BD          set_ax  absORa,0
003CA4  1  56 02 28     
003CA7  1  1D 4A 02             ora absOR,x
003CAA  1  08 DD 62 02          tst_ax  absrlo,absflo,0
003CAE  1  F0 03 20 58  
003CB2  1  44 68 49 30  
003CBE  1  CA                   dex
003CBF  1  10 DF                bpl tora8
003CC1  1  A2 03                ldx #3
003CC3  1               tora9:
003CC3  1  A9 FF 48 BD          set_ax  absORa,$ff
003CC7  1  56 02 28     
003CCA  1  1D 4A 02             ora absOR,x
003CCD  1  08 DD 62 02          tst_ax  absrlo,absflo,$ff-fnz
003CD1  1  F0 03 20 58  
003CD5  1  44 68 49 7D  
003CE1  1  CA                   dex
003CE2  1  10 DF                bpl tora9
003CE4  1               
003CE4  1  A0 03                ldy #3      ;abs,y
003CE6  1               tora10:
003CE6  1  A9 00 48 B9          set_ay  absORa,0
003CEA  1  56 02 28     
003CED  1  19 4A 02             ora absOR,y
003CF0  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003CF4  1  F0 03 20 58  
003CF8  1  44 68 49 30  
003D04  1  88                   dey
003D05  1  10 DF                bpl tora10
003D07  1  A0 03                ldy #3
003D09  1               tora11:
003D09  1  A9 FF 48 B9          set_ay  absORa,$ff
003D0D  1  56 02 28     
003D10  1  19 4A 02             ora absOR,y
003D13  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003D17  1  F0 03 20 58  
003D1B  1  44 68 49 7D  
003D27  1  88                   dey
003D28  1  10 DF                bpl tora11
003D2A  1               
003D2A  1  A2 06                ldx #6      ;(zp,x)
003D2C  1  A0 03                ldy #3
003D2E  1               tora12:
003D2E  1  A9 00 48 B9          set_ay  absORa,0
003D32  1  56 02 28     
003D35  1  01 rr                ora (indOR,x)
003D37  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003D3B  1  F0 03 20 58  
003D3F  1  44 68 49 30  
003D4B  1  CA                   dex
003D4C  1  CA                   dex
003D4D  1  88                   dey
003D4E  1  10 DE                bpl tora12
003D50  1  A2 06                ldx #6
003D52  1  A0 03                ldy #3
003D54  1               tora13:
003D54  1  A9 FF 48 B9          set_ay  absORa,$ff
003D58  1  56 02 28     
003D5B  1  01 rr                ora (indOR,x)
003D5D  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003D61  1  F0 03 20 58  
003D65  1  44 68 49 7D  
003D71  1  CA                   dex
003D72  1  CA                   dex
003D73  1  88                   dey
003D74  1  10 DE                bpl tora13
003D76  1               
003D76  1  A0 03                ldy #3      ;(zp),y
003D78  1               tora14:
003D78  1  A9 00 48 B9          set_ay  absORa,0
003D7C  1  56 02 28     
003D7F  1  11 rr                ora (indOR),y
003D81  1  08 D9 62 02          tst_ay  absrlo,absflo,0
003D85  1  F0 03 20 58  
003D89  1  44 68 49 30  
003D95  1  88                   dey
003D96  1  10 E0                bpl tora14
003D98  1  A0 03                ldy #3
003D9A  1               tora15:
003D9A  1  A9 FF 48 B9          set_ay  absORa,$ff
003D9E  1  56 02 28     
003DA1  1  11 rr                ora (indOR),y
003DA3  1  08 D9 62 02          tst_ay  absrlo,absflo,$ff-fnz
003DA7  1  F0 03 20 58  
003DAB  1  44 68 49 7D  
003DB7  1  88                   dey
003DB8  1  10 E0                bpl tora15
003DBA  1               .if I_flag = 3
003DBA  1  58                   cli
003DBB  1               .endif
003DBB  1  AD 00 02 C9          next_test
003DBF  1  28 F0 03 20  
003DC3  1  58 44 A9 29  
003DCA  1               
003DCA  1               ; full binary add/subtract test
003DCA  1               ; iterates through all combinations of operands and carry input
003DCA  1               ; uses increments/decrements to predict result & result flags
003DCA  1  D8                   cld
003DCB  1  A2 rr                ldx #ad2        ;for indexed test
003DCD  1  A0 FF                ldy #$ff        ;max range
003DCF  1  A9 00                lda #0          ;start with adding zeroes & no carry
003DD1  1  85 rr                sta adfc        ;carry in - for diag
003DD3  1  85 rr                sta ad1         ;operand 1 - accumulator
003DD5  1  85 rr                sta ad2         ;operand 2 - memory or immediate
003DD7  1  8D 03 02             sta ada2        ;non zp
003DDA  1  85 rr                sta adrl        ;expected result bits 0-7
003DDC  1  85 rr                sta adrh        ;expected result bit 8 (carry out)
003DDE  1  A9 FF                lda #$ff        ;complemented operand 2 for subtract
003DE0  1  85 rr                sta sb2
003DE2  1  8D 04 02             sta sba2        ;non zp
003DE5  1  A9 02                lda #2          ;expected Z-flag
003DE7  1  85 rr                sta adrf
003DE9  1  18           tadd:    clc             ;test with carry clear
003DEA  1  20 DF 40             jsr chkadd
003DED  1  E6 rr                inc adfc        ;now with carry
003DEF  1  E6 rr                inc adrl        ;result +1
003DF1  1  08                   php             ;save N & Z from low result
003DF2  1  08                   php
003DF3  1  68                   pla             ;accu holds expected flags
003DF4  1  29 82                and #$82        ;mask N & Z
003DF6  1  28                   plp
003DF7  1  D0 02                bne tadd1
003DF9  1  E6 rr                inc adrh        ;result bit 8 - carry
003DFB  1  05 rr        tadd1:   ora adrh        ;merge C to expected flags
003DFD  1  85 rr                sta adrf        ;save expected flags except overflow
003DFF  1  38                   sec             ;test with carry set
003E00  1  20 DF 40             jsr chkadd
003E03  1  C6 rr                dec adfc        ;same for operand +1 but no carry
003E05  1  E6 rr                inc ad1
003E07  1  D0 E0                bne tadd        ;iterate op1
003E09  1  A9 00                lda #0          ;preset result to op2 when op1 = 0
003E0B  1  85 rr                sta adrh
003E0D  1  EE 03 02             inc ada2
003E10  1  E6 rr                inc ad2
003E12  1  08                   php             ;save NZ as operand 2 becomes the new result
003E13  1  68                   pla
003E14  1  29 82                and #$82        ;mask N00000Z0
003E16  1  85 rr                sta adrf        ;no need to check carry as we are adding to 0
003E18  1  C6 rr                dec sb2         ;complement subtract operand 2
003E1A  1  CE 04 02             dec sba2
003E1D  1  A5 rr                lda ad2
003E1F  1  85 rr                sta adrl
003E21  1  D0 C6                bne tadd        ;iterate op2
003E23  1               .if disable_decimal < 1
003E23  1  AD 00 02 C9          next_test
003E27  1  29 F0 03 20  
003E2B  1  58 44 A9 2A  
003E32  1               
003E32  1               ; decimal add/subtract test
003E32  1               ; *** WARNING - tests documented behavior only! ***
003E32  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003E32  1               ; iterates through all valid combinations of operands and carry input
003E32  1               ; uses increments/decrements to predict result & carry flag
003E32  1  F8                   sed
003E33  1  A2 rr                ldx #ad2        ;for indexed test
003E35  1  A0 FF                ldy #$ff        ;max range
003E37  1  A9 99                lda #$99        ;start with adding 99 to 99 with carry
003E39  1  85 rr                sta ad1         ;operand 1 - accumulator
003E3B  1  85 rr                sta ad2         ;operand 2 - memory or immediate
003E3D  1  8D 03 02             sta ada2        ;non zp
003E40  1  85 rr                sta adrl        ;expected result bits 0-7
003E42  1  A9 01                lda #1          ;set carry in & out
003E44  1  85 rr                sta adfc        ;carry in - for diag
003E46  1  85 rr                sta adrh        ;expected result bit 8 (carry out)
003E48  1  A9 00                lda #0          ;complemented operand 2 for subtract
003E4A  1  85 rr                sta sb2
003E4C  1  8D 04 02             sta sba2        ;non zp
003E4F  1  38           tdad:    sec             ;test with carry set
003E50  1  20 4C 3F             jsr chkdad
003E53  1  C6 rr                dec adfc        ;now with carry clear
003E55  1  A5 rr                lda adrl        ;decimal adjust result
003E57  1  D0 08                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
003E59  1  C6 rr                dec adrh
003E5B  1  A9 99                lda #$99
003E5D  1  85 rr                sta adrl
003E5F  1  D0 12                bne tdad3
003E61  1  29 0F        tdad1:   and #$f         ;lower nibble mask
003E63  1  D0 0C                bne tdad2       ;no decimal adjust needed
003E65  1  C6 rr                dec adrl        ;decimal adjust (?0-6)
003E67  1  C6 rr                dec adrl
003E69  1  C6 rr                dec adrl
003E6B  1  C6 rr                dec adrl
003E6D  1  C6 rr                dec adrl
003E6F  1  C6 rr                dec adrl
003E71  1  C6 rr        tdad2:   dec adrl        ;result -1
003E73  1  18           tdad3:   clc             ;test with carry clear
003E74  1  20 4C 3F             jsr chkdad
003E77  1  E6 rr                inc adfc        ;same for operand -1 but with carry
003E79  1  A5 rr                lda ad1         ;decimal adjust operand 1
003E7B  1  F0 15                beq tdad5       ;iterate operand 2
003E7D  1  29 0F                and #$f         ;lower nibble mask
003E7F  1  D0 0C                bne tdad4       ;skip decimal adjust
003E81  1  C6 rr                dec ad1         ;decimal adjust (?0-6)
003E83  1  C6 rr                dec ad1
003E85  1  C6 rr                dec ad1
003E87  1  C6 rr                dec ad1
003E89  1  C6 rr                dec ad1
003E8B  1  C6 rr                dec ad1
003E8D  1  C6 rr        tdad4:   dec ad1         ;operand 1 -1
003E8F  1  4C 4F 3E             jmp tdad        ;iterate op1
003E92  1               
003E92  1  A9 99        tdad5:   lda #$99        ;precharge op1 max
003E94  1  85 rr                sta ad1
003E96  1  A5 rr                lda ad2         ;decimal adjust operand 2
003E98  1  F0 30                beq tdad7       ;end of iteration
003E9A  1  29 0F                and #$f         ;lower nibble mask
003E9C  1  D0 18                bne tdad6       ;skip decimal adjust
003E9E  1  C6 rr                dec ad2         ;decimal adjust (?0-6)
003EA0  1  C6 rr                dec ad2
003EA2  1  C6 rr                dec ad2
003EA4  1  C6 rr                dec ad2
003EA6  1  C6 rr                dec ad2
003EA8  1  C6 rr                dec ad2
003EAA  1  E6 rr                inc sb2         ;complemented decimal adjust for subtract (?9+6)
003EAC  1  E6 rr                inc sb2
003EAE  1  E6 rr                inc sb2
003EB0  1  E6 rr                inc sb2
003EB2  1  E6 rr                inc sb2
003EB4  1  E6 rr                inc sb2
003EB6  1  C6 rr        tdad6:   dec ad2         ;operand 2 -1
003EB8  1  E6 rr                inc sb2         ;complemented operand for subtract
003EBA  1  A5 rr                lda sb2
003EBC  1  8D 04 02             sta sba2        ;copy as non zp operand
003EBF  1  A5 rr                lda ad2
003EC1  1  8D 03 02             sta ada2        ;copy as non zp operand
003EC4  1  85 rr                sta adrl        ;new result since op1+carry=00+carry +op2=op2
003EC6  1  E6 rr                inc adrh        ;result carry
003EC8  1  D0 85                bne tdad        ;iterate op2
003ECA  1               tdad7:
003ECA  1  AD 00 02 C9          next_test
003ECE  1  2A F0 03 20  
003ED2  1  58 44 A9 2B  
003ED9  1               
003ED9  1               ; decimal/binary switch test
003ED9  1               ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
003ED9  1               ;   tables
003ED9  1  18                   clc
003EDA  1  D8                   cld
003EDB  1  08                   php
003EDC  1  A9 55                lda #$55
003EDE  1  69 55                adc #$55
003EE0  1  C9 AA                cmp #$aa
003EE2  1  F0 03 20 58          trap_ne         ;expected binary result after cld
003EE6  1  44           
003EE7  1  18                   clc
003EE8  1  F8                   sed
003EE9  1  08                   php
003EEA  1  A9 55                lda #$55
003EEC  1  69 55                adc #$55
003EEE  1  C9 10                cmp #$10
003EF0  1  F0 03 20 58          trap_ne         ;expected decimal result after sed
003EF4  1  44           
003EF5  1  D8                   cld
003EF6  1  28                   plp
003EF7  1  A9 55                lda #$55
003EF9  1  69 55                adc #$55
003EFB  1  C9 10                cmp #$10
003EFD  1  F0 03 20 58          trap_ne         ;expected decimal result after plp D=1
003F01  1  44           
003F02  1  28                   plp
003F03  1  A9 55                lda #$55
003F05  1  69 55                adc #$55
003F07  1  C9 AA                cmp #$aa
003F09  1  F0 03 20 58          trap_ne         ;expected binary result after plp D=0
003F0D  1  44           
003F0E  1  18                   clc
003F0F  1  A9 3F                lda #> bin_rti_ret ;emulated interrupt for rti
003F11  1  48                   pha
003F12  1  A9 2C                lda #< bin_rti_ret
003F14  1  48                   pha
003F15  1  08                   php
003F16  1  F8                   sed
003F17  1  A9 3F                lda #> dec_rti_ret ;emulated interrupt for rti
003F19  1  48                   pha
003F1A  1  A9 20                lda #< dec_rti_ret
003F1C  1  48                   pha
003F1D  1  08                   php
003F1E  1  D8                   cld
003F1F  1  40                   rti
003F20  1               dec_rti_ret:
003F20  1  A9 55                lda #$55
003F22  1  69 55                adc #$55
003F24  1  C9 10                cmp #$10
003F26  1  F0 03 20 58          trap_ne         ;expected decimal result after rti D=1
003F2A  1  44           
003F2B  1  40                   rti
003F2C  1               bin_rti_ret:
003F2C  1  A9 55                lda #$55
003F2E  1  69 55                adc #$55
003F30  1  C9 AA                cmp #$aa
003F32  1  F0 03 20 58          trap_ne         ;expected binary result after rti D=0
003F36  1  44           
003F37  1               .endif
003F37  1               
003F37  1  AD 00 02             lda test_case
003F3A  1  C9 2B                cmp #test_num
003F3C  1  F0 03 20 58          trap_ne         ;previous test is out of s:=ence
003F40  1  44           
003F41  1  A9 F0                lda #$f0        ;mark opcode testing complete
003F43  1  8D 00 02             sta test_case
003F46  1               
003F46  1               ; final RAM integrity test
003F46  1               ;   verifies that none of the previous tests has altered RAM outside of the
003F46  1               ;   designated write areas.
003F46  1                       check_ram
003F46  1               ; *** DEBUG INFO ***
003F46  1               ; to debug checksum errors uncomment check_ram in the next_test macro to
003F46  1               ; narrow down the responsible opcode.
003F46  1               ; may give false errors when monitor, OS or other background activity is
003F46  1               ; allowed during previous tests.
003F46  1               
003F46  1               
003F46  1               ; S U C C E S S ************************************************
003F46  1               ; -------------
003F46  1  20 21 45             success         ;if you get here everything went well
003F49  1               ; -------------
003F49  1               ; S U C C E S S ************************************************
003F49  1  4C 00 04             jmp start       ;run again
003F4C  1               .if disable_decimal < 1
003F4C  1               ; core subroutine of the decimal add/subtract test
003F4C  1               ; *** WARNING - tests documented behavior only! ***
003F4C  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003F4C  1               ; iterates through all valid combinations of operands and carry input
003F4C  1               ; uses increments/decrements to predict result & carry flag
003F4C  1               chkdad:
003F4C  1               ; decimal ADC / SBC zp
003F4C  1  08                   php             ;save carry for subtract
003F4D  1  A5 rr                lda ad1
003F4F  1  65 rr                adc ad2         ;perform add
003F51  1  08                   php
003F52  1  C5 rr                cmp adrl        ;check result
003F54  1  F0 03 20 58          trap_ne         ;bad result
003F58  1  44           
003F59  1  68                   pla             ;check flags
003F5A  1  29 01                and #1          ;mask carry
003F5C  1  C5 rr                cmp adrh
003F5E  1  F0 03 20 58          trap_ne         ;bad carry
003F62  1  44           
003F63  1  28                   plp
003F64  1  08                   php             ;save carry for next add
003F65  1  A5 rr                lda ad1
003F67  1  E5 rr                sbc sb2         ;perform subtract
003F69  1  08                   php
003F6A  1  C5 rr                cmp adrl        ;check result
003F6C  1  F0 03 20 58          trap_ne         ;bad result
003F70  1  44           
003F71  1  68                   pla             ;check flags
003F72  1  29 01                and #1          ;mask carry
003F74  1  C5 rr                cmp adrh
003F76  1  F0 03 20 58          trap_ne         ;bad flags
003F7A  1  44           
003F7B  1  28                   plp
003F7C  1               ; decimal ADC / SBC abs
003F7C  1  08                   php             ;save carry for subtract
003F7D  1  A5 rr                lda ad1
003F7F  1  6D 03 02             adc ada2        ;perform add
003F82  1  08                   php
003F83  1  C5 rr                cmp adrl        ;check result
003F85  1  F0 03 20 58          trap_ne         ;bad result
003F89  1  44           
003F8A  1  68                   pla             ;check flags
003F8B  1  29 01                and #1          ;mask carry
003F8D  1  C5 rr                cmp adrh
003F8F  1  F0 03 20 58          trap_ne         ;bad carry
003F93  1  44           
003F94  1  28                   plp
003F95  1  08                   php             ;save carry for next add
003F96  1  A5 rr                lda ad1
003F98  1  ED 04 02             sbc sba2        ;perform subtract
003F9B  1  08                   php
003F9C  1  C5 rr                cmp adrl        ;check result
003F9E  1  F0 03 20 58          trap_ne         ;bad result
003FA2  1  44           
003FA3  1  68                   pla             ;check flags
003FA4  1  29 01                and #1          ;mask carry
003FA6  1  C5 rr                cmp adrh
003FA8  1  F0 03 20 58          trap_ne         ;bad carry
003FAC  1  44           
003FAD  1  28                   plp
003FAE  1               ; decimal ADC / SBC #
003FAE  1  08                   php             ;save carry for subtract
003FAF  1  A5 rr                lda ad2
003FB1  1  8D 12 02             sta ex_adci+1   ;set ADC # operand
003FB4  1  A5 rr                lda ad1
003FB6  1  20 11 02             jsr ex_adci     ;execute ADC # in RAM
003FB9  1  08                   php
003FBA  1  C5 rr                cmp adrl        ;check result
003FBC  1  F0 03 20 58          trap_ne         ;bad result
003FC0  1  44           
003FC1  1  68                   pla             ;check flags
003FC2  1  29 01                and #1          ;mask carry
003FC4  1  C5 rr                cmp adrh
003FC6  1  F0 03 20 58          trap_ne         ;bad carry
003FCA  1  44           
003FCB  1  28                   plp
003FCC  1  08                   php             ;save carry for next add
003FCD  1  A5 rr                lda sb2
003FCF  1  8D 15 02             sta ex_sbci+1   ;set SBC # operand
003FD2  1  A5 rr                lda ad1
003FD4  1  20 14 02             jsr ex_sbci     ;execute SBC # in RAM
003FD7  1  08                   php
003FD8  1  C5 rr                cmp adrl        ;check result
003FDA  1  F0 03 20 58          trap_ne         ;bad result
003FDE  1  44           
003FDF  1  68                   pla             ;check flags
003FE0  1  29 01                and #1          ;mask carry
003FE2  1  C5 rr                cmp adrh
003FE4  1  F0 03 20 58          trap_ne         ;bad carry
003FE8  1  44           
003FE9  1  28                   plp
003FEA  1               ; decimal ADC / SBC zp,x
003FEA  1  08                   php             ;save carry for subtract
003FEB  1  A5 rr                lda ad1
003FED  1  75 00                adc 0,x         ;perform add
003FEF  1  08                   php
003FF0  1  C5 rr                cmp adrl        ;check result
003FF2  1  F0 03 20 58          trap_ne         ;bad result
003FF6  1  44           
003FF7  1  68                   pla             ;check flags
003FF8  1  29 01                and #1          ;mask carry
003FFA  1  C5 rr                cmp adrh
003FFC  1  F0 03 20 58          trap_ne         ;bad carry
004000  1  44           
004001  1  28                   plp
004002  1  08                   php             ;save carry for next add
004003  1  A5 rr                lda ad1
004005  1  F5 04                sbc sb2-ad2,x   ;perform subtract
004007  1  08                   php
004008  1  C5 rr                cmp adrl        ;check result
00400A  1  F0 03 20 58          trap_ne         ;bad result
00400E  1  44           
00400F  1  68                   pla             ;check flags
004010  1  29 01                and #1          ;mask carry
004012  1  C5 rr                cmp adrh
004014  1  F0 03 20 58          trap_ne         ;bad carry
004018  1  44           
004019  1  28                   plp
00401A  1               ; decimal ADC / SBC abs,x
00401A  1  08                   php             ;save carry for subtract
00401B  1  A5 rr                lda ad1
00401D  1  7D rr rr             adc a:ada2-ad2,x  ;perform add
004020  1  08                   php
004021  1  C5 rr                cmp adrl        ;check result
004023  1  F0 03 20 58          trap_ne         ;bad result
004027  1  44           
004028  1  68                   pla             ;check flags
004029  1  29 01                and #1          ;mask carry
00402B  1  C5 rr                cmp adrh
00402D  1  F0 03 20 58          trap_ne         ;bad carry
004031  1  44           
004032  1  28                   plp
004033  1  08                   php             ;save carry for next add
004034  1  A5 rr                lda ad1
004036  1  FD rr rr             sbc a:sba2-ad2,x  ;perform subtract
004039  1  08                   php
00403A  1  C5 rr                cmp adrl        ;check result
00403C  1  F0 03 20 58          trap_ne         ;bad result
004040  1  44           
004041  1  68                   pla             ;check flags
004042  1  29 01                and #1          ;mask carry
004044  1  C5 rr                cmp adrh
004046  1  F0 03 20 58          trap_ne         ;bad carry
00404A  1  44           
00404B  1  28                   plp
00404C  1               ; decimal ADC / SBC abs,y
00404C  1  08                   php             ;save carry for subtract
00404D  1  A5 rr                lda ad1
00404F  1  79 04 01             adc ada2-$ff,y  ;perform add
004052  1  08                   php
004053  1  C5 rr                cmp adrl        ;check result
004055  1  F0 03 20 58          trap_ne         ;bad result
004059  1  44           
00405A  1  68                   pla             ;check flags
00405B  1  29 01                and #1          ;mask carry
00405D  1  C5 rr                cmp adrh
00405F  1  F0 03 20 58          trap_ne         ;bad carry
004063  1  44           
004064  1  28                   plp
004065  1  08                   php             ;save carry for next add
004066  1  A5 rr                lda ad1
004068  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
00406B  1  08                   php
00406C  1  C5 rr                cmp adrl        ;check result
00406E  1  F0 03 20 58          trap_ne         ;bad result
004072  1  44           
004073  1  68                   pla             ;check flags
004074  1  29 01                and #1          ;mask carry
004076  1  C5 rr                cmp adrh
004078  1  F0 03 20 58          trap_ne         ;bad carry
00407C  1  44           
00407D  1  28                   plp
00407E  1               ; decimal ADC / SBC (zp,x)
00407E  1  08                   php             ;save carry for subtract
00407F  1  A5 rr                lda ad1
004081  1  61 rr                adc (< adi2-ad2,x) ;perform add
004083  1  08                   php
004084  1  C5 rr                cmp adrl        ;check result
004086  1  F0 03 20 58          trap_ne         ;bad result
00408A  1  44           
00408B  1  68                   pla             ;check flags
00408C  1  29 01                and #1          ;mask carry
00408E  1  C5 rr                cmp adrh
004090  1  F0 03 20 58          trap_ne         ;bad carry
004094  1  44           
004095  1  28                   plp
004096  1  08                   php             ;save carry for next add
004097  1  A5 rr                lda ad1
004099  1  E1 rr                sbc (< sbi2-ad2,x) ;perform subtract
00409B  1  08                   php
00409C  1  C5 rr                cmp adrl        ;check result
00409E  1  F0 03 20 58          trap_ne         ;bad result
0040A2  1  44           
0040A3  1  68                   pla             ;check flags
0040A4  1  29 01                and #1          ;mask carry
0040A6  1  C5 rr                cmp adrh
0040A8  1  F0 03 20 58          trap_ne         ;bad carry
0040AC  1  44           
0040AD  1  28                   plp
0040AE  1               ; decimal ADC / SBC (abs),y
0040AE  1  08                   php             ;save carry for subtract
0040AF  1  A5 rr                lda ad1
0040B1  1  71 rr                adc (adiy2),y   ;perform add
0040B3  1  08                   php
0040B4  1  C5 rr                cmp adrl        ;check result
0040B6  1  F0 03 20 58          trap_ne         ;bad result
0040BA  1  44           
0040BB  1  68                   pla             ;check flags
0040BC  1  29 01                and #1          ;mask carry
0040BE  1  C5 rr                cmp adrh
0040C0  1  F0 03 20 58          trap_ne         ;bad carry
0040C4  1  44           
0040C5  1  28                   plp
0040C6  1  08                   php             ;save carry for next add
0040C7  1  A5 rr                lda ad1
0040C9  1  F1 rr                sbc (sbiy2),y   ;perform subtract
0040CB  1  08                   php
0040CC  1  C5 rr                cmp adrl        ;check result
0040CE  1  F0 03 20 58          trap_ne         ;bad result
0040D2  1  44           
0040D3  1  68                   pla             ;check flags
0040D4  1  29 01                and #1          ;mask carry
0040D6  1  C5 rr                cmp adrh
0040D8  1  F0 03 20 58          trap_ne         ;bad carry
0040DC  1  44           
0040DD  1  28                   plp
0040DE  1  60                   rts
0040DF  1               .endif
0040DF  1               
0040DF  1               ; core subroutine of the full binary add/subtract test
0040DF  1               ; iterates through all combinations of operands and carry input
0040DF  1               ; uses increments/decrements to predict result & result flags
0040DF  1  A5 rr        chkadd:  lda adrf        ;add V-flag if overflow
0040E1  1  29 83                and #$83        ;keep N-----ZC / clear V
0040E3  1  48                   pha
0040E4  1  A5 rr                lda ad1         ;test sign un:=al between operands
0040E6  1  45 rr                eor ad2
0040E8  1  30 0A                bmi ckad1       ;no overflow possible - operands have different sign
0040EA  1  A5 rr                lda ad1         ;test sign :=al between operands and result
0040EC  1  45 rr                eor adrl
0040EE  1  10 04                bpl ckad1       ;no overflow occured - operand and result have same sign
0040F0  1  68                   pla
0040F1  1  09 40                ora #$40        ;set V
0040F3  1  48                   pha
0040F4  1  68           ckad1:   pla
0040F5  1  85 rr                sta adrf        ;save expected flags
0040F7  1               ; binary ADC / SBC zp
0040F7  1  08                   php             ;save carry for subtract
0040F8  1  A5 rr                lda ad1
0040FA  1  65 rr                adc ad2         ;perform add
0040FC  1  08                   php
0040FD  1  C5 rr                cmp adrl        ;check result
0040FF  1  F0 03 20 58          trap_ne         ;bad result
004103  1  44           
004104  1  68                   pla             ;check flags
004105  1  29 C3                and #$c3        ;mask NV----ZC
004107  1  C5 rr                cmp adrf
004109  1  F0 03 20 58          trap_ne         ;bad flags
00410D  1  44           
00410E  1  28                   plp
00410F  1  08                   php             ;save carry for next add
004110  1  A5 rr                lda ad1
004112  1  E5 rr                sbc sb2         ;perform subtract
004114  1  08                   php
004115  1  C5 rr                cmp adrl        ;check result
004117  1  F0 03 20 58          trap_ne         ;bad result
00411B  1  44           
00411C  1  68                   pla             ;check flags
00411D  1  29 C3                and #$c3        ;mask NV----ZC
00411F  1  C5 rr                cmp adrf
004121  1  F0 03 20 58          trap_ne         ;bad flags
004125  1  44           
004126  1  28                   plp
004127  1               ; binary ADC / SBC abs
004127  1  08                   php             ;save carry for subtract
004128  1  A5 rr                lda ad1
00412A  1  6D 03 02             adc ada2        ;perform add
00412D  1  08                   php
00412E  1  C5 rr                cmp adrl        ;check result
004130  1  F0 03 20 58          trap_ne         ;bad result
004134  1  44           
004135  1  68                   pla             ;check flags
004136  1  29 C3                and #$c3        ;mask NV----ZC
004138  1  C5 rr                cmp adrf
00413A  1  F0 03 20 58          trap_ne         ;bad flags
00413E  1  44           
00413F  1  28                   plp
004140  1  08                   php             ;save carry for next add
004141  1  A5 rr                lda ad1
004143  1  ED 04 02             sbc sba2        ;perform subtract
004146  1  08                   php
004147  1  C5 rr                cmp adrl        ;check result
004149  1  F0 03 20 58          trap_ne         ;bad result
00414D  1  44           
00414E  1  68                   pla             ;check flags
00414F  1  29 C3                and #$c3        ;mask NV----ZC
004151  1  C5 rr                cmp adrf
004153  1  F0 03 20 58          trap_ne         ;bad flags
004157  1  44           
004158  1  28                   plp
004159  1               ; binary ADC / SBC #
004159  1  08                   php             ;save carry for subtract
00415A  1  A5 rr                lda ad2
00415C  1  8D 12 02             sta ex_adci+1   ;set ADC # operand
00415F  1  A5 rr                lda ad1
004161  1  20 11 02             jsr ex_adci     ;execute ADC # in RAM
004164  1  08                   php
004165  1  C5 rr                cmp adrl        ;check result
004167  1  F0 03 20 58          trap_ne         ;bad result
00416B  1  44           
00416C  1  68                   pla             ;check flags
00416D  1  29 C3                and #$c3        ;mask NV----ZC
00416F  1  C5 rr                cmp adrf
004171  1  F0 03 20 58          trap_ne         ;bad flags
004175  1  44           
004176  1  28                   plp
004177  1  08                   php             ;save carry for next add
004178  1  A5 rr                lda sb2
00417A  1  8D 15 02             sta ex_sbci+1   ;set SBC # operand
00417D  1  A5 rr                lda ad1
00417F  1  20 14 02             jsr ex_sbci     ;execute SBC # in RAM
004182  1  08                   php
004183  1  C5 rr                cmp adrl        ;check result
004185  1  F0 03 20 58          trap_ne         ;bad result
004189  1  44           
00418A  1  68                   pla             ;check flags
00418B  1  29 C3                and #$c3        ;mask NV----ZC
00418D  1  C5 rr                cmp adrf
00418F  1  F0 03 20 58          trap_ne         ;bad flags
004193  1  44           
004194  1  28                   plp
004195  1               ; binary ADC / SBC zp,x
004195  1  08                   php             ;save carry for subtract
004196  1  A5 rr                lda ad1
004198  1  75 00                adc 0,x         ;perform add
00419A  1  08                   php
00419B  1  C5 rr                cmp adrl        ;check result
00419D  1  F0 03 20 58          trap_ne         ;bad result
0041A1  1  44           
0041A2  1  68                   pla             ;check flags
0041A3  1  29 C3                and #$c3        ;mask NV----ZC
0041A5  1  C5 rr                cmp adrf
0041A7  1  F0 03 20 58          trap_ne         ;bad flags
0041AB  1  44           
0041AC  1  28                   plp
0041AD  1  08                   php             ;save carry for next add
0041AE  1  A5 rr                lda ad1
0041B0  1  F5 04                sbc sb2-ad2,x   ;perform subtract
0041B2  1  08                   php
0041B3  1  C5 rr                cmp adrl        ;check result
0041B5  1  F0 03 20 58          trap_ne         ;bad result
0041B9  1  44           
0041BA  1  68                   pla             ;check flags
0041BB  1  29 C3                and #$c3        ;mask NV----ZC
0041BD  1  C5 rr                cmp adrf
0041BF  1  F0 03 20 58          trap_ne         ;bad flags
0041C3  1  44           
0041C4  1  28                   plp
0041C5  1               ; binary ADC / SBC abs,x
0041C5  1  08                   php             ;save carry for subtract
0041C6  1  A5 rr                lda ad1
0041C8  1  7D rr rr             adc a:ada2-ad2,x  ;perform add
0041CB  1  08                   php
0041CC  1  C5 rr                cmp adrl        ;check result
0041CE  1  F0 03 20 58          trap_ne         ;bad result
0041D2  1  44           
0041D3  1  68                   pla             ;check flags
0041D4  1  29 C3                and #$c3        ;mask NV----ZC
0041D6  1  C5 rr                cmp adrf
0041D8  1  F0 03 20 58          trap_ne         ;bad flags
0041DC  1  44           
0041DD  1  28                   plp
0041DE  1  08                   php             ;save carry for next add
0041DF  1  A5 rr                lda ad1
0041E1  1  FD rr rr             sbc a:sba2-ad2,x  ;perform subtract
0041E4  1  08                   php
0041E5  1  C5 rr                cmp adrl        ;check result
0041E7  1  F0 03 20 58          trap_ne         ;bad result
0041EB  1  44           
0041EC  1  68                   pla             ;check flags
0041ED  1  29 C3                and #$c3        ;mask NV----ZC
0041EF  1  C5 rr                cmp adrf
0041F1  1  F0 03 20 58          trap_ne         ;bad flags
0041F5  1  44           
0041F6  1  28                   plp
0041F7  1               ; binary ADC / SBC abs,y
0041F7  1  08                   php             ;save carry for subtract
0041F8  1  A5 rr                lda ad1
0041FA  1  79 04 01             adc ada2-$ff,y  ;perform add
0041FD  1  08                   php
0041FE  1  C5 rr                cmp adrl        ;check result
004200  1  F0 03 20 58          trap_ne         ;bad result
004204  1  44           
004205  1  68                   pla             ;check flags
004206  1  29 C3                and #$c3        ;mask NV----ZC
004208  1  C5 rr                cmp adrf
00420A  1  F0 03 20 58          trap_ne         ;bad flags
00420E  1  44           
00420F  1  28                   plp
004210  1  08                   php             ;save carry for next add
004211  1  A5 rr                lda ad1
004213  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
004216  1  08                   php
004217  1  C5 rr                cmp adrl        ;check result
004219  1  F0 03 20 58          trap_ne         ;bad result
00421D  1  44           
00421E  1  68                   pla             ;check flags
00421F  1  29 C3                and #$c3        ;mask NV----ZC
004221  1  C5 rr                cmp adrf
004223  1  F0 03 20 58          trap_ne         ;bad flags
004227  1  44           
004228  1  28                   plp
004229  1               ; binary ADC / SBC (zp,x)
004229  1  08                   php             ;save carry for subtract
00422A  1  A5 rr                lda ad1
00422C  1  61 rr                adc (< adi2-ad2,x) ;perform add
00422E  1  08                   php
00422F  1  C5 rr                cmp adrl        ;check result
004231  1  F0 03 20 58          trap_ne         ;bad result
004235  1  44           
004236  1  68                   pla             ;check flags
004237  1  29 C3                and #$c3        ;mask NV----ZC
004239  1  C5 rr                cmp adrf
00423B  1  F0 03 20 58          trap_ne         ;bad flags
00423F  1  44           
004240  1  28                   plp
004241  1  08                   php             ;save carry for next add
004242  1  A5 rr                lda ad1
004244  1  E1 rr                sbc (< sbi2-ad2,x) ;perform subtract
004246  1  08                   php
004247  1  C5 rr                cmp adrl        ;check result
004249  1  F0 03 20 58          trap_ne         ;bad result
00424D  1  44           
00424E  1  68                   pla             ;check flags
00424F  1  29 C3                and #$c3        ;mask NV----ZC
004251  1  C5 rr                cmp adrf
004253  1  F0 03 20 58          trap_ne         ;bad flags
004257  1  44           
004258  1  28                   plp
004259  1               ; binary ADC / SBC (abs),y
004259  1  08                   php             ;save carry for subtract
00425A  1  A5 rr                lda ad1
00425C  1  71 rr                adc (adiy2),y   ;perform add
00425E  1  08                   php
00425F  1  C5 rr                cmp adrl        ;check result
004261  1  F0 03 20 58          trap_ne         ;bad result
004265  1  44           
004266  1  68                   pla             ;check flags
004267  1  29 C3                and #$c3        ;mask NV----ZC
004269  1  C5 rr                cmp adrf
00426B  1  F0 03 20 58          trap_ne         ;bad flags
00426F  1  44           
004270  1  28                   plp
004271  1  08                   php             ;save carry for next add
004272  1  A5 rr                lda ad1
004274  1  F1 rr                sbc (sbiy2),y   ;perform subtract
004276  1  08                   php
004277  1  C5 rr                cmp adrl        ;check result
004279  1  F0 03 20 58          trap_ne         ;bad result
00427D  1  44           
00427E  1  68                   pla             ;check flags
00427F  1  29 C3                and #$c3        ;mask NV----ZC
004281  1  C5 rr                cmp adrf
004283  1  F0 03 20 58          trap_ne         ;bad flags
004287  1  44           
004288  1  28                   plp
004289  1  60                   rts
00428A  1               
00428A  1               ; target for the jump absolute test
00428A  1  88                   dey
00428B  1  88                   dey
00428C  1               test_far:
00428C  1  08                   php             ;either SP or Y count will fail, if we do not hit
00428D  1  88                   dey
00428E  1  88                   dey
00428F  1  88                   dey
004290  1  28                   plp
004291  1  90 03 20 58          trap_cs         ;flags loaded?
004295  1  44           
004296  1  50 03 20 58          trap_vs
00429A  1  44           
00429B  1  10 03 20 58          trap_mi
00429F  1  44           
0042A0  1  D0 03 20 58          trap_eq
0042A4  1  44           
0042A5  1  C9 46                cmp #'F'        ;registers loaded?
0042A7  1  F0 03 20 58          trap_ne
0042AB  1  44           
0042AC  1  E0 41                cpx #'A'
0042AE  1  F0 03 20 58          trap_ne
0042B2  1  44           
0042B3  1  C0 4F                cpy #('R'-3)
0042B5  1  F0 03 20 58          trap_ne
0042B9  1  44           
0042BA  1  48                   pha             ;save a,x
0042BB  1  8A                   txa
0042BC  1  48                   pha
0042BD  1  BA                   tsx
0042BE  1  E0 FD                cpx #$fd        ;check SP
0042C0  1  F0 03 20 58          trap_ne
0042C4  1  44           
0042C5  1  68                   pla             ;restore x
0042C6  1  AA                   tax
0042C7  1  A9 FF 48 28          set_stat $ff
0042CB  1  68                   pla             ;restore a
0042CC  1  E8                   inx             ;return registers with modifications
0042CD  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
0042CF  1  4C F3 09             jmp far_ret
0042D2  1               
0042D2  1               ; target for the jump indirect test
0042D2  1               .if (* & 1)=1
0042D2  1                       .byte 0
0042D2  1               .endif
0042D2  1  DB 42        ptr_tst_ind: .word test_ind
0042D4  1  7B 0A        ptr_ind_ret: .word ind_ret
0042D6  1  20 58 44             trap            ;runover protection
0042D9  1  88                   dey
0042DA  1  88                   dey
0042DB  1               test_ind:
0042DB  1  08                   php             ;either SP or Y count will fail, if we do not hit
0042DC  1  88                   dey
0042DD  1  88                   dey
0042DE  1  88                   dey
0042DF  1  28                   plp
0042E0  1  90 03 20 58          trap_cs         ;flags loaded?
0042E4  1  44           
0042E5  1  50 03 20 58          trap_vs
0042E9  1  44           
0042EA  1  10 03 20 58          trap_mi
0042EE  1  44           
0042EF  1  D0 03 20 58          trap_eq
0042F3  1  44           
0042F4  1  C9 49                cmp #'I'        ;registers loaded?
0042F6  1  F0 03 20 58          trap_ne
0042FA  1  44           
0042FB  1  E0 4E                cpx #'N'
0042FD  1  F0 03 20 58          trap_ne
004301  1  44           
004302  1  C0 41                cpy #('D'-3)
004304  1  F0 03 20 58          trap_ne
004308  1  44           
004309  1  48                   pha             ;save a,x
00430A  1  8A                   txa
00430B  1  48                   pha
00430C  1  BA                   tsx
00430D  1  E0 FD                cpx #$fd        ;check SP
00430F  1  F0 03 20 58          trap_ne
004313  1  44           
004314  1  68                   pla             ;restore x
004315  1  AA                   tax
004316  1  A9 FF 48 28          set_stat $ff
00431A  1  68                   pla             ;restore a
00431B  1  E8                   inx             ;return registers with modifications
00431C  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
00431E  1  6C D4 42             jmp (ptr_ind_ret)
004321  1  20 58 44             trap            ;runover protection
004324  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
004327  1               
004327  1               ; target for the jump subroutine test
004327  1  88                   dey
004328  1  88                   dey
004329  1               test_jsr:
004329  1  08                   php             ;either SP or Y count will fail, if we do not hit
00432A  1  88                   dey
00432B  1  88                   dey
00432C  1  88                   dey
00432D  1  28                   plp
00432E  1  90 03 20 58          trap_cs         ;flags loaded?
004332  1  44           
004333  1  50 03 20 58          trap_vs
004337  1  44           
004338  1  10 03 20 58          trap_mi
00433C  1  44           
00433D  1  D0 03 20 58          trap_eq
004341  1  44           
004342  1  C9 4A                cmp #'J'        ;registers loaded?
004344  1  F0 03 20 58          trap_ne
004348  1  44           
004349  1  E0 53                cpx #'S'
00434B  1  F0 03 20 58          trap_ne
00434F  1  44           
004350  1  C0 4F                cpy #('R'-3)
004352  1  F0 03 20 58          trap_ne
004356  1  44           
004357  1  48                   pha             ;save a,x
004358  1  8A                   txa
004359  1  48                   pha
00435A  1  BA                   tsx             ;sp -4? (return addr,a,x)
00435B  1  E0 FB                cpx #$fb
00435D  1  F0 03 20 58          trap_ne
004361  1  44           
004362  1  AD FF 01             lda $1ff        ;propper return on stack
004365  1  C9 0A                cmp #>(jsr_ret)
004367  1  F0 03 20 58          trap_ne
00436B  1  44           
00436C  1  AD FE 01             lda $1fe
00436F  1  C9 CC                cmp #<(jsr_ret)
004371  1  F0 03 20 58          trap_ne
004375  1  44           
004376  1  A9 FF 48 28          set_stat $ff
00437A  1  68                   pla             ;pull x,a
00437B  1  AA                   tax
00437C  1  68                   pla
00437D  1  E8                   inx             ;return registers with modifications
00437E  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
004380  1  60                   rts
004381  1  20 58 44             trap            ;runover protection
004384  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
004387  1               
004387  1               ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
004387  1               nmi_trap:
004387  1  20 58 44             trap            ;check stack for conditions at NMI
00438A  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
00438D  1               res_trap:
00438D  1                       ;trap            ;unexpected RESET
00438D  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
004390  1               
004390  1  88                   dey
004391  1  88                   dey
004392  1               irq_trap:                ;BRK test or unextpected BRK or IRQ
004392  1  08                   php             ;either SP or Y count will fail, if we do not hit
004393  1  88                   dey
004394  1  88                   dey
004395  1  88                   dey
004396  1                       ;next traps could be caused by unexpected BRK or IRQ
004396  1                       ;check stack for BREAK and originating location
004396  1                       ;possible jump/branch into weeds (uninitialized space)
004396  1  C9 BD                cmp #$ff-'B'    ;BRK pass 2 registers loaded?
004398  1  F0 5A                beq break2
00439A  1  C9 42                cmp #'B'        ;BRK pass 1 registers loaded?
00439C  1  F0 03 20 58          trap_ne
0043A0  1  44           
0043A1  1  E0 52                cpx #'R'
0043A3  1  F0 03 20 58          trap_ne
0043A7  1  44           
0043A8  1  C0 48                cpy #'K'-3
0043AA  1  F0 03 20 58          trap_ne
0043AE  1  44           
0043AF  1  85 rr                sta irq_a       ;save registers during break test
0043B1  1  86 rr                stx irq_x
0043B3  1  BA                   tsx             ;test break on stack
0043B4  1  BD 02 01             lda $102,x
0043B7  1  C9 30                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
0043B9  1  F0 03 20 58          trap_ne         ; - no break flag on stack
0043BD  1  44           
0043BE  1  68                   pla
0043BF  1  C9 34                cmp_flag intdis ;should have added interrupt disable
0043C1  1  F0 03 20 58          trap_ne
0043C5  1  44           
0043C6  1  BA                   tsx
0043C7  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
0043C9  1  F0 03 20 58          trap_ne
0043CD  1  44           
0043CE  1  AD FF 01             lda $1ff        ;propper return on stack
0043D1  1  C9 0B                cmp #>(brk_ret0)
0043D3  1  F0 03 20 58          trap_ne
0043D7  1  44           
0043D8  1  AD FE 01             lda $1fe
0043DB  1  C9 1E                cmp #<(brk_ret0)
0043DD  1  F0 03 20 58          trap_ne
0043E1  1  44           
0043E2  1  A9 FF                load_flag $ff
0043E4  1  48                   pha
0043E5  1  A6 rr                ldx irq_x
0043E7  1  E8                   inx             ;return registers with modifications
0043E8  1  A5 rr                lda irq_a
0043EA  1  49 AA                eor #$aa
0043EC  1  28                   plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
0043ED  1  40                   rti
0043EE  1  20 58 44             trap            ;runover protection
0043F1  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
0043F4  1               
0043F4  1               break2:                  ;BRK pass 2
0043F4  1  E0 AD                cpx #$ff-'R'
0043F6  1  F0 03 20 58          trap_ne
0043FA  1  44           
0043FB  1  C0 B1                cpy #$ff-'K'-3
0043FD  1  F0 03 20 58          trap_ne
004401  1  44           
004402  1  85 rr                sta irq_a       ;save registers during break test
004404  1  86 rr                stx irq_x
004406  1  BA                   tsx             ;test break on stack
004407  1  BD 02 01             lda $102,x
00440A  1  C9 FF                cmp_flag $ff    ;break test should have B=1
00440C  1  F0 03 20 58          trap_ne         ; - no break flag on stack
004410  1  44           
004411  1  68                   pla
004412  1  09 08                ora #decmode    ;ignore decmode cleared if 65c02
004414  1  C9 FF                cmp_flag $ff    ;actual passed flags
004416  1  F0 03 20 58          trap_ne
00441A  1  44           
00441B  1  BA                   tsx
00441C  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
00441E  1  F0 03 20 58          trap_ne
004422  1  44           
004423  1  AD FF 01             lda $1ff        ;propper return on stack
004426  1  C9 0B                cmp #>(brk_ret1)
004428  1  F0 03 20 58          trap_ne
00442C  1  44           
00442D  1  AD FE 01             lda $1fe
004430  1  C9 53                cmp #<(brk_ret1)
004432  1  F0 03 20 58          trap_ne
004436  1  44           
004437  1  A9 04                load_flag intdis
004439  1  48                   pha
00443A  1  A6 rr                ldx irq_x
00443C  1  E8                   inx             ;return registers with modifications
00443D  1  A5 rr                lda irq_a
00443F  1  49 AA                eor #$aa
004441  1  28                   plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
004442  1  40                   rti
004443  1  20 58 44             trap            ;runover protection
004446  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
004449  1               .if report = 1
004449  1                       .include "report.i65"
004449  2               ;**** report 6502 funtional test errors to standard I/O ****
004449  2               ;
004449  2               ;this include file is part of the 6502 functional tests
004449  2               ;it is used when you configure report = 1 in the tests
004449  2               ;
004449  2               ;to adopt the standard output vectors of your test environment
004449  2               ;you must modify the rchar and rget subroutines in this include
004449  2               ;
004449  2               ;I/O hardware may have to be initialized in report_init
004449  2               
004449  2               ;print message macro - \1 = message location
004449  2               .macro  rprt addr
004449  2                       .local loop
004449  2                       ldx #0
004449  2                       lda addr
004449  2               loop:
004449  2                       jsr rchar
004449  2                       inx
004449  2                       lda addr,x
004449  2                       bne loop
004449  2               .endmacro
004449  2               
004449  2               ;initialize I/O as required (example: configure & enable ACIA)
004449  2               report_init:
004449  2                       ;nothing to initialize
004449  2  A2 00 AD 66          rprt rmsg_start
00444D  2  45 20 62 45  
004451  2  E8 BD 66 45  
004457  2  60                   rts
004458  2               
004458  2               ;show stack (with saved registers), zeropage and absolute memory workspace
004458  2               ;after an error was trapped in the test program
004458  2               report_error:
004458  2               ;save registers
004458  2  08                   php
004459  2  48                   pha
00445A  2  8A                   txa
00445B  2  48                   pha
00445C  2  98                   tya
00445D  2  48                   pha
00445E  2  D8                   cld
00445F  2               ;show stack with index to registers at error
00445F  2  A2 00 AD 7A          rprt rmsg_stack
004463  2  45 20 62 45  
004467  2  E8 BD 7A 45  
00446D  2  BA                   tsx
00446E  2  E8                   inx
00446F  2  A9 01                lda #1      ;address high
004471  2  20 4E 45             jsr rhex
004474  2  8A                   txa         ;address low
004475  2  20 4E 45             jsr rhex
004478  2  20 4A 45     rstack:  jsr rspace
00447B  2  BD 00 01             lda $100,x  ;stack data
00447E  2  20 4E 45             jsr rhex
004481  2  E8                   inx
004482  2  D0 F4                bne rstack
004484  2  20 41 45             jsr rcrlf   ;new line
004487  2               ;show zero page workspace
004487  2  A9 00                lda #0
004489  2  20 4E 45             jsr rhex
00448C  2  A9 rr                lda #zpt
00448E  2  AA                   tax
00448F  2  20 4E 45             jsr rhex
004492  2  20 4A 45     rzp:     jsr rspace
004495  2  B5 00                lda 0,x
004497  2  20 4E 45             jsr rhex
00449A  2  E8                   inx
00449B  2  E0 rr                cpx #zp_bss
00449D  2  D0 F3                bne rzp
00449F  2  20 41 45             jsr rcrlf
0044A2  2               ;show absolute workspace
0044A2  2  A9 02                lda #>(data_segment)
0044A4  2  20 4E 45             jsr rhex
0044A7  2  A9 00                lda #<(data_segment)
0044A9  2  20 4E 45             jsr rhex
0044AC  2  A2 00                ldx #0
0044AE  2  20 4A 45     rabs:   jsr rspace
0044B1  2  BD 00 02             lda data_segment,x
0044B4  2  20 4E 45             jsr rhex
0044B7  2  E8                   inx
0044B8  2  E0 08                cpx #<(data_bss-data_segment)
0044BA  2  D0 F2                bne rabs
0044BC  2               ;ask to continue
0044BC  2  A2 00 AD 96          rprt rmsg_cont
0044C0  2  45 20 62 45  
0044C4  2  E8 BD 96 45  
0044CA  2  20 37 45     rerr1:   jsr rget
0044CD  2  C9 53                cmp #'S'
0044CF  2  F0 0B                beq rskip
0044D1  2  C9 43                cmp #'C'
0044D3  2  D0 F5                bne rerr1
0044D5  2               ;restore registers
0044D5  2  68                   pla
0044D6  2  A8                   tay
0044D7  2  68                   pla
0044D8  2  AA                   tax
0044D9  2  68                   pla
0044DA  2  28                   plp
0044DB  2  60                   rts
0044DC  2               ;skip the current test
0044DC  2  A9 F0        rskip:   lda #$f0            ;already end of tests?
0044DE  2  CD 00 02             cmp test_case
0044E1  2  F0 E7                beq rerr1           ;skip is not available
0044E3  2  A2 FF                ldx #$ff            ;clear stack
0044E5  2  9A                   txs
0044E6  2  EE 00 02             inc test_case       ;next test
0044E9  2  A9 00                lda #<(start)      ;find begin of test
0044EB  2  85 rr                sta zpt
0044ED  2  A9 04                lda #>(start)
0044EF  2  85 rr                sta zpt+1
0044F1  2  A0 04        rskipl1: ldy #4              ;search pattern
0044F3  2  B1 rr        rskipl2: lda (zpt),y         ;next byte
0044F5  2  D9 1C 45             cmp rmark,y
0044F8  2  D0 0A                bne rskipnx         ;no match
0044FA  2  88                   dey
0044FB  2  30 0F                bmi rskipf          ;found pattern
0044FD  2  C0 01                cpy #1              ;skip immediate value
0044FF  2  D0 F2                bne rskipl2
004501  2  88                   dey
004502  2  F0 EF                beq rskipl2
004504  2               
004504  2  E6 rr        rskipnx: inc zpt             ;next RAM location
004506  2  D0 E9                bne rskipl1
004508  2  E6 rr                inc zpt+1
00450A  2  D0 E5                bne rskipl1
00450C  2               
00450C  2  A0 01        rskipf:  ldy #1              ;pattern found - check test number
00450E  2  B1 rr                lda (zpt),y         ;test number
004510  2  C9 F0                cmp #$f0            ;end of last test?
004512  2  F0 05                beq rskipe          ;ask to rerun all
004514  2  CD 00 02             cmp test_case       ;is next test?
004517  2  D0 EB                bne rskipnx         ;continue searching
004519  2  6C rr rr     rskipe:  jmp (zpt)           ;start next test or rerun at end of tests
00451C  2               
00451C  2  A9 00        rmark:   lda #0              ;begin of test search pattern
00451E  2  8D 00 02             sta test_case
004521  2               
004521  2               ;show test has ended, ask to repeat
004521  2               report_success:
004521  2               .if rep_int = 1
004521  2                       rprt rmsg_priority
004521  2                       lda data_segment    ;show interrupt sequence
004521  2                       jsr rhex
004521  2                       jsr rspace
004521  2                       lda data_segment+1
004521  2                       jsr rhex
004521  2                       jsr rspace
004521  2                       lda data_segment+2
004521  2                       jsr rhex
004521  2               .endif
004521  2  A2 00 AD C8          rprt rmsg_success
004525  2  45 20 62 45  
004529  2  E8 BD C8 45  
00452F  2  20 37 45     rsuc1:   jsr rget
004532  2  C9 52                cmp #'R'
004534  2  D0 F9                bne rsuc1
004536  2  60                   rts
004537  2               
004537  2               ;input subroutine
004537  2               ;get a character from standard input
004537  2               ;adjust according to the needs in your test environment
004537  2               rget:                ;get character in A
004537  2               ;rget1
004537  2               ;        lda $bff1   ;wait RDRF
004537  2               ;        and #8
004537  2               ;        beq rget1
004537  2               ;not a real ACIA - so RDRF is not checked
004537  2               ;        lda $bff0   ;read acia rx reg
004537  2  AD 04 F0             lda $f004   ;Kowalski simulator default
00453A  2               ;the load can be replaced by a call to a kernal routine
00453A  2               ;        jsr $ffcf   ;example: CHRIN for a C64
00453A  2  C9 61                cmp #'a'    ;lower case
00453C  2  90 02                bcc rget1
00453E  2  29 5F                and #$5f    ;convert to upper case
004540  2  60           rget1:   rts
004541  2               
004541  2               ;output subroutines
004541  2  A9 0A        rcrlf:   lda #10
004543  2  20 62 45             jsr rchar
004546  2  A9 0D                lda #13
004548  2  D0 18                bne rchar
00454A  2               
00454A  2  A9 20        rspace:  lda #' '
00454C  2  D0 14                bne rchar
00454E  2               
00454E  2  48           rhex:    pha         ;report hex byte in A
00454F  2  4A                   lsr a       ;high nibble first
004550  2  4A                   lsr a
004551  2  4A                   lsr a
004552  2  4A                   lsr a
004553  2  20 59 45             jsr rnib
004556  2  68                   pla         ;now low nibble
004557  2  29 0F                and #$f
004559  2               
004559  2  18           rnib:    clc         ;report nibble in A
00455A  2  69 30                adc #'0'    ;make printable 0-9
00455C  2  C9 3A                cmp #'9'+1
00455E  2  90 02                bcc rchar
004560  2  69 06                adc #6      ;make printable A-F
004562  2               
004562  2               ;send a character to standard output
004562  2               ;adjust according to the needs in your test environment
004562  2               ;register X needs to be preserved!
004562  2               rchar:               ;report character in A
004562  2               ;        pha         ;wait TDRF
004562  2               ;rchar1  lda $bff1
004562  2               ;        and #$10
004562  2               ;        beq rchar1
004562  2               ;        pla
004562  2               ;not a real ACIA - so TDRF is not checked
004562  2               ;        sta $bff0   ;write acia tx reg
004562  2  8D 01 F0             sta $f001   ;Kowalski simulator default
004565  2               ;the store can be replaced by a call to a kernal routine
004565  2               ;        jsr $ffd2   ;example: CHROUT for a C64
004565  2  60                   rts
004566  2               
004566  2               rmsg_start:
004566  2  0A 0D 53 74          .byte  10,13,"Started testing",10,13,0
00456A  2  61 72 74 65  
00456E  2  64 20 74 65  
00457A  2               rmsg_stack:
00457A  2  0A 0D 72 65          .byte  10,13,"regs Y  X  A  PS PCLPCH",10,13,0
00457E  2  67 73 20 59  
004582  2  20 20 58 20  
004596  2               rmsg_cont:
004596  2  0A 0D 70 72          .byte  10,13,"press C to continue or S to skip current test",10,13,0
00459A  2  65 73 73 20  
00459E  2  43 20 74 6F  
0045C8  2               rmsg_success:
0045C8  2  0A 0D 41 6C          .byte  10,13,"All tests completed, press R to repeat",10,13,0
0045CC  2  6C 20 74 65  
0045D0  2  73 74 73 20  
0045F3  2               .if rep_int = 1
0045F3  2               rmsg_priority:
0045F3  2                       .byte  10,13,"interrupt sequence (NMI IRQ BRK) ",0
0045F3  2               .endif
0045F3  2               
0045F3  2               
0045F3  1               .endif
0045F3  1               
0045F3  1               ;copy of data to initialize BSS segment
0045F3  1               .if load_data_direct <> 1
0045F3  1               zp_init:
0045F3  1               zp1_:    .byte  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0045F3  1               zp7f_:   .byte  $7f             ;test pattern for compare
0045F3  1               ;logical zeropage operands
0045F3  1               zpOR_:   .byte  0,$1f,$71,$80   ;test pattern for OR
0045F3  1               zpAN_:   .byte  $0f,$ff,$7f,$80 ;test pattern for AND
0045F3  1               zpEO_:   .byte  $ff,$0f,$8f,$8f ;test pattern for EOR
0045F3  1               ;indirect addressing pointers
0045F3  1               ind1_:   .word  abs1            ;indirect pointer to pattern in absolute memory
0045F3  1                       .word  abs1+1
0045F3  1                       .word  abs1+2
0045F3  1                       .word  abs1+3
0045F3  1                       .word  abs7f
0045F3  1               inw1_:   .word  abs1-$f8        ;indirect pointer for wrap-test pattern
0045F3  1               indt_:   .word  abst            ;indirect pointer to store area in absolute memory
0045F3  1                       .word  abst+1
0045F3  1                       .word  abst+2
0045F3  1                       .word  abst+3
0045F3  1               inwt_:   .word  abst-$f8        ;indirect pointer for wrap-test store
0045F3  1               indAN_:  .word  absAN           ;indirect pointer to AND pattern in absolute memory
0045F3  1                       .word  absAN+1
0045F3  1                       .word  absAN+2
0045F3  1                       .word  absAN+3
0045F3  1               indEO_:  .word  absEO           ;indirect pointer to EOR pattern in absolute memory
0045F3  1                       .word  absEO+1
0045F3  1                       .word  absEO+2
0045F3  1                       .word  absEO+3
0045F3  1               indOR_:  .word  absOR           ;indirect pointer to OR pattern in absolute memory
0045F3  1                       .word  absOR+1
0045F3  1                       .word  absOR+2
0045F3  1                       .word  absOR+3
0045F3  1               ;add/subtract indirect pointers
0045F3  1               adi2_:   .word  ada2            ;indirect pointer to operand 2 in absolute memory
0045F3  1               sbi2_:   .word  sba2            ;indirect pointer to complemented operand 2 (SBC)
0045F3  1               adiy2_:  .word  ada2-$ff        ;with offset for indirect indexed
0045F3  1               sbiy2_:  .word  sba2-$ff
0045F3  1               zp_end:
0045F3  1               .if (zp_end - zp_init) <> (zp_bss_end - zp_bss)
0045F3  1                       ;force assembler error if size is different
0045F3  1                       ERROR ERROR ERROR   ;mismatch between bss and zeropage data
0045F3  1               .endif
0045F3  1               data_init:
0045F3  1               ex_and_: and #0              ;execute immediate opcodes
0045F3  1                       rts
0045F3  1               ex_eor_: eor #0              ;execute immediate opcodes
0045F3  1                       rts
0045F3  1               ex_ora_: ora #0              ;execute immediate opcodes
0045F3  1                       rts
0045F3  1               ex_adc_: adc #0              ;execute immediate opcodes
0045F3  1                       rts
0045F3  1               ex_sbc_: sbc #0              ;execute immediate opcodes
0045F3  1                       rts
0045F3  1               abs1_:   .byte  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0045F3  1               abs7f_:  .byte  $7f             ;test pattern for compare
0045F3  1               ;loads
0045F3  1               fLDx_:   .byte  fn,fn,0,fz      ;expected flags for load
0045F3  1               ;shifts
0045F3  1               rASL_:                       ;expected result ASL & ROL -carry
0045F3  1               rROL_:   .byte  $86,$04,$82,0   ; "
0045F3  1               rROLc_:  .byte  $87,$05,$83,1   ;expected result ROL +carry
0045F3  1               rLSR_:                       ;expected result LSR & ROR -carry
0045F3  1               rROR_:   .byte  $61,$41,$20,0   ; "
0045F3  1               rRORc_:  .byte  $e1,$c1,$a0,$80 ;expected result ROR +carry
0045F3  1               fASL_:                       ;expected flags for shifts
0045F3  1               fROL_:   .byte  fnc,fc,fn,fz    ;no carry in
0045F3  1               fROLc_:  .byte  fnc,fc,fn,0     ;carry in
0045F3  1               fLSR_:
0045F3  1               fROR_:   .byte  fc,0,fc,fz      ;no carry in
0045F3  1               fRORc_:  .byte  fnc,fn,fnc,fn   ;carry in
0045F3  1               ;increments (decrements)
0045F3  1               rINC_:   .byte  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0045F3  1               fINC_:   .byte  0,fn,fn,fz,0    ;expected flags for INC/DEC
0045F3  1               ;logical memory operand
0045F3  1               absOR_:  .byte  0,$1f,$71,$80   ;test pattern for OR
0045F3  1               absAN_:  .byte  $0f,$ff,$7f,$80 ;test pattern for AND
0045F3  1               absEO_:  .byte  $ff,$0f,$8f,$8f ;test pattern for EOR
0045F3  1               ;logical accu operand
0045F3  1               absORa_: .byte  0,$f1,$1f,0     ;test pattern for OR
0045F3  1               absANa_: .byte  $f0,$ff,$ff,$ff ;test pattern for AND
0045F3  1               absEOa_: .byte  $ff,$f0,$f0,$0f ;test pattern for EOR
0045F3  1               ;logical results
0045F3  1               absrlo_: .byte  0,$ff,$7f,$80
0045F3  1               absflo_: .byte  fz,fn,0,fn
0045F3  1               data_end:
0045F3  1               .if (data_end - data_init) <> (data_bss_end - data_bss)
0045F3  1                       ;force assembler error if size is different
0045F3  1                       ERROR ERROR ERROR   ;mismatch between bss and data
0045F3  1               .endif
0045F3  1               
0045F3  1               vec_init:
0045F3  1                       .word  nmi_trap
0045F3  1                       .word  res_trap
0045F3  1                       .word  irq_trap
0045F3  1               vec_bss := $fffa
0045F3  1               .endif                   ;end of RAM init data
0045F3  1               .if (load_data_direct = 1) & (ROM_vectors = 1)
0045F3  1                       .segment "VECTORS"      ;vectors
0045F3  1  87 43                .word  nmi_trap
0045F5  1  8D 43                .word  res_trap
0045F7  1  92 43                .word  irq_trap
0045F9  1               .endif
0045F9  1               
0045F9  1               
0045F9  1               
